[{"path":"index.html","id":"bienvenido","chapter":"Bienvenido","heading":"Bienvenido","text":"Esta es la versión web de Geocomputación con R, un libro sobre análisis, visualización y modelado de datos geográficos.Nota: La primera edición del libro en inglés ha sido publicada por CRC Press en la [Serie R] (https://www.routledge.com/Chapman--HallCRC--R-Series/book-series/CRCTHERSER).\nPuedes comprar el libro en CRC Press, o en Amazon y acceder la primera edición archivada en la plataforma para libros en abierto bookdown.org.Inspirado en bookdown y en el movimiento del software libre y de código abierto para el sector geoespacial (FOSS4G), este libro es de código abierto.\nEsto garantiza que su contenido sea reproducible y accesible al público en todo el mundo.La versión online del libro está alojada en geocompr.robinlovelace.net y se mantiene actualizada gracias GitHub Actions, que proporciona información sobre su “estado de construcción” de la siguiente manera:Esta versión del libro fue elaborada en GH Actions el 2021-11-30.","code":""},{"path":"index.html","id":"cómo-contribuir","chapter":"Bienvenido","heading":"¿Cómo contribuir?","text":"bookdown hace que editar un libro sea tan fácil como editar una wiki, siempre que tengas una cuenta en (sign-github.com).\nUna vez iniciada tu sesión en GitHub, haz clic en el icono “Editar esta página” (‘Edit page’ en inglés) en el panel derecho del sitio web del libro.\nEsto te llevará una versión editable del archivo original de R Markdown que ha generado la página en la que te encuentras.Para plantear un problema sobre el contenido del libro (por ejemplo, que el código se ejecute) o hacer una solicitud de funcionalidad, consulte el rastreador de problemas.Los responsables del mantenimiento y los colaboradores deben seguir el CÓDIGO DE CONDUCTA de este repositorio.","code":""},{"path":"index.html","id":"reproducibilidad","chapter":"Bienvenido","heading":"Reproducibilidad","text":"Para reproducir el código del libro, se necesita una versión reciente de R y que los paquetes estén actualizados. Estos pueden ser instalados con el siguiente comando (que requiere del paquete remotes):La forma más rápida de reproducir los contenidos del libro si eres principiante en tratar datos geográficos en R puede ser en el navegador web, gracias Binder.Al hacer clic en el siguiente enlace se abrirá una nueva ventana con RStudio Server en su navegador web, lo que te permitirá abrir archivos de capítulos y ejecutar trozos de código para comprobar que el código es reproducible.Si ves algo como la imagen de abajo, enhorabuena, ha funcionado y puedes empezar explorar Geocomputación con R en un entorno en la nube (siendo consciente de las normas de uso de mybinder.org):\nFIGURE 0.1: Screenshot reproducible code contained Geocomputación con R running RStudio Server browser served Binder\nPara reproducir el código del libro en tu propio ordenador, necesitarás una versión reciente de R con paquetes actualizados.\nEstos pueden ser instalados usando la librería remotes.Después de instalar las dependencias del libro, deberías ser capaz de reproducir los fragmentos de código de cada uno de los capítulos del libro.\nSi clonas el repo del libro y accedes la carpeta geocompr, deberías poder reproducir el contenido con el siguiente comando:Echa un vistazo al repositorio de GitHub para los detalles sobre la reproducción del libro.","code":"\ninstall.packages(\"remotes\")\nremotes::install_github(\"geocompr/geocompkg\")\nremotes::install_github(\"nowosad/spData\")\nremotes::install_github(\"nowosad/spDataLarge\")\n\n# Durante el desarrollo de la segunda edición tal vez necesites versiones de desarrollo de\n# otros paquetes para construir el libro, p.ej.:\nremotes::install_github(\"rspatial/terra\")\nremotes::install_github(\"mtennekes/tmap\")\nbookdown::serve_book()"},{"path":"index.html","id":"apoya-el-proyecto","chapter":"Bienvenido","heading":"Apoya el proyecto","text":"Si encuentras el libro útil, por favor, apóyalo mediante:Hablando de él en personaComunicando sobre el libro en medios digitales, por ejemplo, través del hashtag #geocompr en Twitter (véase nuestro Libro de visitas) o haciéndonos saber sobre cursos en los que se utiliza el libroCitándolo o enlazándoloPoniendo estrellas en el repositorio GitHub de geocomprHaciendo reseñas, por ejemplo, en Amazon o GoodreadsHaciendo preguntas o sugerencias sobre el contenido través de GitHub o Twitter.Comprando un ejemplar en papelPuedes encontrar más detalles en github.com/Robinlovelace/geocompr.work licensed Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.","code":""},{"path":"prólogo-1a-edición.html","id":"prólogo-1a-edición","chapter":"Prólogo (1a Edición)","heading":"Prólogo (1a Edición)","text":"Hacer “espacial” en R siempre ha sido una cuestión muy amplia, buscando proporcionar e integrar herramientas de geografía, geoinformática, geocomputación y estadística espacial para cualquier persona interesada en participar: participar en la formulación de preguntas interesantes, contribuir con preguntas fructíferas para la investigación, y escribir y mejorar el código.\nEs decir, hacer “espacial” en R siempre ha incluido código abierto, datos abiertos y reproducibilidad.Hacer “espacial” en R también ha buscado estar abierto la interacción con muchas ramas del análisis de datos espaciales aplicados, y también implementar nuevos avances en la representación de datos y métodos de análisis para exponerlos al escrutinio interdisciplinario.\nComo demuestra este libro, menudo existen flujos de trabajo alternativos para obtener resultados similares partir de datos similares, y podemos aprender de las comparaciones con la forma en que otros crean y entienden sus flujos de trabajo.\nEsto incluye aprender de comunidades similares en torno los SIG de código abierto y lenguajes complementarios como Python, Java, etc.La amplia variedad de capacidades espaciales de R nunca habría evolucionado sin personas dispuestas compartir lo que están creando o adaptando.\nEsto puede incluir material didáctico, software, prácticas de investigación (investigación reproducible, datos abiertos) y combinaciones de todos ellos.\nLos usuarios de R también se han beneficiado enormemente de las bibliotecas geográficas de código abierto como GDAL, GEOS y PROJ.Este libro es un claro ejemplo de que, si eres curioso y estás dispuesto participar, puedes encontrar cosas que es necesario hacer y que se ajustan tus aptitudes.\nCon los avances en la representación de datos y las alternativas de flujo de trabajo, y el número cada vez mayor de nuevos usuarios que menudo están expuestos la línea de comandos cuantitativa aplicada, un libro de este tipo es realmente necesario.\npesar del esfuerzo que supone, los autores se han apoyado mutuamente para sacar adelante la publicación.Por lo tanto, este libro fresco está listo para funcionar; sus autores lo han probado durante muchos seminarios y talleres, por lo que los lectores e instructores podrán beneficiarse de saber que los contenidos han sido y siguen siendo probados por personas como ellos.\nComprométete con los autores y con la comunidad R-spatial, observa el valor de tener más opciones en la construcción de tus flujos de trabajo y, lo más importante, disfruta aplicando lo que aprendes aquí en cosas que te interesan.Roger BivandBergen, September 2018","code":""},{"path":"prefacio.html","id":"prefacio","chapter":"Prefacio","heading":"Prefacio","text":"","code":""},{"path":"prefacio.html","id":"a-quién-va-dirigido-este-libro","chapter":"Prefacio","heading":"A quién va dirigido este libro","text":"Este libro está dirigido personas que quieren analizar, visualizar y modelar datos geográficos con software de código abierto.\nSe basa en R, un lenguaje de programación estadístico que tiene potentes capacidades de procesamiento de datos, de visualización y geoespaciales.\nEl libro cubre una extensa variedad de temas y puede ser de interés para un amplio abanico de personas de campos muy distintos, especialmente:Personas que han aprendido realizar análisis espaciales con un Sistema de Información Geográfica (SIG) de escritorio, como QGIS, ArcGIS, GRASS o SAGA, que quieran acceder un potente lenguaje de programación de (geo)estadística y de visualización y las ventajas de un entorno de línea de comandos (Sherman 2008):\n\nCon la llegada del software SIG “moderno,” la mayoría de la gente quiere apuntar y hacer clic en su camino por la vida. Eso está bien, pero hay una enorme cantidad de flexibilidad y poder esperándote en las líneas de comandos.\nPersonas que han aprendido realizar análisis espaciales con un Sistema de Información Geográfica (SIG) de escritorio, como QGIS, ArcGIS, GRASS o SAGA, que quieran acceder un potente lenguaje de programación de (geo)estadística y de visualización y las ventajas de un entorno de línea de comandos (Sherman 2008):Con la llegada del software SIG “moderno,” la mayoría de la gente quiere apuntar y hacer clic en su camino por la vida. Eso está bien, pero hay una enorme cantidad de flexibilidad y poder esperándote en las líneas de comandos.Estudiantes graduados e investigadores de campos especializados en datos geográficos, como la geografía, la teledetección, la planificación, los SIG y la ciencia de los datos geográficosEstudiantes graduados e investigadores de campos especializados en datos geográficos, como la geografía, la teledetección, la planificación, los SIG y la ciencia de los datos geográficosAcadémicos y estudiantes que trabajan con datos geográficos — en campos como la Geología, la Ciencia Regional, la Biología y la Ecología, las Ciencias Agrícolas, la Arqueología, la Epidemiología, la Modelización del Transporte, y la Ciencia de los Datos en sentido amplio — los cuales requieren la potencia y la flexibilidad de R para su investigaciónAcadémicos y estudiantes que trabajan con datos geográficos — en campos como la Geología, la Ciencia Regional, la Biología y la Ecología, las Ciencias Agrícolas, la Arqueología, la Epidemiología, la Modelización del Transporte, y la Ciencia de los Datos en sentido amplio — los cuales requieren la potencia y la flexibilidad de R para su investigaciónInvestigadores y analistas aplicados en organizaciones públicas, privadas o del tercer sector que necesitan la reproducibilidad, la velocidad y la flexibilidad de un lenguaje de línea de comandos como R en aplicaciones que tratan datos espaciales tan diversos como la planificación urbana y del transporte, la logística, el geomarketing (análisis de localización de tiendas) y la planificación de emergenciasInvestigadores y analistas aplicados en organizaciones públicas, privadas o del tercer sector que necesitan la reproducibilidad, la velocidad y la flexibilidad de un lenguaje de línea de comandos como R en aplicaciones que tratan datos espaciales tan diversos como la planificación urbana y del transporte, la logística, el geomarketing (análisis de localización de tiendas) y la planificación de emergenciasEl libro está diseñado para usuarios de R de nivel intermedio-avanzado interesados en la geocomputación y para principiantes en R que tengan experiencia previa con datos geográficos.\nSi eres nuevo tanto en R como trabajando con datos geográficos, te desanimes: proporcionamos enlaces materiales adicionales y describimos la naturaleza de los datos espaciales desde una perspectiva de principiante en el capítulo 2 y en los enlaces que se proporcionan continuación.","code":""},{"path":"prefacio.html","id":"cómo-leer-este-libro","chapter":"Prefacio","heading":"Cómo leer este libro","text":"El libro está dividido en tres partes:Parte : Fundamentos, destinado ponerte al día con los datos geográficos en R.Parte II: Extensiones, las cuales cubren técnicas avanzadas.Parte III: Aplicaciones, para los problemas del mundo real.Los capítulos se vuelven progresivamente más difíciles, por lo que recomendamos leer el libro en orden.\nUno de los principales obstáculos para el análisis geográfico en R es su pronunciada curva de aprendizaje.\nLos capítulos de la primera parte pretenden abordar esta cuestión proporcionando código reproducible en conjuntos de datos sencillos que deberían facilitar el proceso de iniciación.Un aspecto importante del libro desde el punto de vista de la enseñanza/aprendizaje son los ejercicios al final de cada capítulo.\nAl completarlos, desarrollarás tus habilidades y obtendrás la confianza necesaria para abordar distintos problemas geoespaciales.\nLas soluciones los ejercicios, así como varios ejemplos ampliados, se encuentran en la web de apoyo del libro, en geocompr.github.io.Los lectores impacientes pueden sumergirse directamente en los ejemplos prácticos, los cuales comienzan en el capítulo 2.\nSin embargo, recomendamos leer primero el amplio contexto de Geocomputación con R en el capítulo 1.\nSi eres nuevo en R, también te recomendamos que aprendas más sobre el lenguaje antes de intentar ejecutar los bloques de código proporcionados en cada capítulo (menos que estés leyendo el libro para entender los conceptos).\nAfortunadamente para los principiantes de R, la comunidad de apoyo ha desarrollado una gran cantidad de recursos que pueden ayudar.\nNosotros particularmente recomendamos tres tutoriales: R para Ciencia de Datos (Grolemund Wickham 2016) y Programación eficiente con R (Gillespie Lovelace 2016), especialmente Capítulo 2 (sobre la instalación y configuración de R/RStudio) y Capítulo 10 (sobre aprender aprender), y Una introducción R (Venables, Smith, Team 2017).","code":""},{"path":"prefacio.html","id":"por-qué-r","chapter":"Prefacio","heading":"¿Por qué R?","text":"Aunque R tiene una curva de aprendizaje pronunciada, el método de línea de comandos que se defiende en este libro puede ser rápidamente rentable.\nComo aprenderás en los capítulos siguientes, R es una herramienta eficaz para abordar una gran variedad de retos relacionados con los datos geográficos.\nEsperamos que, con la práctica, R se convierta en el programa elegido en tu caja de herramientas geoespaciales para muchas aplicaciones.\nEscribir y ejecutar comandos en la línea de comandos es, en muchos casos, más rápido que apuntar y hacer clic en la interfaz gráfica de usuario (GUI) de un SIG de escritorio.\nPara algunas aplicaciones, como la estadística espacial y el modelado, R puede ser la única forma realista de llevar cabo el trabajo.Como se indica en la Sección ??, hay muchas razones para usar R para la geocomputación:\nR se adapta bien al uso interactivo que requieren muchos flujos de trabajo de análisis de datos geográficos en comparación con otros lenguajes.\nR destaca en los campos de rápido crecimiento de la Ciencia de Datos (que incluye la carpintería de datos, las técnicas de aprendizaje estadístico y la visualización de datos) y el Big Data (través de interfaces eficientes con bases de datos y sistemas de computación distribuidos).\nAdemás, R permite un flujo de trabajo reproducible: compartir las secuencias de comandos subyacentes tu análisis permitirá que otros se basen en tu trabajo.\nPara garantizar la reproducibilidad en este libro, hemos puesto disposición su código fuente en github.com/Robinlovelace/geocompr.\nAllí encontrarás archivos en la carpeta code/ que generan figuras:\nCuando el código que genera una figura se proporciona en el texto principal del libro, el nombre del archivo que la generó se proporciona en el pie de foto (véase, por ejemplo, el pie de foto de la figura ??).\nOtros lenguajes como Python, Java y C++ pueden utilizarse para la geocomputación y existen excelentes recursos para aprender geocomputación sin R, como se discute en la sección ??.\nNinguno de ellos proporciona la combinación única de ecosistema de paquetes, capacidades estadísticas, opciones de visualización y potentes IDEs que ofrece la comunidad R.\nAdemás, al enseñar utilizar un lenguaje (R) en profundidad, este libro te proporcionará los conceptos y la confianza necesarios para realizar geocomputación en otros lenguajes.","code":""},{"path":"prefacio.html","id":"impacto-en-el-mundo-real","chapter":"Prefacio","heading":"Impacto en el mundo real","text":"Geocomputación con R proporcionará los conocimientos y las habilidades necesarias para abordar una amplia variedad de cuestiones, incluidas aquellas con implicaciones científicas, sociales y medioambientales, que se manifiestan en los datos geográficos.\nComo se describe en la sección @ref(qué-es-la-geocomputación), la geocomputación sólo consiste en utilizar ordenadores para procesar datos geográficos:\ntambién se trata del impacto en el mundo real.\nSi estás interesado en un contexto más amplio y las motivaciones que hay detrás de este libro, sigue leyendo; se tratan en el capítulo 1.","code":""},{"path":"prefacio.html","id":"agradecimientos","chapter":"Prefacio","heading":"Agradecimientos","text":"Muchas gracias todos los que han contribuido directa e indirectamente través del código de alojamiento y colaboración través de GitHub, incluyendo las siguientes personas que contribuyeron directamente través de solicitudes de extracción (pull requests): prosoitos, florisvdh, katygregg, rsbivand, KiranmayiV, zmbc, erstearns, MikeJohnPage, eyesofbambi, nickbearman, tyluRp, marcosci, giocomai, KHwong12, LaurieLBaker, MarHer90, mdsumner, pat-s, gisma, ateucher, annakrystalli, DarrellCarvalho, kant, gavinsimpson, Henrik-P, Himanshuteli, yutannihilation, jbixon13, yvkschaefer, katiejolly, layik, mpaulacaldas, mtennekes, mvl22, ganes1410, richfitz, wdearden, yihui, chihinl, cshancock, gregor-d, jasongrahn, p-kono, pokyah, schuetzingit, sdesabbata, tim-salabim, tszberkowitz.\nUn agradecimiento especial Marco Sciaini, que sólo creó la imagen de la portada, sino que también publicó el código que la generó (véase code/frontcover.R en el repositorio de GitHub del libro).\nDocenas de personas más contribuyeron en línea, planteando y comentando cuestiones, y proporcionando comentarios través de las redes sociales.¡El hashtag #geocompr seguirá vivo!Nos gustaría dar las gracias John Kimmel, de CRC Press, que ha trabajado con nosotros durante dos años para convertir nuestras ideas iniciales de un plan de libro en la producción final través de cuatro rondas de revisión.\nLos revisores merecen una mención especial: sus detallados comentarios y su experiencia mejoraron sustancialmente la estructura y el contenido del libro.Damos las gracias Patrick Schratz y Alexander Brenning, de la Universidad de Jena, por sus fructíferas discusiones y aportaciones los capítulos ?? y ??.\nDamos las gracias Emmanuel Blondel, de la Organización de las Naciones Unidas para la Agricultura y la Alimentación, por su aportación experta la sección sobre servicios web;\nMichael Sumner, por su aportación crítica en muchas áreas del libro, especialmente en la discusión de los algoritmos del capítulo 10;\nTim Appelhans y David Cooley, por sus contribuciones clave al capítulo sobre visualización (capítulo 8);\ny Katy Gregg, que corrigió todos los capítulos y mejoró enormemente la legibilidad del libro.Podrían mencionarse innumerables personas que han contribuido de innumerables maneras.\nEl último agradecimiento es para todos los desarrolladores de software que hacen posible Geocomputación con R.\nEdzer Pebesma (que creó el paquete sf), Robert Hijmans (que creó raster) y Roger Bivand (que sentó las bases de gran parte del software espacial de R) han hecho posible la computación geográfica de alto rendimiento en R.","code":""},{"path":"intro.html","id":"intro","chapter":"1 Introducción","heading":"1 Introducción","text":"Este libro trata de utilizar el poder de los ordenadores para hacer cosas con los datos geográficos.\nEnseña una serie de habilidades espaciales, entre las que se incluyen: la lectura, escritura y manipulación de datos geográficos; la elaboración de mapas estáticos e interactivos; la aplicación de la geocomputación para resolver problemas del mundo real; y la modelización de fenómenos geográficos.\nAl demostrar cómo se pueden enlazar varias operaciones geográficas, en “trozos de código” reproducibles que intercalan la prosa, el libro también enseña un flujo de trabajo transparente y, por tanto, científico.\nAprender utilizar la gran cantidad de herramientas geoespaciales disponibles en la línea de comandos de R puede ser emocionante, pero crear otras nuevas puede ser realmente liberador.\nEl uso del enfoque basado en la línea de comandos que se enseña lo largo del libro, y las técnicas de programación que se tratan en el capítulo ??, pueden ayudar eliminar las restricciones tu creatividad impuestas por el software.\nPor lo tanto, después de leer el libro y completar los ejercicios, deberías sentirte capacitado con una sólida comprensión de las posibilidades abiertas por las impresionantes capacidades geográficas de R, nuevas habilidades para resolver problemas del mundo real con datos geográficos, y la capacidad de comunicar tu trabajo con mapas y código reproducible.En las últimas décadas, el software libre y de código abierto dedicado al ámbito geoespacial (FOSS4G) ha progresado un ritmo asombroso.\nGracias organizaciones como OSGeo, el análisis de datos geográficos ha dejado de ser algo exclusivo de quienes disponen de caros hardware y software: ahora cualquiera puede descargar y ejecutar bibliotecas espaciales de alto rendimiento.\nLos Sistemas de Información Geográfica (SIG, o GIS en inglés) de código abierto, como QGIS, han hecho accesible el análisis geográfico en todo el mundo. Los programas SIG tienden enfatizar las interfaces gráficas para el usuario (GUIs), con la consecuencia deseada de desalentar la reproducibilidad (aunque muchos pueden utilizarse desde la línea de comandos, como veremos en el capítulo ??).\nR, por el contrario, hace énfasis en la interfaz de la línea de comandos (CLI). Una comparación simplista entre los diferentes enfoques se ilustra en la Tabla 1.1.TABLE 1.1: Diferencias de énfasis entre los paquetes software (Interfaz gráfica del usuario (Graphical User Interface, GUI en inglés) de los Sistemas de Información Geográfica (GIS) y R).Este libro está motivado por la importancia de la reproducibilidad para la investigación científica (véase la nota inferior).\nSu objetivo es hacer más accesibles los flujos de trabajo de los análisis de datos geográficos reproducibles, y demostrar el poder del software geoespacial abierto disponible desde la línea de comandos.\n“Las interfaces para otros software forman parte de R” (Eddelbuettel Balamuta 2018).\nEsto significa que, además de las destacadas capacidades “internas,” R permite el acceso muchas otras bibliotecas de software espacial, explicadas en la sección ?? y demostradas en el capítulo ??.\nSin embargo, antes de entrar en los detalles del software, vale la pena dar un paso atrás y pensar en lo que entendemos por geocomputación.La reproducibilidad es una de las principales ventajas de las interfaces de línea de comandos, pero ¿qué significa en la práctica?\nLa definimos del siguiente modo:“Un proceso en el que los mismos resultados pueden ser generados por otros utilizando un código públicamente accesible.”","code":""},{"path":"intro.html","id":"qué-es-la-geocomputación","chapter":"1 Introducción","heading":"1.1 ¿Qué es la geocomputación?","text":"‘Geocomputación’ es un término joven, que se remonta la primera conferencia sobre el tema en 1996.1Lo que distingue la geocomputación del término comúnmente utilizado (en aquel momento) “geografía cuantitativa,” según propusieron sus primeros defensores, es su énfasis en las aplicaciones “creativas y experimentales” (P. . Longley et al. 1998) y en el desarrollo de nuevas herramientas y métodos (Openshaw Abrahart 2000):\n“La geocomputación consiste en utilizar los distintos tipos de geodatos y en desarrollar geoherramientas relevantes dentro del contexto general de un enfoque ‘científico’.”\nEste libro pretende ir más allá de la enseñanza de los métodos y el código; al final de él, deberías ser capaz de utilizar tus conocimientos de geocomputación para realizar “un trabajo práctico que sea beneficioso o útil” (Openshaw Abrahart 2000).Sin embargo, nuestro enfoque difiere de los primeros en adoptarlo, como Stan Openshaw, en su énfasis en la reproducibilidad y la colaboración.\nprincipios del siglo XXI, era realista esperar que los lectores pudieran reproducir los ejemplos de código, debido las barreras que impedían el acceso al hardware, el software y los datos necesarios.\nSi avanzamos dos décadas, las cosas han progresado rápidamente.\nCualquiera que tenga acceso un ordenador portátil con aproximadamente 4 GB de RAM puede esperar de forma realista poder instalar y ejecutar software de geocomputación sobre conjuntos de datos de acceso público, que están más disponibles que nunca (como veremos en el capítulo ??).2\ndiferencia de los primeros trabajos en este campo, todo el trabajo presentado en este libro es reproducible utilizando el código y los datos de ejemplo proporcionados junto con el libro, en paquetes de R como spData, cuya instalación se trata en el capítulo 2.La geocomputación está estrechamente relacionada con otros términos como: Ciencia de la Información Geográfica (GIScience); Geomática; Geoinformática; Ciencia de la Información Espacial; Ingeniería de la Geoinformación (P. Longley 2015); y Ciencia de los Datos Geográficos (GDS).\nTodos los términos comparten el énfasis en un enfoque “científico” (que implica que es reproducible y falsable) influenciado por los SIG, aunque sus orígenes y principales campos de aplicación difieren.\nLa GDS, por ejemplo, enfatiza las habilidades de la “ciencia de datos” y los grandes conjuntos de datos, mientras que la Geoinformática tiende centrarse en las estructuras de datos.\nPero los solapamientos entre los términos son mayores que las diferencias entre ellos y utilizamos la geocomputación como un sinónimo aproximado que los engloba todos:\ntodos tratan de utilizar los datos geográficos para el trabajo científico aplicado.\nSin embargo, diferencia de los primeros usuarios del término, pretendemos dar entender que existe un campo académico cohesionado llamado “Geocomputación” (o “GeoComputación,” como lo llamaba Stan Openshaw).\nEn cambio, definimos el término de la siguiente manera: trabajar con datos geográficos de forma computacional, centrándose en el código, la reproducibilidad y la modularidad.La geocomputación es un término reciente pero está influenciado por ideas antiguas.\nPuede considerarse parte de la Geografía, la cual tiene más de 2000 años de historia (Talbert 2014); y una extensión de los Sistemas de Información Geográfica (SIG) (Neteler Mitasova 2008), los cuales surgieron en la década de 1960 (Coppock Rhind 1991).Sin embargo, la geografía ha desempeñado un papel importante la hora de explicar e influir la relación de la humanidad con el mundo natural mucho antes de la invención del ordenador.\nLos viajes de Alexander von Humboldt Sudamérica principios del siglo XIX ilustran este papel:\nlas observaciones resultantes solo sentaron las bases de las tradiciones de la geografía física y vegetal, sino que también allanaron el camino hacia las políticas de protección del mundo natural (Wulf 2015).\nEste libro pretende contribuir la “Tradición Geográfica” (Livingstone 1992) aprovechando la potencia de los ordenadores modernos y el software de código abierto.Los vínculos del libro con disciplinas más antiguas se reflejaron en los títulos sugeridos para el libro: Geografía con R y R para SIG.\nCada uno tiene sus ventajas.\nEl primero transmite el mensaje de que comprende mucho más que datos espaciales:\nlos datos de atributos espaciales se entremezclan inevitablemente con los datos geométricos, y la Geografía trata de algo más que de dónde está algo en el mapa.\nEl segundo comunica que este un libro sobre el uso de R como un SIG, para realizar operaciones espaciales sobre datos geográficos (R. Bivand, Pebesma, Gómez-Rubio 2013).\nSin embargo, el término SIG transmite algunas connotaciones (véase la Tabla 1.1) que simplemente comunican una de las mayores fortalezas de R:\nsu capacidad basada en la consola para cambiar sin problemas entre las tareas de procesamiento, modelado y visualización de datos geográficos y geográficos.\nPor el contrario, el término geocomputación implica una programación reproducible y creativa.\nPor supuesto, los algoritmos (geocomputacionales) son herramientas poderosas que pueden llegar ser altamente complejas.\nSin embargo, todos los algoritmos se componen de partes más pequeñas.\nAl enseñarte sus fundamentos y su estructura subyacente, pretendemos capacitarte para crear tus propias soluciones innovadoras los problemas de datos geográficos.","code":""},{"path":"intro.html","id":"por-qué-usar-r-para-la-geocomputación","chapter":"1 Introducción","heading":"1.2 ¿Por qué usar R para la geocomputación?","text":"Los primeros geógrafos utilizaron diversas herramientas, como barómetros, brújulas y sextantes, para avanzar en el conocimiento del mundo (Wulf 2015). Solo con la invención del cronómetro marino en 1761 fue posible calcular la longitud en el mar, lo que permitió los barcos tomar rutas más directas.Hoy en día es difícil imaginar tal falta de datos geográficos.\nTodos los teléfonos inteligentes tienen un receptor de posicionamiento global (GPS) y una multitud de sensores en dispositivos que van desde satélites y vehículos semiautónomos hasta científicos ciudadanos que miden incesantemente cada parte del mundo.\nEl ritmo de producción de datos es abrumador.\nUn vehículo autónomo, por ejemplo, puede generar 100 GB de datos al día (Economist 2016).\nLos datos de teledetección de los satélites se han vuelto demasiado grandes para analizar los datos correspondientes con un solo ordenador, lo que ha dado lugar iniciativas como OpenEO.Esta “revolución de los geodatos” impulsa la demanda de equipos informáticos de alto rendimiento y de software eficientes y escalables para manejar y extraer la señal del ruido, con el fin de comprender y quizás cambiar el mundo.\nLas bases de datos espaciales permiten almacenar y generar subconjuntos manejables de los vastos almacenes de datos geográficos, haciendo que las interfaces para obtener conocimientos de ellos sean herramientas vitales para el futuro.\nR es una de esas herramientas, con capacidades avanzadas de análisis, modelización y visualización.\nEn este contexto, el libro se centra en el lenguaje en sí (véase Wickham 2014).\nEn su lugar, utilizamos R como una “herramienta para trabajar” para entender el mundo, de forma similar al uso que Humboldt hizo de las herramientas para obtener una comprensión profunda de la naturaleza en toda su complejidad e interconexiones (véase Wulf 2015).\nAunque la programación puede parecer una actividad reduccionista, el objetivo es enseñar geocomputación con R solo por diversión, sino para entender el mundo.R es un lenguaje y entorno de código abierto y multiplataforma para la computación estadística y los gráficos (r-project.org/).\nCon una amplia gama de paquetes, R también permite la estadística geoespacial avanzada, la modelización y la visualización.\n\nLos nuevos entornos de desarrollo integrados (IDE), como RStudio, han hecho que R sea más fácil de usar para muchos, facilitando la elaboración de mapas con un panel dedicado la visualización interactiva.En su esencia, R es un lenguaje de programación funcional orientado objetos (Wickham 2014), y fue diseñado específicamente como una interfaz interactiva para otro software (Chambers 2016).\nEste último también incluye muchos “puentes” hacia el hallazgo de un tesoro del software SIG, “geolibrerías” y funciones (véase el capítulo ??).\nPor tanto, es ideal para crear rápidamente “geoherramientas,” sin necesidad de dominar lenguajes de nivel inferior (en comparación con R) como C, FORTRAN o Java (véase la sección ??).\n\nEsto puede ser como liberarse del metafórico “techo de cristal” impuesto por los sistemas de información geográfica basados en GUI o patentados (véase la Tabla 1.1 para una definición de GUI).\nAdemás, R facilita el acceso otros lenguajes:\nlos paquetes Rcpp y reticulate permiten acceder código de C++ y Python, por ejemplo.\nEsto significa que R puede utilizarse como “puente” hacia una amplia gama de programas geoespaciales (véase la sección ??).Otro ejemplo que muestra la flexibilidad y la evolución de las capacidades geográficas de R es la elaboración de mapas interactivos.\nComo veremos en el Capítulo ??, la afirmación de que R tiene “facilidades interactivas [para elaborar gráficos] limitadas” (R. Bivand, Pebesma, Gómez-Rubio 2013) ya es cierta.\nAsí lo demuestra el siguiente fragmento de código, que crea la Figura 1.1 (las funciones que generan el gráfico se tratan en la Sección ??).\nFIGURE 1.1: Los marcadores azules indican la procedencia de los autores. El mapa base es una imagen en mosaico de la Tierra de noche proporcionada por la NASA. Interactúa con la versión en línea en geocompr.robinlovelace.net, por ejemplo, ampliando la imagen y haciendo clic en las ventanas emergentes.\nHace unos años habría sido difícil elaborar la Figura 1.1 con R, más aún en forma de mapa interactivo.\nEsto ilustra la flexibilidad de R y cómo, gracias desarrollos como knitr y leaflet, puede utilizarse como interfaz con otro software, un tema que se repetirá lo largo de este libro.\nEl uso del código de R, por tanto, permite enseñar geocomputación con referencia ejemplos reproducibles como el proporcionado en la Figura 1.1 en lugar de conceptos abstractos.","code":"\nlibrary(leaflet)\npopup = c(\"Robin\", \"Jakub\", \"Jannes\", \"Mireia\")\nleaflet() %>%\n  addProviderTiles(\"NASAGIBS.ViirsEarthAtNight2012\") %>%\n  addMarkers(c(-3, 23, 11, 2), c(52, 53, 49, 42), popup = popup)"},{"path":"intro.html","id":"software-para-geocomputación","chapter":"1 Introducción","heading":"1.3 Software para geocomputación","text":"R es un poderoso lenguaje para la geocomputación, pero hay muchas otras opciones para el análisis de datos geográficos que ofrecen miles de funciones geográficas.\nEl conocimiento de otros lenguajes para la geocomputación ayudará decidir cuándo una herramienta diferente puede ser más apropiada para una tarea específica, y situar R en el amplio ecosistema geoespacial.\nEsta sección presenta brevemente los lenguajes C++, Java y Python para la geocomputación, como preparación para el capítulo ??.Una importante característica de R (y de Python) es que es un lenguaje interpretado.\nEsto es ventajoso porque permite la programación interactiva en un bucle de lectura-evaluación-impresión (REPL):\nel código introducido en la consola se ejecuta inmediatamente y el resultado se imprime, en lugar de esperar la etapa intermedia de compilación. Por otra parte, los lenguajes compilados, como C++ y Java, tienden ejecutarse más rápidamente (una vez que han sido compilados).C++ proporciona la base de muchos paquetes SIG, como QGIS, GRASS y SAGA, por lo que es un punto de partida apropiado.\nEl C++ bien escrito es muy rápido, lo que lo convierte en una buena opción para aplicaciones de rendimiento crítico, como el procesamiento de grandes conjuntos de datos geográficos, pero es más difícil de aprender que Python o R.\nEl C++ se ha vuelto más accesible con el paquete Rcpp, el cual proporciona una buena ” vía de entrada ” la programación en C para los usuarios de R.\nEl dominio de estos lenguajes de bajo nivel abre la posibilidad de crear nuevos “geoalgoritmos” de alto rendimiento y de comprender mejor el funcionamiento del software SIG (véase el capítulo ??).Java es otro lenguaje importante y versátil para la geocomputación.\nLos paquetes de SIG gvSig, OpenJump y uDig están escritos en Java.\nHay muchas bibliotecas de SIG escritas en Java, como GeoTools y JTS, la Topología Suite de Java (GEOS es un puerto C++ de JTS).\nAdemás, muchas aplicaciones de servidores de mapas utilizan Java, como Geoserver/Geonode, deegree y 52°North WPS.La sintaxis orientada objetos de Java es similar la de C++.\nUna de las principales ventajas de Java es que es independiente de las plataformas (lo que es inusual para un lenguaje compilado) y es altamente escalable, lo cual lo convierte en un lenguaje adecuado para IDEs como RStudio, con el cual se ha escrito este libro.\nJava tiene menos herramientas para el modelado estadístico y la visualización que Python o R, aunque puede utilizarse para la ciencia de datos (Brzustowicz 2017).Python es un lenguaje importante para la geocomputación, especialmente porque muchos SIG de escritorio, como GRASS, SAGA y QGIS, proporcionan una API de Python (véase el capítulo ??).\nAl igual que R, es una herramienta popular para la ciencia de los datos.\nAmbos lenguajes están orientados objetos y tienen muchas áreas de solapamiento, lo cual ha llevado iniciativas como el paquete reticulate, que facilita el acceso Python desde R, y la iniciativa de Ursa Labs para apoyar las bibliotecas portátiles en beneficio de todo el ecosistema de ciencia de datos de código abierto.En la práctica, tanto R como Python tienen sus puntos fuertes y, hasta cierto punto, cuál de ellos se utiliza es menos importante que el ámbito de aplicación y la comunicación de los resultados.\nEl aprendizaje de cualquiera de los dos permite empezar aprender el otro.\nSin embargo, R tiene grandes ventajas sobre Python para la geocomputación.\nEntre ellas se encuentra el hecho de que soporta mucho mejor los modelos de datos geográficos vectoriales y rasterizados en el propio lenguaje (véase el capítulo 2) y las correspondientes posibilidades de visualización (véanse los capítulos 2 y ??).\nIgualmente importante es el hecho de que R tiene un soporte incomparable para la estadística, incluida la estadística espacial, con cientos de paquetes (diferencia de Python) que soportan miles de métodos estadísticos.La mayor ventaja de Python es que es un lenguaje de programación de propósito general.\nSe utiliza en muchos ámbitos, como el software de escritorio, los juegos de ordenador, los sitios web y la ‘ciencia de los datos’.\nPython es menudo el único lenguaje compartido entre diferentes comunidades (de geocomputación) y puede considerarse como el “pegamento” que mantiene unidos muchos programas de SIG.\nSe puede acceder muchos geoalgoritmos, incluidos los de QGIS y ArcMap, desde la línea de comandos de Python, lo que lo convierte en un lenguaje idóneo para iniciarse en los SIG de línea de comandos.3Sin embargo, para la estadística espacial y el modelado predictivo, R es considerablemente mejor.\nEsto significa que haya que elegir entre R o Python: Python soporta la mayoría de las técnicas estadísticas comunes (aunque R tiende soportar antes los nuevos desarrollos en estadística espacial) y muchos conceptos aprendidos en Python pueden aplicarse al mundo de R.\nAl igual que R, Python también soporta el análisis y la manipulación de datos geográficos con paquetes como osgeo, Shapely, NumPy y PyGeoProcessing (Garrard 2016).","code":""},{"path":"intro.html","id":"el-ecosistema-espacial-de-r","chapter":"1 Introducción","heading":"1.4 El ecosistema espacial de R","text":"Hay muchas maneras de manejar datos geográficos en R, con docenas de paquetes en el área.4\nEn este libro nos esforzamos por enseñar el estado del arte en el campo, al tiempo que nos aseguramos de que los métodos estén preparados para el futuro.\nAl igual que muchas áreas de desarrollo de software, el ecosistema espacial de R está evolucionando rápidamente (Figura 1.2).\nPuesto que R es de código abierto, estos desarrollos pueden construirse fácilmente partir de trabajos anteriores, “subiendo hombros de gigantes,” como dijo Isaac Newton en 1675.\nEste enfoque es ventajoso porque fomenta la colaboración y evita “reinventar la rueda.”\nEl paquete sf (tratado en el capítulo 2), por ejemplo, se basa en su predecesor sp.El aumento del tiempo de desarrollo (y del interés) en ‘R-spatial’ se ha producido tras la concesión de una subvención por parte del R Consortium para el desarrollo del soporte para Funciones Simples, un estándar y modelo de código abierto para almacenar y acceder geometrías vectoriales.\nEsto dio lugar al paquete sf (tratado en la sección 2.2.1).\nMúltiples sitios reflejan el inmenso interés por sf.\nEsto es especialmente cierto en el caso de los archivos de R-sig-Geo Archives, una lista de correos electrónicos en abierto que contiene mucha sabiduría de R-spatial acumulada lo largo de los años.\nFIGURE 1.2: La popularidad de los paquetes espaciales en R. El eje Y muestra el número medio de descargas por día, dentro de una ventana móvil de 30 días, de paquetes espaciales destacados.\nCabe destacar que los cambios en la comunidad de R en general, como por ejemplo el paquete de procesamiento de datos dplyr (publicado en 2014), han influido en los cambios del ecosistema espacial de R.\nJunto con otros paquetes que tienen un estilo compartido y un énfasis en los “datos ordenados” (“tidy data”) (incluyendo, por ejemplo, ggplot2), dplyr se colocó en el “metapaquete” tidyverse finales de 2016.El enfoque de tidyverse, centrado en los datos de forma larga y en las funciones rápidas de nombre intuitivo, se ha hecho inmensamente popular.\nEsto ha dado lugar una demanda de “datos geográficos ordenados” que ha sido satisfecha en parte por sf y otros enfoques como tabularaster.\nUna característica evidente del tidyverse es la tendencia que los paquetes trabajen en armonía.\nexiste un ‘geoverso’ equivalente, pero hay intentos de armonización entre los paquetes alojados en la organización r-spatial y el número creciente de paquetes que utilizan sf (Tabla 1.2).TABLE 1.2: Los 5 paquetes más descargados que dependen de sf, en términos de número medio de descargas por día durante el mes anterior. partir del 2021-08-22 hay 383 paquetes que importan sf.","code":""},{"path":"intro.html","id":"la-historia-de-r-spatial","chapter":"1 Introducción","heading":"1.5 La historia de R-spatial","text":"El uso de paquetes espaciales recientes como sf tiene muchas ventajas, pero también es importante ser consciente de la historia de las capacidades espaciales de R: muchas funciones, casos de uso y material didáctico están contenidos en paquetes más antiguos.\nEstos pueden seguir siendo útiles hoy en día, siempre que se sepa dónde buscar.\n\nLas capacidades espaciales de R se originaron en los primeros paquetes espaciales del lenguaje S (R. Bivand Gebhardt 2000).\n\nEn la década de 1990 se desarrollaron numerosos scripts en S y un puñado de paquetes para la estadística espacial.\nLos paquetes de R surgieron partir de ellos y en el año 2000 había paquetes de R para varios métodos espaciales “análisis de patrones puntuales, geoestadística, análisis exploratorio de datos espaciales y econometría espacial,” según un artículo presentado en GeoComputation 2000 (R. Bivand Neteler 2000).\nAlgunos de ellos, especialmente spatial, sgeostat y splancs, siguen estando disponibles en CRAN (B. S. Rowlingson Diggle 1993; B. Rowlingson Diggle 2017; Venables Ripley 2002; Majure Gebhardt 2016).Un artículo posterior en R News (el predecesor de R Journal) contenía una visión general del software estadístico espacial en R en ese momento, gran parte del cual se basaba en código anterior escrito para S/S-PLUS (Ripley 2001).\nEsta visión general describía paquetes para el suavizado y la interpolación espacial, incluyendo akima y geoR (Akima Gebhardt 2016; Jr Diggle 2016), y el análisis de patrones de puntos, incluyendo splancs (B. Rowlingson Diggle 2017) y spatstat (Baddeley, Rubak, Turner 2015).La siguiente publicación de R News (Volumen 1/3) volvió poner los paquetes espaciales en el punto de mira, con una introducción más detallada splancs y un comentario sobre las perspectivas futuras de la estadística espacial (R. Bivand 2001).\nAdemás, la publicación introdujo dos paquetes para probar la autocorrelación espacial que finalmente se convirtieron en parte de spdep (R. Bivand 2017).\nEn particular, el comentario menciona la necesidad de estandarizar las interfaces espaciales, los mecanismos eficientes para el intercambio de datos con SIG y el manejo de metadatos espaciales como los sistemas de referencia de coordenadas (CRS).maptools [escrito por Nicholas Lewin-Koh; R. Bivand Lewin-Koh (2017)] es otro paquete importante de esta época.\nInicialmente, maptools solo contenía una envoltura alrededor de shapelib y permitía la lectura de ESRI Shapefiles en listas anidadas de geometría.\nLa clase S3 correspondiente y hoy en día obsoleta llamada “Map” almacenaba esta lista junto un dataframe de atributos.\nEl trabajo sobre la representación de la clase “Map” fue, sin embargo, importante, ya que alimentó directamente sp antes de su publicación en CRAN.En 2003, Roger Bivand publicó una revisión extendida de los paquetes espaciales.\nPropuso un sistema de clases para soportar los “objetos de datos ofrecidos por GDAL”, incluyendo los tipos ‘fundamentales’ punto, línea, polígono y raster.\nAdemás, sugería que las interfaces con bibliotecas externas debían ser la base de los paquetes modulares de R (R. Bivand 2003).\nEn gran medida, estas ideas se materializaron en los paquetes rgdal y sp.\nEstos proporcionaron una base para el análisis de datos espaciales con R, tal como se describe en Análisis de datos espaciales aplicados con R (Applied Spatial Data Analysis R en inglés) (ASDAR) (R. Bivand, Pebesma, Gómez-Rubio 2013), publicado por primera vez en 2008.\nDiez años más tarde, las capacidades espaciales de R han evolucionado sustancialmente, pero siguen basándose en las ideas expuestas por Bivand (2003):\nlas interfaces para GDAL y PROJ, por ejemplo, siguen potenciando las capacidades de /O de datos geográficos de alto rendimiento y de transformación de CRS (véanse los capítulos ?? y ??, respectivamente).rgdal, publicado en 2003, proporcionó vínculos GDAL para R que mejoraron en gran medida su capacidad para importar datos de formatos de datos geográficos que antes estaban disponibles.\nLa versión inicial sólo admitía controladores raster, pero las mejoras posteriores proporcionaron soporte para sistemas de referencia de coordenadas (través de la librería PROJ), reproyecciones e importación de formatos de archivos vectoriales (véase el capítulo ?? para más información sobre los formatos de archivo).\nMuchas de estas capacidades adicionales fueron desarrolladas por Barry Rowlingson y publicadas en el código base de rgdal en 2006 (véase B. Rowlingson et al. 2003 y R-help(véase Rowlingson et al. 2003 y la lista de correos electrónicos de R-help para el contexto).sp, publicado en 2005, superó la incapacidad de R para distinguir entre los objetos espaciales y los espaciales (E. J. Pebesma Bivand 2005).\nsp surgió de un taller celebrado en Viena en 2003 y estuvo alojado en sourceforge antes de migrar R-Forge.\n\n\nAntes de 2005, las coordenadas geográficas se trataban generalmente como cualquier otro número.\nsp cambió esto con sus clases y métodos genéricos que soportan puntos, líneas, polígonos y cuadrículas, y datos de atributos.sp almacena información como el cuadro delimitador, el sistema de referencia de coordenadas y los atributos en ranuras de objetos espaciales que utilizan el sistema de clases S4, lo que permite que las operaciones de datos funcionen con datos geográficos (véase la sección ??).\nAdemás, sp proporciona métodos genéricos como summary() y plot() para datos geográficos.\nEn la década siguiente, las clases sp se popularizaron rápidamente para los datos geográficos en R y el número de paquetes que dependían de él se incrementó de unos 20 en 2008 más de 100 en 2013 (R. Bivand, Pebesma, Gómez-Rubio 2013).En 2018, casi 500 paquetes dependen de sp, lo que lo convierte en una parte importante del ecosistema de R.\nEntre los paquetes R más destacados que utilizan sp se encuentran: gstat, para geoestadística espacial y espacio-temporal; geosphere, para trigonometría esférica; y adehabitat, utilizado para el análisis de la selección de hábitat por parte de los animales (E. Pebesma Graeler 2018; Calenge 2006; Hijmans 2016).Mientras que rgdal y sp resolvían muchos problemas espaciales, R seguía careciendo de la capacidad de realizar operaciones geométricas (véase el capítulo ??).\nColin Rundel abordó este problema desarrollando rgeos, una interfaz de R para la librería de geometría en código abierto (GEOS) durante un proyecto de Google Summer Code en 2010 (R. Bivand Rundel 2018).\nrgeos permitió GEOS manipular objetos sp, con funciones como gIntersection().Otra limitación de sp — su limitado apoyo los datos raster — fue superada por raster, publicado por primera vez en 2010 (Hijmans 2017).\nSu sistema de clases y sus funciones soportan una serie de operaciones de rasterización, como se indica en la sección ??.\nUna característica clave de raster es su capacidad para trabajar con conjuntos de datos que son demasiado grandes para caber en la memoria RAM (la interfaz de R con PostGIS admite operaciones fuera del disco sobre datos geográficos vectoriales).\nraster también admite el álgebra de mapas (véase la sección ??).Paralelamente estos desarrollos de sistemas de clases y métodos, llegó el apoyo R como interfaz para el software SIG dedicado.\nGRASS (R. S. Bivand 2000) y los paquetes posteriores spgrass6 y rgrass7 (para GRASS GIS 6 y 7, respectivamente) fueron ejemplos destacados en esta dirección (R. Bivand 2016a, 2016b).\nOtros ejemplos de puentes entre R y SIG son RSAGA (Brenning, Bangs, Becker 2018, publicado por primera vez en 2008), RPyGeo (Brenning 2012, publicado por primera vez en 2008) y RQGIS (Muenchow, Schratz, Brenning 2017, publicado por primera vez en 2016) (véase el capítulo ??).La visualización fue un foco de atención al principio, ya que la mayor parte del desarrollo de R-spatial se centró en el análisis y las operaciones geográficas.\nsp proporcionó métodos para la elaboración de mapas utilizando el sistema de graficación de base y de lattice, pero la demanda estaba creciendo para las capacidades de elaboración de mapas avanzados, especialmente después del lanzamiento de ggplot2 en 2007.\nggmap amplió las capacidades espaciales de ggplot2 (Kahle Wickham 2013), facilitando el acceso los segmentos del “basemap” desde servicios en línea como Google Maps.\nAunque ggmap facilitaba la elaboración de mapas con ggplot2, su utilidad estaba limitada por la necesidad de fortificar los objetos espaciales, lo que significa convertirlos en largos dataframes.\nAunque esto funciona bien para los puntos, es computacionalmente ineficiente para las líneas y los polígonos, ya que cada coordenada (vértice) se convierte en una fila, lo que da lugar enormes dataframes para representar geometrías complejas.\nAunque la visualización geográfica tendía centrarse en los datos vectoriales, la visualización rasterizada está soportada en raster y recibió un impulso con el lanzamiento de rasterVis, el cual se describe en un libro sobre el tema de la visualización de datos espaciales y temporales (Lamigueiro 2018).\npartir de 2018, la creación de mapas en R es un tema candente con paquetes dedicados como tmap, leaflet y mapview, todos ellos compatibles con el sistema de clases proporcionado por sf, en el cual se centra el siguiente capítulo (véase el capítulo ?? para obtener más información sobre la visualización).","code":""},{"path":"intro.html","id":"ejercicios","chapter":"1 Introducción","heading":"1.6 Ejercicios","text":"","code":""},{"path":"spatial-class.html","id":"spatial-class","chapter":"2 Datos geográficos en R","heading":"2 Datos geográficos en R","text":"","code":""},{"path":"spatial-class.html","id":"prerrequisitos","chapter":"2 Datos geográficos en R","heading":"Prerrequisitos","text":"Este es el primer capítulo práctico del libro y, por lo tanto, conlleva algunos requisitos de software.\nSuponemos que ya tienes instalada una versión actualizada de R y que te sientes cómodo utilizando el software con una interfaz de línea de comandos como el entorno de desarrollo integrado (IDE) RStudio.\nSi eres nuevo en R, te recomendamos leer el capítulo 2 del libro en línea Efficient R Programming de Gillespie Lovelace (2016) y aprender los fundamentos del lenguaje con recursos como R Data Science de Grolemund Wickham (2016).\nOrganiza tu trabajo (por ejemplo, con proyectos de RStudio) y asigna los scripts nombres sensatos como 02-chapter.R para documentar el código que escribes medida que aprendes.\nLos paquetes utilizados en este capítulo pueden instalarse con los siguientes comandos:5Si estás trabajando con Mac o Linux, es posible que el comando anterior para instalar sf funcione la primera vez.\nEstos sistemas operativos () tienen “requisitos del sistema” que se describen en el README del paquete.\nSe pueden encontrar varias instrucciones específicas para cada en línea, como el artículo Instalación de R 4.0 en Ubuntu 20.04 (Installation R 4.0 Ubuntu 20.04 en inglés) en el blog rtask.thinkr.fr.Todos los paquetes necesarios para reproducir el contenido del libro se pueden instalar con el siguiente comando:\nremotes::install_github(\"geocompr/geocompkg\").\nLos paquetes necesarios se pueden “cargar” (técnicamente se adjuntan) con la función library() de la siguiente manera:La salida de library(sf) informa de las versiones de las bibliotecas geográficas clave (key geographic libraries), como GEOS, la cual ya está utilizando el paquete, como se indica en la Sección 2.2.1.Los demás paquetes instalados contienen datos que se utilizarán en el libro:","code":"\ninstall.packages(\"sf\")\ninstall.packages(\"terra\")\ninstall.packages(\"spData\")\ninstall.packages(\"spDataLarge\", repos = \"https://nowosad.r-universe.dev\")\nlibrary(sf)          # clases y funciones para datos vectoriales\n#> Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1\nlibrary(terra)      # clases y funciones para datos rasterizados\nlibrary(spData)        # cargar datos geográficos\nlibrary(spDataLarge)   # cargar datos geográficos de mayor tamaño"},{"path":"spatial-class.html","id":"intro-spatial-class","chapter":"2 Datos geográficos en R","heading":"2.1 Introducción","text":"En este capítulo se explicarán brevemente los modelos de datos geográficos fundamentales: vectorial y rasterizado.\nIntroduciremos la teoría detrás de cada modelo de datos y las disciplinas en las que predominan, antes de demostrar su implementación en R.El modelo de datos vectoriales representa el mundo mediante puntos, líneas y polígonos.\nEstos tienen bordes discretos y bien definidos, lo que significa que los conjuntos de datos vectoriales suelen tener un alto nivel de precisión (pero necesariamente exactitud, como veremos en el apartado ??).\nEl modelo de datos ráster divide la superficie en celdas de tamaño constante.\nLos conjuntos de datos ráster son la base de las imágenes de fondo utilizadas en la cartografía web y han sido una fuente vital de datos geográficos desde los orígenes de la fotografía aérea y los dispositivos de teledetección por satélite.\nLos rásteres agregan características espacialmente específicas una resolución determinada, lo que significa que son consistentes en el espacio y escalables (existen muchos conjuntos de datos ráster nivel mundial).¿Cuál utilizar?\nLa respuesta depende probablemente de su ámbito de aplicación:Los datos vectoriales tienden dominar las ciencias sociales porque los asentamientos humanos tienden tener fronteras discretasLos datos rasterizados predominan en las ciencias medioambientales debido la dependencia de los datos de teledetecciónEn algunos campos hay mucho solapamiento y los conjuntos de datos ráster y vectoriales pueden utilizarse conjuntamente:\nlos ecologistas y los demógrafos, por ejemplo, suelen utilizar tanto datos vectoriales como rasterizados.\nAdemás, es posible la conversión entre ambas formas (véase el apartado ??).\nIndependientemente de si tu trabajo implica un mayor uso de los conjuntos de datos vectoriales o rasterizados, merece la pena comprender el modelo de datos subyacente antes de utilizarlos, como se explica en los capítulos siguientes.\nEste libro utiliza los paquetes sf y raster para trabajar con datos vectoriales y conjuntos de datos raster, respectivamente.","code":""},{"path":"spatial-class.html","id":"datos-vectoriales","chapter":"2 Datos geográficos en R","heading":"2.2 Datos vectoriales","text":"El modelo de datos vectoriales geográficos se basa en puntos situados dentro de un sistema de referencia de coordenadas (SRC, CRS en inglés).\nLos puntos pueden representar características autónomas (por ejemplo, la ubicación de una parada de autobús) o pueden estar vinculados entre sí para formar geometrías más complejas, como líneas y polígonos.\nLa mayoría de las geometrías de puntos contienen sólo dos dimensiones (los SRC tridimensionales contienen un valor \\(z\\) adicional, que suele representar la altura sobre el nivel del mar).En este sistema, Londres, por ejemplo, puede representarse con las coordenadas c(-0.1, 51.5).\nEsto significa que su ubicación es -0,1 grados al este y 51,5 grados al norte del origen.\nEn este caso, el origen se encuentra 0 grados de longitud (el Primer Meridiano o Meridiano de Greenwich) y 0 grados de latitud (Ecuador) en un SRC geográfico (‘lon/lat’) (Figura 2.1, panel izquierdo).\nEl mismo punto también podría aproximarse en un SRC proyectado con valores ‘Este/Norte’ de c(530000, 180000) en la British National Grid, lo que significa que Londres se encuentra 530 km al Este y 180 km al Norte del \\(origen\\) del SRC.\nEsto puede comprobarse visualmente: algo más de 5 ‘casillas’ -áreas cuadradas delimitadas por las líneas grises de la cuadrícula de 100 km de ancho- separan el punto que representa Londres del origen (Figura 2.1, panel derecho).La ubicación del origen de National Grid, en el mar más allá del Suroeste de la península, garantiza que la mayoría de las ubicaciones en el Reino Unido tengan valores positivos de Orientación y Longitud.6\nHay más aspectos sobre los SRC, como se describe en las secciones 2.4 y ??, pero, para los propósitos de esta sección, es suficiente saber que las coordenadas consisten en dos números que representan la distancia desde un origen, generalmente en \\(x\\) y luego \\(y\\) para las dimensiones.\nFIGURE 2.1: Ilustración de datos vectoriales (puntos) en los que la ubicación de Londres (la X roja) se representa con referencia un origen (el círculo azul). El gráfico de la izquierda representa un SRC geográfico con un origen 0° tanto para la longitud como para la latitud. El gráfico de la derecha representa un SRC proyectado con el origen situado en el mar al Suroeste peninsular.\nsf es un paquete que proporciona un sistema de clases para datos vectoriales geográficos.\nsf sólo sustituye sp, sino que también proporciona una interfaz de línea de comandos consistente para GEOS y GDAL, sustituyendo rgeos y rgdal (descritos en la Sección ??).\nEsta sección presenta las clases sf como preparación para los capítulos siguientes (los capítulos @ref(geometric-operations y ?? cubren la interfaz de GEOS y GDAL, respectivamente).","code":""},{"path":"spatial-class.html","id":"intro-sf","chapter":"2 Datos geográficos en R","heading":"2.2.1 Introducción a Simple Features","text":"Simple Features (en ocasiones también llamado Simple feature access (SFA)) es un estándar abierto desarrollado y respaldado por el Open Geospatial Consortium (OGC), una organización sin ánimo de lucro cuyas actividades volveremos tratar en un capítulo posterior (en la sección ??.\n\nSimple Features es un modelo de datos jerárquico que representa una amplia gama de tipos de geometría.\nDe los 17 tipos de geometría que soporta la especificación, solo 7 se utilizan en la gran mayoría de las investigaciones geográficas (véase la figura 2.2);\nestos tipos de geometría básicos son totalmente compatibles con el paquete de R sf (E. Pebesma 2018).7\nFIGURE 2.2: Tipos de Simple Features compatibles con sf.\nsf puede representar todos los tipos de geometría vectorial comunes (las clases de datos rasterizados son soportadas por sf): puntos, líneas, polígonos y sus respectivas versiones ‘multi’ (que agrupan elementos del mismo tipo en una sola función).\n\n\nsf también soporta colecciones geométricas, las cuales pueden contener múltiples tipos de geometrías en un solo objeto.\nsf proporciona la misma funcionalidad (y más) que previamente se ofrecía en tres paquetes: sp para las clases de datos (E. Pebesma Bivand 2018), rgdal para la lectura/escritura de datos través de una interfaz para GDAL y PROJ (R. Bivand, Keitt, Rowlingson 2018) y rgeos para las operaciones espaciales través de una interfaz para GEOS (R. Bivand Rundel 2018).\nPara reiterar el mensaje del capítulo 1, los paquetes geográficos de R tienen una larga historia de interfaces con librerías de bajo nivel, y sf mantiene esta tradición con una interfaz unificada con versiones recientes de la librería GEOS para operaciones geométricas, la librería GDAL para leer y escribir archivos de datos geográficos, y la librería PROJ para representar y transformar sistemas de referencia de coordenadas proyectadas.\nEste es un logro notable que reduce el espacio necesario para ‘cambiar de contexto’ entre diferentes paquetes y permite el acceso librerías geográficas de alto rendimiento.\nLa documentación sobre sf puede encontrarse en su sitio web y en 6 ‘viñetas,’ que pueden cargarse de la siguiente manera:Como se explica en la primera viñeta, los objetos ‘Simple Feature’ en R se almacenan en un marco de datos, con los datos geográficos ocupando una columna especial, normalmente llamada ‘geom’ o ‘geometry.’\nUtilizaremos el conjunto de datos world proporcionado por el paquete spData, cargado al principio de este capítulo (véase nowosad.github.io/spData para ver una lista de conjuntos de datos cargados por el paquete).\nworld es un objeto espacial que contiene columnas espaciales y atributos, cuyos nombres son devueltos por la función names() (la última columna contiene la información geográfica):El contenido de la columna geom proporciona los objetos sf sus poderes espaciales: world$geom es una ‘columna lista’ que contiene todas las coordenadas de los polígonos de cada uno de los países.\n\nEl paquete sf proporciona un método plot() para visualizar los datos geográficos:\nel siguiente comando crea la Figura 2.3.\nFIGURE 2.3: Un gráfico espacial del mundo utilizando el paquete sf, con un panel por cada atributo del conjunto de datos.\nObserva que en lugar de crear un único mapa, como harían la mayoría de los programas SIG, el comando plot() ha creado múltiples mapas, uno para cada variable en los conjuntos de datos de world.\nEste procedimiento puede ser útil para explorar la distribución espacial de diferentes variables y se trata más adelante, en la sección 2.2.3.Poder tratar los objetos espaciales como marcos de datos ordinarios pero con poderes espaciales tiene muchas ventajas, especialmente si ya estás acostumbrado trabajar con marcos de datos.\nLa función summary(), por ejemplo, proporciona una útil visión general de las variables dentro del objeto world.Aunque sólo hemos seleccionado una variable para el comando summary, éste también emite un informe sobre la geometría.\nEsto demuestra el comportamiento “pegajoso” de las columnas con geometrías de los objetos sf, lo que significa que los datos geométricos se mantienen menos que el usuario las elimine deliberadamente, como veremos en la sección 3.2.\nEl resultado proporciona un rápido resumen de los datos espaciales y espaciales contenidos en world: la media de la esperanza de vida es de 71 años (oscilando entre menos de 51 y más de 83 años, con una mediana de 73 años) en todos los países.Merece la pena profundizar en el comportamiento y el contenido básicos de este objeto Simple feature, que puede considerarse útilmente como un ‘marco de datos espaciales’ (‘Spatial data frame’ en inglés).Los objetos sf son fáciles de subdividir.\nEl código siguiente muestra sus dos primeras filas y tres columnas.\nEl resultado muestra dos diferencias importantes en comparación con un data.frame normal: la inclusión de datos geográficos adicionales (tipo de geometría, dimensión, bbox e información SRC - epsg (SRID), proj4string), y la presencia de una columna de geometría, aquí denominada geom:Todo esto puede parecer bastante complejo, especialmente para un sistema de clases que se supone que es sencillo.\nSin embargo, hay buenas razones para organizar las cosas de esta manera y utilizar sf.Antes de describir cada tipo de geometría que permite el paquete sf, vale la pena dar un paso atrás para entender los bloques de construcción de los objetos sf.\nLa sección 2.2.8 muestra cómo los objetos Simple features son marcos de datos, con columnas especiales de geometría.\nEstas columnas espaciales suelen llamarse geom o geometry: world$geom se refiere al elemento espacial del objeto world descrito previamente.\nEstas columnas de geometría son ‘columnas lista’ de la clase sfc (véase el apartado 2.2.7).\nsu vez, los objetos sfc (Simple Feature geometry list-Column) se componen de uno o varios objetos de la clase sfg (Simple Feature Geometries): geometrías simples que se describen en la sección 2.2.6.\n\nPara entender cómo funcionan los componentes espaciales de simple features, es vital entender las geometrías simples (sfg).\nPor este motivo, en el apartado 2.2.5 se tratan todos los tipos de sfg actualmente admitidos, antes de pasar describir cómo pueden representarse en R partir de objetos sfg, los cuales constituyen las bases de los objetos sfc y, eventualmente, la totalidad de los objetos sf.","code":"\nvignette(package = \"sf\") # ver qué viñetas están disponibles\nvignette(\"sf1\")          # introducción al paquete\nnames(world)\n#>  [1] \"iso_a2\"    \"name_long\" \"continent\" \"region_un\" \"subregion\" \"type\"     \n#>  [7] \"area_km2\"  \"pop\"       \"lifeExp\"   \"gdpPercap\" \"geom\"\nplot(world)\nsummary(world[\"lifeExp\"])\n#>     lifeExp                geom    \n#>  Min.   :50.6   MULTIPOLYGON :177  \n#>  1st Qu.:65.0   epsg:4326    :  0  \n#>  Median :72.9   +proj=long...:  0  \n#>  Mean   :70.9                      \n#>  3rd Qu.:76.8                      \n#>  Max.   :83.6                      \n#>  NA's   :10\nworld_mini = world[1:2, 1:3]\nworld_mini\n#> Simple feature collection with 2 features and 3 fields\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -180 ymin: -18.3 xmax: 180 ymax: -0.95\n#> Geodetic CRS:  WGS 84\n#> # A tibble: 2 × 4\n#>   iso_a2 name_long continent                                                geom\n#>   <chr>  <chr>     <chr>                                      <MULTIPOLYGON [°]>\n#> 1 FJ     Fiji      Oceania   (((-180 -16.6, -180 -16.5, -180 -16, -180 -16.1, -…\n#> 2 TZ     Tanzania  Africa    (((33.9 -0.95, 31.9 -1.03, 30.8 -1.01, 30.4 -1.13,…"},{"path":"spatial-class.html","id":"por-qué-simple-features","chapter":"2 Datos geográficos en R","heading":"2.2.2 ¿Por qué Simple Features?","text":"Simple features es un modelo de datos ampliamente aceptado que subyace en las estructuras de datos de muchas aplicaciones SIG, incluyendo QGIS y PostGIS.\nUna de las principales ventajas es que el uso del modelo de datos garantiza la transferencia de tu trabajo otras configuraciones, por ejemplo, importar desde y exportar hacia otras bases de datos espaciales.\nUna pregunta más específica desde la perspectiva de R es “¿por qué utilizar el paquete sf cuando sp ya está probado y comprobado?” Hay muchas razones (relacionadas con las ventajas del modelo Simple features):Lectura y escritura rápida de datosMejora del rendimiento de los gráficosLos objetos sf pueden ser tratados como marcos de datos en la mayoría de las operacionesLas funciones sf pueden combinarse mediante el operador %>% y funcionan bien con la colección tidyverse de paquetes RLos nombres de las funciones sf son relativamente coherentes e intuitivos (todos comienzan por st_)Debido estas ventajas, algunos paquetes espaciales (como tmap, mapview y tidycensus) han añadido compatibilidades con sf.\nSin embargo, la mayoría de los paquetes tardarán muchos años en hacer la transición y algunos nunca la harán.\nAfortunadamente, éstos aún pueden seguir utilizándose en un flujo de trabajo basado en objetos sf, convirtiéndolos la clase Spatial utilizada en sp:Los objetos espaciales pueden volver convertirse en sf de la misma manera o con st_as_sf():","code":"\nlibrary(sp)\nworld_sp = as(world, Class = \"Spatial\")\n# sp functions ...\nworld_sf = st_as_sf(world_sp)"},{"path":"spatial-class.html","id":"basic-map","chapter":"2 Datos geográficos en R","heading":"2.2.3 Elaboración de un mapa básico","text":"Los mapas básicos pueden crearse en sf con plot().\nPor defecto, esto crea un gráfico compuesto de varios paneles (como spplot() de sp), un sub-gráfico para cada variable del objeto, como se ilustra en el panel de la izquierda en la Figura 2.4.\nSe produce una leyenda o “clave” con una paleta de colores continua si el objeto que se va trazar tiene una sola variable (véase el panel de la derecha).\nLos colores también pueden establecerse con col =, aunque esto creará una paleta continua ni una leyenda.\n\nFIGURE 2.4: Gráficos con sf, con múltiples variables (izquierda) y con una única variable (derecha).\nLos gráficos se añaden como capas las imágenes existentes estableciendo add = TRUE.8\nPara demostrar esto, y para proporcionar una muestra del contenido cubierto en los capítulos 3 y ?? sobre las operaciones de atributos y datos espaciales, el siguiente fragmento de código combina países de Asia:Ahora podemos representar el continente asiático sobre un mapa del mundo.\nTen en cuenta que el primer gráfico sólo debe tener una variable para que add = TRUE funcione.\nSi el primer gráfico tiene una leyenda, debe usarse reset = FALSE (el resultado se muestra):Añadir capas de esta manera puede servir para verificar la correspondencia geográfica entre capas: la función plot() es rápida de ejecutar y requiere pocas líneas de código, pero crea mapas interactivos con una amplia gama de opciones.\nPara la creación de mapas más avanzados, recomendamos utilizar paquetes de visualización dedicados ello, como tmap (véase el capítulo ??).","code":"\n\nplot(world[3:6])\nplot(world[\"pop\"])\nworld_asia = world[world$continent == \"Asia\", ]\nasia = st_union(world_asia)\nplot(world[\"pop\"], reset = FALSE)\nplot(asia, add = TRUE, col = \"red\")"},{"path":"spatial-class.html","id":"base-args","chapter":"2 Datos geográficos en R","heading":"2.2.4 Argumentos básicos de plot()","text":"Hay varias formas de modificar los mapas con el método plot() de sf.\nDado que sf amplía los métodos de representación gráfica básicos de R, los argumentos de plot() como main = (que especifica el título del mapa) funcionan con los objetos sf (véase ?graphics::plot y ?par).9\n\nLa figura 2.5 ilustra esta flexibilidad superponiendo círculos, cuyos diámetros (fijados con cex =) representan las poblaciones de los países, en un mapa del mundo.\nSe puede crear una versión proyectada de esta figura con los siguientes comandos (véanse los ejercicios al final de este capítulo y el script 02-contplot.R para reproducir la Figura 2.5):\nFIGURE 2.5: Continentes por países (representados por colores) y poblaciones de 2015 (representadas por círculos, con área proporcional su población).\nEl código anterior utiliza la función st_centroid() para convertir un tipo de geometría (polígonos) en otra (puntos) (véase el capítulo ??), cuya estética se modifica mediante el argumento cex.\nEl método de graficación de sf también tiene argumentos específicos para los datos geográficos. expandBB, por ejemplo, puede usarse para representar un objeto sf en su contexto:\ntoma un vector numérico de longitud cuatro que expande el contorno del gráfico relativo cero en el siguiente orden: abajo, izquierda, arriba, derecha.\nEsto se utiliza para dibujar India en el contexto de sus gigantescos vecinos asiáticos, con énfasis en China al este, en el siguiente fragmento de código, que genera la Figura 2.6 (véanse los ejercicios más adelante sobre la adición de texto los gráficos):\nFIGURE 2.6: India en su contexto, mostrando el resultado del argumento expandBB.\nNótese el uso de [0] para mantener sólo la columna de geometría y lwd para enfatizar India.\nVéase la sección ?? para otras técnicas de visualización para representar distintos tipos de geometrías, el tema de la siguiente sección.","code":"\nplot(world[\"continent\"], reset = FALSE)\ncex = sqrt(world$pop) / 10000\nworld_cents = st_centroid(world, of_largest = TRUE)\nplot(st_geometry(world_cents), add = TRUE, cex = cex)\nindia = world[world$name_long == \"India\", ]\nplot(st_geometry(india), expandBB = c(0, 0.2, 0.1, 1), col = \"gray\", lwd = 3)\nplot(world_asia[0], add = TRUE)"},{"path":"spatial-class.html","id":"geometry","chapter":"2 Datos geográficos en R","heading":"2.2.5 Tipos de geometrías","text":"Las geometrías son los componentes básicos de Simple features.\nSimple features en R pueden adoptar uno de los 17 tipos de geometría compatibles con el paquete sf.\n\n\nEn este capítulo nos centraremos en los siete tipos más utilizados: PUNTO, LÍNEA, POLÍGONO, MULTIPUNTO, MULTILÍNEA, MULTIPOLÍGONO y COLECCIÓN GEOMÉTRICA.\nEncontrarás la lista completa de tipos disponibles en el manual de PostGIS.Por lo general, la codificación estándar para Simple features es la binaria conocida (well-known binary en inglés (WKB)) o el texto conocido (well-known text en inglés (WKT)).\n\n\n\nLas representaciones de WKB suelen ser cadenas hexadecimales fácilmente legibles para los ordenadores.\nPor ello, los SIG y las bases de datos espaciales utilizan WKB para transferir y almacenar objetos geométricos.\nWKT, por otra parte, es una descripción de texto legible para el ser humano de Simple features.\nAmbos formatos son intercambiables, y si debemos presentar uno, naturalmente elegiremos la representación WKT.Las bases de cada tipo de geometría son los puntos.\nUn punto es simplemente una coordenada en el espacio 2D, 3D o 4D (véase vignette(\"sf1\") para más información) así como (véase el panel izquierdo de la figura 2.7):\nPOINT (5 2)\nUna cadena de líneas es una secuencia de puntos con una línea recta que los une, por ejemplo (véase el panel central de la figura 2.7):LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)Un polígono es una secuencia de puntos que forman un anillo cerrado y sin intersecciones.\nCerrado significa que el primer y el último punto de un polígono tienen las mismas coordenadas (véase el panel derecho de la figura 2.7).[\nPor definición, un polígono tiene un límite exterior (anillo exterior) y puede tener cero o más límites interiores (anillos interiores), también conocidos como agujeros.\nUn polígono con agujeros serían, por ejemplo, POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4))]\nPolígono cerrado: POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))\nFIGURE 2.7: Ilustración de geometrías de puntos, líneas y polígonos.\nHasta ahora hemos creado geometrías con una sola entidad geométrica por objeto.\nSin embargo, sf también permite la existencia de múltiples geometrías dentro de un único elemento (de ahí el término “colección de geometrías”) utilizando la versión “multi” de cada tipo de geometría:\nMultipunto: MULTIPOINT (5 2, 1 3, 3 4, 3 2)Multilínea: MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))Multipolígono: MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5), (0 2, 1 2, 1 3, 0 3, 0 2)))\nFIGURE 2.8: Illustration multi* geometries.\nPor último, una colección de geometrías puede contener cualquier combinación de geometrías, incluidos (multi)puntos y cadenas de líneas (véase la figura 2.9):\nColección de geometrías: GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2), LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))\nFIGURE 2.9: Ilustración de una colección de geometrías.\n","code":""},{"path":"spatial-class.html","id":"sfg","chapter":"2 Datos geográficos en R","heading":"2.2.6 Geometrías de Simple features (sfg)","text":"La clase sfg (Simple feature geometry en inglés) representa los diferentes tipos de geometrías de Simple features en R: punto, línea, polígono (y sus equivalentes ‘multi,’ como multipuntos) o colección de geometrías.\nPor lo general, te ahorras la tediosa tarea de crear geometrías por tu cuenta, ya que puedes simplemente importar un archivo espacial ya existente.\nSin embargo, existe un conjunto de funciones para crear objetos sfg desde cero si es necesario.\nLos nombres de estas funciones son sencillos y coherentes, ya que todas comienzan con el prefijo st_ y terminan con el nombre del tipo de geometría en minúsculas:Punto: st_point()Línea: st_linestring()Polígono: st_polygon()Multipunto: st_multipoint()Multilínea: st_multilinestring()Multipolígono: st_multipolygon()Colección geométrica: st_geometrycollection()Los objetos sfg pueden crearse partir de tres tipos de datos básicos de R:Un vector numérico: un solo puntoUna matriz: un conjunto de puntos, donde cada fila representa un punto, un multipunto o una líneaUna lista: una colección de objetos como matrices, multilíneas o colecciones de geometríasLa función st_point() crea puntos únicos partir de vectores numéricos:Los resultados muestran que los tipos de punto XY (coordenadas 2D), XYZ (coordenadas 3D) y XYZM (3D con una variable adicional, normalmente la precisión de la medición) se crean partir de vectores de longitud 2, 3 y 4, respectivamente.\nEl tipo XYM debe especificarse mediante el argumento dim (que es la abreviatura de dimensión).Por el contrario, utiliza matrices en el caso de los objetos multipunto (st_multipoint()) y en líneas (st_linestring()):Por último, utiliza listas para la creación de multilíneas, (multi)polígonos y colecciones de geometrías:","code":"\nst_point(c(5, 2))                 # XY point\n#> POINT (5 2)\nst_point(c(5, 2, 3))              # XYZ point\n#> POINT Z (5 2 3)\nst_point(c(5, 2, 1), dim = \"XYM\") # XYM point\n#> POINT M (5 2 1)\nst_point(c(5, 2, 3, 1))           # XYZM point\n#> POINT ZM (5 2 3 1)\n# la función rbind simplifica la creación de matrices\n## MULTIPUNTO\nmultipoint_matrix = rbind(c(5, 2), c(1, 3), c(3, 4), c(3, 2))\nst_multipoint(multipoint_matrix)\n#> MULTIPOINT ((5 2), (1 3), (3 4), (3 2))\n## LÍNEA\nlinestring_matrix = rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2))\nst_linestring(linestring_matrix)\n#> LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)\n## POLÍGONO\npolygon_list = list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))\nst_polygon(polygon_list)\n#> POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))\n## POLÍGONO no cerrado\npolygon_border = rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))\npolygon_hole = rbind(c(2, 4), c(3, 4), c(3, 3), c(2, 3), c(2, 4))\npolygon_with_hole_list = list(polygon_border, polygon_hole)\nst_polygon(polygon_with_hole_list)\n#> POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4))\n## MULTILÍNEA\nmultilinestring_list = list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), \n                            rbind(c(1, 2), c(2, 4)))\nst_multilinestring((multilinestring_list))\n#> MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))\n## MULTIPOLÍGONO\nmultipolygon_list = list(list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))),\n                         list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2))))\nst_multipolygon(multipolygon_list)\n#> MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5)), ((0 2, 1 2, 1 3, 0 3, 0 2)))\n## COLECCIÓN GEOMÉTRICA\ngemetrycollection_list = list(st_multipoint(multipoint_matrix),\n                              st_linestring(linestring_matrix))\nst_geometrycollection(gemetrycollection_list)\n#> GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2),\n#>   LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))"},{"path":"spatial-class.html","id":"sfc","chapter":"2 Datos geográficos en R","heading":"2.2.7 Columnas de simple features (sfc)","text":"Un objeto sfg contiene una sola geometría de Simple feature.\nUna columna de simple feature (Simple feature column en inglés (sfc)) es una lista de objetos sfg, que además puede contener información sobre el sistema de referencia de coordenadas en uso.\nPor ejemplo, para combinar dos objetos simple feature en un objeto con dos elementos, podemos utilizar la función st_sfc().\n\nEsto es importante puesto que sfc representa la columna de geometría en los marcos de datos sf:En la mayoría de los casos, un objeto sfc contiene objetos del mismo tipo de geometría.\nPor lo tanto, cuando convirtamos objetos sfg de tipo polígono en una columna de sfg, acabaríamos también con un objeto sfc de tipo polígono, lo cual puede verificarse con st_geometry_type().\nIgualmente, una columna de geometría de multilíneas resultaría en un objeto sfc de tipo multilíneas:También es posible crear un objeto sfc partir de objetos sfg con diferentes tipos de geometrías:Como se ha mencionado anteriormente, los objetos sfc pueden almacenar adicionalmente información sobre los sistemas de referencia de coordenadas (SRC).\nPara especificar un determinado SRC, podemos utilizar los atributos epsg (SRID) o proj4string de un objeto sfc.\nEl valor por defecto de epsg (SRID) y proj4string es NA (disponible o Available en inglés), como se puede comprobar con st_crs():Todas las geometrías de un objeto sfc deben tener el mismo SRC.\nPodemos añadir el sistema de referencia de coordenadas como argumento crs de st_sfc().\nEste argumento acepta un número entero con el código epsg como 4326, el cual añade automáticamente el ‘proj4string’ (véase la sección 2.4):También acepta un proj4string sin procesar (el resultado se muestra):","code":"\n# PUNTO sfc \npoint1 = st_point(c(5, 2))\npoint2 = st_point(c(1, 3))\npoints_sfc = st_sfc(point1, point2)\npoints_sfc\n#> Geometry set for 2 features \n#> Geometry type: POINT\n#> Dimension:     XY\n#> Bounding box:  xmin: 1 ymin: 2 xmax: 5 ymax: 3\n#> CRS:           NA\n#> POINT (5 2)\n#> POINT (1 3)\n# POLÍGONO sfc \npolygon_list1 = list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))\npolygon1 = st_polygon(polygon_list1)\npolygon_list2 = list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2)))\npolygon2 = st_polygon(polygon_list2)\npolygon_sfc = st_sfc(polygon1, polygon2)\nst_geometry_type(polygon_sfc)\n#> [1] POLYGON POLYGON\n#> 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n# MULTILÍNEA sfc \nmultilinestring_list1 = list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), \n                            rbind(c(1, 2), c(2, 4)))\nmultilinestring1 = st_multilinestring((multilinestring_list1))\nmultilinestring_list2 = list(rbind(c(2, 9), c(7, 9), c(5, 6), c(4, 7), c(2, 7)), \n                            rbind(c(1, 7), c(3, 8)))\nmultilinestring2 = st_multilinestring((multilinestring_list2))\nmultilinestring_sfc = st_sfc(multilinestring1, multilinestring2)\nst_geometry_type(multilinestring_sfc)\n#> [1] MULTILINESTRING MULTILINESTRING\n#> 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n# GEOMETRÍA sfc \npoint_multilinestring_sfc = st_sfc(point1, multilinestring1)\nst_geometry_type(point_multilinestring_sfc)\n#> [1] POINT           MULTILINESTRING\n#> 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\nst_crs(points_sfc)\n#> Coordinate Reference System: NA\n# definición EPSG \npoints_sfc_wgs = st_sfc(point1, point2, crs = 4326)\nst_crs(points_sfc_wgs)\n#> Coordinate Reference System:\n#>   User input: EPSG:4326 \n#>   wkt:\n#> GEOGCRS[\"WGS 84\",\n#>     DATUM[\"World Geodetic System 1984\",\n#>         ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n#>             LENGTHUNIT[\"metre\",1]]],\n#>     PRIMEM[\"Greenwich\",0,\n#>         ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>     CS[ellipsoidal,2],\n#>         AXIS[\"geodetic latitude (Lat)\",north,\n#>             ORDER[1],\n#>             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>         AXIS[\"geodetic longitude (Lon)\",east,\n#>             ORDER[2],\n#>             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>     USAGE[\n#>         SCOPE[\"unknown\"],\n#>         AREA[\"World\"],\n#>         BBOX[-90,-180,90,180]],\n#>     ID[\"EPSG\",4326]]\n# definición PROJ4STRING \nst_sfc(point1, point2, crs = \"+proj=longlat +datum=WGS84 +no_defs\")"},{"path":"spatial-class.html","id":"sf","chapter":"2 Datos geográficos en R","heading":"2.2.8 La clase sf","text":"Los apartados 2.2.5 2.2.7 tratan de objetos puramente geométricos, ‘sf geometry’ y ‘sf column’ respectivamente.\nEstos son bloques de construcción geográficos de datos vectoriales geográficos representados como simple features.\nEl último bloque de construcción son los atributos geográficos, los cuales representan el nombre de la función u otros atributos como los valores medidos, los grupos y otras cosas.\nPara ilustrar los atributos, representaremos una temperatura de 25°C en Londres el 21 de junio de 2017.\nEste ejemplo contiene una geometría (las coordenadas), y tres atributos con tres clases diferentes (nombre del lugar, temperatura y fecha).10\nLos objetos de clase sf representan esos datos combinando los atributos (data.frame) con la columna de geometrías simple (sfc).\nÉstos son creados con st_sf() como se ilustra continuación, lo cual crea el ejemplo de Londres descrito anteriormente:¿Qué ha pasado? En primer lugar, las coordenadas se utilizaron para crear la geometría simple feature (sfg).\nEn segundo lugar, la geometría se convirtió en una columna de geometrías simple feature (sfc), con un SRC.\nEn tercer lugar, los atributos se almacenaron en un data.frame, que se combinó con el objeto sfc con st_sf().\nEsto da como resultado un objeto sf, como se demuestra continuación (se omiten algunos resultados):El resultado muestra que los objetos sf tienen en realidad dos clases, sf y data.frame.\nsf son simplemente marcos de datos (tablas cuadradas), pero con atributos espaciales almacenados en una columna con forma de lista, normalmente llamada geometría, como se describe en el apartado 2.2.1.\nEsta dualidad es fundamental para el concepto de simple features:\nla mayoría de las veces, un sf puede tratarse y comportarse como un data.frame.\nSimple features son, en esencia, marcos de datos con una extensión espacial.","code":"\nlnd_point = st_point(c(0.1, 51.5))                 # objeto sfg \nlnd_geom = st_sfc(lnd_point, crs = 4326)           # objeto sfc \nlnd_attrib = data.frame(                           # objeto data.frame \n  name = \"London\",\n  temperature = 25,\n  date = as.Date(\"2017-06-21\")\n  )\nlnd_sf = st_sf(lnd_attrib, geometry = lnd_geom)    # objeto sf \nlnd_sf\n#> Simple feature collection with 1 features and 3 fields\n#> ...\n#>     name temperature       date         geometry\n#> 1 London          25 2017-06-21 POINT (0.1 51.5)\nclass(lnd_sf)\n#> [1] \"sf\"         \"data.frame\""},{"path":"spatial-class.html","id":"datos-rasterizados","chapter":"2 Datos geográficos en R","heading":"2.3 Datos rasterizados","text":"El modelo de datos espaciales rasterizados representa el mundo con la cuadrícula continua de celdas (menudo también llamadas píxeles; 2.10:).\nEste modelo de datos suele referirse las llamadas cuadrículas regulares, en las que cada celda tiene el mismo tamaño constante, y en este libro nos centraremos únicamente en las cuadrículas regulares.\nSin embargo, existen otros tipos de cuadrículas, como las cuadrículas rotadas, cizalladas, rectilíneas y curvilíneas (véase el capítulo 1 de E. Pebesma Bivand (2022) o el capítulo 2 de Tennekes Nowosad (2022))).El modelo de datos ráster suele consistir en una cabecera ráster\ny una matriz (con filas y columnas) que representa celdas igualmente espaciadas (menudo también llamadas píxeles; Figura 2.10:).11\nLa cabecera ráster define el sistema de referencia de coordenadas, la extensión y el origen.\n\n\nEl origen (o punto de partida) suele ser la coordenada de la esquina inferior izquierda de la matriz (el paquete terra, sin embargo, utiliza la esquina superior izquierda, por defecto (Figura 2.10:B)).\nLa cabecera define la extensión mediante el número de columnas, el número de filas y la resolución del tamaño de las celdas.\nPor lo tanto, partiendo del origen, podemos acceder fácilmente cada celda y modificarla utilizando su ID (Figura 2.10:B) o especificando explícitamente las filas y las columnas.\nEsta representación matricial evita almacenar explícitamente las coordenadas de los cuatro puntos de las esquinas (de hecho, sólo almacena una coordenada, el origen) de cada celda, como ocurriría con los polígonos vectoriales rectangulares.\nEsto y el álgebra de mapas (apartado (map-algebra)) hacen que el procesamiento de rásters sea mucho más eficiente y rápido que el de datos vectoriales.\nSin embargo, diferencia de los datos vectoriales, la celda de una capa ráster sólo puede contener un único valor. El valor puede ser numérico o categórico (Figura 2.10:C).\nFIGURE 2.10: Tipos de datos ráster: () IDs de celdas, (B) valores de celdas, (C) un mapa raster coloreado.\nLos mapas ráster suelen representar fenómenos continuos como la elevación, la temperatura, la densidad de población o los datos espectrales (Figura 2.11).\nPor supuesto, también podemos representar características discretas, como las clases de suelo o de cobertura del suelo, con la ayuda de un modelo de datos raster (Figura 2.11).\nEn consecuencia, los límites discretos de estas características se difuminan y, dependiendo de la tarea espacial, podría ser más adecuada una representación vectorial.\nFIGURE 2.11: Ejemplos de rásters continuos y categóricos.\n","code":""},{"path":"spatial-class.html","id":"paquetes-de-r-para-el-manejo-de-datos-rasterizados","chapter":"2 Datos geográficos en R","heading":"2.3.1 Paquetes de R para el manejo de datos rasterizados","text":"","code":""},{"path":"spatial-class.html","id":"introducción-a-terra","chapter":"2 Datos geográficos en R","heading":"2.3.2 Introducción a terra","text":"El paquete terra soporta objetos raster en R.\nProporciona un amplio conjunto de funciones para crear, leer, exportar, manipular y procesar conjuntos de datos raster.\nAparte de la manipulación general de datos ráster, terra proporciona muchas funciones de bajo nivel que pueden constituir la base para desarrollar una funcionalidad ráster más avanzada.\n\nterra también permite trabajar con grandes conjuntos de datos ráster que son demasiado grandes para caber en una memoria principal.\nEn este caso, terra ofrece la posibilidad de dividir el raster en fragmentos más pequeños, y los procesa iterativamente en lugar de cargar todo el archivo raster en la RAM.Para ilustrar los conceptos de terra, utilizaremos los conjuntos de datos de spDataLarge.\nSe trata de unos cuantos objetos ráster y un objeto vectorial que cubren una zona del Parque Nacional de Zion (Utah, EE.UU.).\nPor ejemplo, srtm.tif es un modelo digital de elevación de esta zona (para más detalles, véase su documentación con ?srtm).\nEn primer lugar, vamos crear un objeto SpatRaster llamado my_rast:Al escribir el nombre del raster en la consola, el resultado será la cabecera del raster (dimensiones, resolución, extensión, SRC) y alguna información adicional (clase, fuente de datos, resumen de los valores del ráster):Las funciones dedicadas informan de cada componente: dim(my_rast) retorna el número de filas, columnas y capas; ncell() el número de celdas (píxeles); res() la resolución espacial; ext() su extensión espacial; y crs() su sistema de referencia de coordenadas (la reproyección raster se trata en la Sección ??).\ninMemory() informa de si los datos raster están almacenados en memoria o en disco.help(\"terra-package\") retorna una lista completa de todas las funciones disponibles de terra","code":"\nraster_filepath = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nmy_rast = rast(raster_filepath)\nmy_rast\n#> class       : SpatRaster \n#> dimensions  : 457, 465, 1  (nrow, ncol, nlyr)\n#> resolution  : 0.000833, 0.000833  (x, y)\n#> extent      : -113, -113, 37.1, 37.5  (xmin, xmax, ymin, ymax)\n#> coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#> source      : srtm.tif \n#> name        : srtm \n#> min value   : 1024 \n#> max value   : 2892"},{"path":"spatial-class.html","id":"basic-map-raster","chapter":"2 Datos geográficos en R","heading":"2.3.3 Elaboración de mapas básicos","text":"Al igual que el paquete sf, terra también proporciona métodos plot() para sus propias clases.\n\nFIGURE 2.12: Gráfico raster básico.\nExisten otros enfoques para representar datos ráster en R que quedan fuera del alcance de esta sección, por ejemplo:paquetes como tmap para crear mapas estáticos e interactivos de objetos raster y vectoriales (véase el capítulo ??)funciones, por ejemplo levelplot() del paquete rasterVis, para crear facetas, una técnica común para visualizar el cambio en el tiempo","code":"\nplot(my_rast)"},{"path":"spatial-class.html","id":"raster-classes","chapter":"2 Datos geográficos en R","heading":"2.3.4 Clases ráster","text":"La clase SpatRaster representa un objeto raster en terra.\nLa forma más fácil de crear un objeto raster en R es leer un archivo raster desde el disco o desde un servidor (Sección ??).\nEl paquete terra soporta numerosos controles con la ayuda de la librería GDAL.\nLos rásters de los archivos suelen ser leídos en su totalidad en la memoria RAM, excepción de su cabecera y un puntero al propio archivo.Los rásters también pueden crearse desde cero utilizando la misma función rast().\nEsto se ilustra en el siguiente fragmento de código, que da como resultado un nuevo objeto SpatRaster.\nEl raster resultante consta de 36 celdas (6 columnas y 6 filas especificadas por nrows y ncols) centradas alrededor del Primer Meridiano y el Ecuador (ver parámetros xmin, xmax, ymin y ymax).\nEl SRC por defecto de los objetos ráster es WGS84, pero puede cambiarse con el argumento crs.\nEsto significa que la unidad de la resolución está en grados, que fijamos en 0,5 (resolución).\nLos valores (vals) se asignan cada celda: 1 la celda 1, 2 la celda 2, y así sucesivamente.\nRecuerda: rast() rellena las celdas por filas (diferencia de matrix()) empezando por la esquina superior izquierda, lo que significa que la fila superior contiene los valores del 1 al 6, la segunda del 7 al 12, etc.Para otras formas de crear objetos ráster, véase ?rast.La clase SpatRaster también maneja múltiples capas, que suelen corresponder un único archivo de satélite multiespectral o una serie temporal de rásters.nlyr() recupera el número de capas almacenadas en un objeto ‘SpatRaster’:","code":"\nsingle_raster_file = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nsingle_rast = rast(raster_filepath)\nnew_raster = rast(nrows = 6, ncols = 6, resolution = 0.5, \n                  xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n                  vals = 1:36)\nmulti_raster_file = system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmulti_rast = rast(multi_raster_file)\nmulti_rast\n#> class       : SpatRaster \n#> dimensions  : 1428, 1128, 4  (nrow, ncol, nlyr)\n#> resolution  : 30, 30  (x, y)\n#> extent      : 301905, 335745, 4111245, 4154085  (xmin, xmax, ymin, ymax)\n#> coord. ref. : WGS 84 / UTM zone 12N (EPSG:32612) \n#> source      : landsat.tif \n#> names       : lan_1, lan_2, lan_3, lan_4 \n#> min values  :  7550,  6404,  5678,  5252 \n#> max values  : 19071, 22051, 25780, 31961\nnlyr(multi_rast)\n#> [1] 4"},{"path":"spatial-class.html","id":"crs-intro","chapter":"2 Datos geográficos en R","heading":"2.4 Sistemas de referencia de coordenadas","text":"Los tipos de datos espaciales vectoriales y ráster comparten conceptos intrínsecos los datos espaciales.\nQuizás el más fundamental sea el Sistema de Referencia de Coordenadas (SRC), que define cómo se relacionan los elementos espaciales de los datos con la superficie de la Tierra (u otros cuerpos).\nLos SRC son geográficos o proyectados, tal y como se ha introducido al principio de este capítulo (véase la figura 2.1).\nEn esta sección se explicará cada tipo, sentando las bases para la Sección ?? sobre transformaciones de SRC.","code":""},{"path":"spatial-class.html","id":"sistemas-de-coordenadas-geográficas","chapter":"2 Datos geográficos en R","heading":"2.4.1 Sistemas de coordenadas geográficas","text":"\nLos sistemas de coordenadas geográficas identifican cualquier ubicación en la superficie de la Tierra mediante dos valores: la longitud y la latitud (véase el panel izquierdo de la figura 2.13 y 2.14).\nLa longitud es la ubicación en la dirección Este-Oeste en distancia angular desde el plano del Primer Meridiano (también conocido como Meridiano de Greenwich).\nLa latitud es la distancia angular al Norte o al Sur del plano ecuatorial.\nPor tanto, las distancias en los SRC geográficos se miden en metros.\nEsto tiene importantes consecuencias, como se demuestra en la sección ??.La superficie de la Tierra en los sistemas de coordenadas geográficas se representa mediante una superficie esférica o elipsoidal.\nLos modelos esféricos suponen que la Tierra es una esfera perfecta de un radio determinado; tienen la ventaja de la simplicidad pero, al mismo tiempo, son inexactos: ¡la Tierra es una esfera!\nLos modelos elipsoidales se definen mediante dos parámetros: el radio ecuatorial y el radio polar.\nÉstos son adecuados porque la Tierra está comprimida: el radio ecuatorial es unos 11,5 km más largo que el radio polar (Maling 1992).12Los elipsoides forman parte de un componente más amplio de los SRC: el datum.\nÉste contiene información sobre el elipsoide que debe utilizarse y la relación precisa entre las coordenadas cartesianas y la ubicación en la superficie de la Tierra.\n\nHay dos tipos de datum: geocéntrico y local.\nEn un dato geocéntrico, como el WGS84, el centro es el centro de gravedad de la Tierra y la precisión de las proyecciones está optimizada para una ubicación específica.\nEn un dato local, como el NAD83, la superficie elipsoidal se desplaza para alinearse con la superficie de un lugar concreto.\n\n","code":""},{"path":"spatial-class.html","id":"sistemas-de-referencia-de-coordenadas-proyectadas","chapter":"2 Datos geográficos en R","heading":"2.4.2 Sistemas de referencia de coordenadas proyectadas","text":"\nLos SRC proyectados se basan en coordenadas cartesianas sobre una superficie implícitamente plana (panel derecho de las Figuras 2.13 y 2.14).\nTienen un origen, unos ejes x e y y una unidad de medida lineal como los metros.\nTodos los SRC proyectados se basan en un SRC geográfico, descrito en la sección anterior, y se apoyan en proyecciones cartográficas para convertir la superficie tridimensional de la Tierra en valores de Este y Norte (x e y) en un SRC proyectado.Esta transición puede realizarse sin añadir algunas deformaciones.\nPor tanto, algunas propiedades de la superficie terrestre se distorsionan en este proceso, como el área, la dirección, la distancia y la forma.\nUn sistema de coordenadas proyectado puede conservar sólo una o dos de esas propiedades.\nLas proyecciones suelen denominarse en función de la propiedad que preservan: las de áreas iguales preservan el área, la azimutal preserva la dirección, la equidistante preserva la distancia y la conformal preserva la forma local.Existen tres grupos principales de tipos de proyección: cónica, cilíndrica y planar (azimutal).\nEn una proyección cónica, la superficie de la Tierra se proyecta en un cono lo largo de una única línea de tangencia o de dos líneas de tangencia.\nLas distorsiones se minimizan lo largo de las líneas de tangencia y aumentan con la distancia desde esas líneas en esta proyección.\nPor lo tanto, es la más adecuada para los mapas de zonas de latitud media.\nUna proyección cilíndrica representa la superficie en un cilindro.\nEsta proyección también puede crearse tocando la superficie de la Tierra lo largo de una sola línea de tangencia o de dos líneas de tangencia.\nLas proyecciones cilíndricas son las que más se utilizan para cartografiar el mundo en su totalidad.\nUna proyección plana proyecta los datos sobre una superficie plana que toca el globo en un punto o lo largo de una línea de tangencia.\nSe suele utilizar para cartografiar regiones polares.\nsf_proj_info(type = \"proj\") ofrece una lista de las proyecciones disponibles que admite la librería PROJ.\nFIGURE 2.13: Ejemplos de sistemas de coordenadas geográficas (WGS 84; izquierda) y proyectadas (NAD83 / zona UTM 12N; derecha) para datos vectoriales.\n\nFIGURE 2.14: Ejemplos de sistemas de coordenadas geográficas (WGS 84; izquierda) y proyectadas (NAD83 / zona UTM 12N; derecha) para datos rasterizados.\n","code":""},{"path":"spatial-class.html","id":"crs-in-r","chapter":"2 Datos geográficos en R","heading":"2.4.3 SRC en R","text":"\n\n\nDos formas recomendables de describir los SRC en R son () los identificadores de sistemas de referencia espacial (Spatial Reference System Identifiers en inglés (SRID)) o (b) las definiciones de texto conocidas (WKT2).\nAmbos enfoques tienen ventajas y desventajas.Un código epsg suele ser más corto y, por tanto, más fácil de recordar.\nEl código también se refiere un solo sistema de referencia de coordenadas bien definido.Los paquetes espaciales de R admiten una amplia gama de SRC y utilizan la biblioteca PROJ, establecida desde hace tiempo.\n\n\n\n\nEn sf el SRC de un objeto puede ser recuperado usando st_crs().\nPara ello, necesitamos leer un conjunto de datos vectoriales:Nuestro nuevo objeto, new_vector, es un polígono que representa los límites del Parque Nacional de Zion (?zion).En los casos en que falta un sistema de referencia de coordenadas (SRC) o se establece un SRC incorrecto, se puede utilizar la función st_set_crs():El mensaje de advertencia nos informa de que la función st_set_crs() transforma los datos de un SRC otro.La función crs() se puede utilizar para acceder la información del SRC desde un objeto SpatRaster:La misma función, crs(), se utiliza para establecer un SRC para los objetos raster.Es importante destacar que las funciones st_crs() y crs() alteran los valores de las coordenadas ni las geometrías.\nSu función es sólo la de establecer los metadatos sobre el objeto SRC.\nAmpliaremos los SRC y explicaremos cómo proyectar de un SRC otro en el capítulo ??.","code":"\nvector_filepath = system.file(\"vector/zion.gpkg\", package = \"spDataLarge\")\nnew_vector = st_read(vector_filepath)\nst_crs(new_vector) # get CRS\n#> Coordinate Reference System:\n#>   User input: UTM Zone 12, Northern Hemisphere \n#>   wkt:\n#> BOUNDCRS[\n#>     SOURCECRS[\n#>         PROJCRS[\"UTM Zone 12, Northern Hemisphere\",\n#>             BASEGEOGCRS[\"GRS 1980(IUGG, 1980)\",\n#>                 DATUM[\"unknown\",\n#>                     ELLIPSOID[\"GRS80\",6378137,298.257222101,\n#>                         LENGTHUNIT[\"metre\",1,\n#>                             ID[\"EPSG\",9001]]]],\n#>                 PRIMEM[\"Greenwich\",0,\n#>                     ANGLEUNIT[\"degree\",0.0174532925199433]]],\n#>             CONVERSION[\"UTM zone 12N\",\n#>                 METHOD[\"Transverse Mercator\",\n#>                     ID[\"EPSG\",9807]],\n#>                 PARAMETER[\"Latitude of natural origin\",0,\n#>                     ANGLEUNIT[\"degree\",0.0174532925199433],\n#>                     ID[\"EPSG\",8801]],\n#>                 PARAMETER[\"Longitude of natural origin\",-111,\n#>                     ANGLEUNIT[\"degree\",0.0174532925199433],\n#>                     ID[\"EPSG\",8802]],\n#>                 PARAMETER[\"Scale factor at natural origin\",0.9996,\n#>                     SCALEUNIT[\"unity\",1],\n#>                     ID[\"EPSG\",8805]],\n#>                 PARAMETER[\"False easting\",500000,\n#>                     LENGTHUNIT[\"Meter\",1],\n#>                     ID[\"EPSG\",8806]],\n#>                 PARAMETER[\"False northing\",0,\n#>                     LENGTHUNIT[\"Meter\",1],\n#>                     ID[\"EPSG\",8807]],\n#>                 ID[\"EPSG\",16012]],\n#>             CS[Cartesian,2],\n#>                 AXIS[\"(E)\",east,\n#>                     ORDER[1],\n#>                     LENGTHUNIT[\"Meter\",1]],\n#>                 AXIS[\"(N)\",north,\n#>                     ORDER[2],\n#>                     LENGTHUNIT[\"Meter\",1]]]],\n#>     TARGETCRS[\n#>         GEOGCRS[\"WGS 84\",\n#>             DATUM[\"World Geodetic System 1984\",\n#>                 ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n#>                     LENGTHUNIT[\"metre\",1]]],\n#>             PRIMEM[\"Greenwich\",0,\n#>                 ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>             CS[ellipsoidal,2],\n#>                 AXIS[\"latitude\",north,\n#>                     ORDER[1],\n#>                     ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>                 AXIS[\"longitude\",east,\n#>                     ORDER[2],\n#>                     ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>             ID[\"EPSG\",4326]]],\n#>     ABRIDGEDTRANSFORMATION[\"Transformation from GRS 1980(IUGG, 1980) to WGS84\",\n#>         METHOD[\"Position Vector transformation (geog2D domain)\",\n#>             ID[\"EPSG\",9606]],\n#>         PARAMETER[\"X-axis translation\",0,\n#>             ID[\"EPSG\",8605]],\n#>         PARAMETER[\"Y-axis translation\",0,\n#>             ID[\"EPSG\",8606]],\n#>         PARAMETER[\"Z-axis translation\",0,\n#>             ID[\"EPSG\",8607]],\n#>         PARAMETER[\"X-axis rotation\",0,\n#>             ID[\"EPSG\",8608]],\n#>         PARAMETER[\"Y-axis rotation\",0,\n#>             ID[\"EPSG\",8609]],\n#>         PARAMETER[\"Z-axis rotation\",0,\n#>             ID[\"EPSG\",8610]],\n#>         PARAMETER[\"Scale difference\",1,\n#>             ID[\"EPSG\",8611]]]]\nnew_vector = st_set_crs(new_vector, \"EPSG:26912\") # set CRS\n#> Warning: st_crs<- : replacing crs does not reproject data; use st_transform for\n#> that\ncrs(my_rast) # get CRS\n#> [1] \"GEOGCRS[\\\"WGS 84\\\",\\n    DATUM[\\\"World Geodetic System 1984\\\",\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"geodetic latitude (Lat)\\\",north,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        AXIS[\\\"geodetic longitude (Lon)\\\",east,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    ID[\\\"EPSG\\\",4326]]\"\nmy_rast2 = my_rast\ncrs(my_rast2) = \"EPSG:26912\" # set CRS"},{"path":"spatial-class.html","id":"paquete-units","chapter":"2 Datos geográficos en R","heading":"2.5 Paquete Units","text":"Una característica importante de los SRC es que contienen información sobre las unidades espaciales.\nEstá claro que es vital saber si las medidas de una casa están en pies o en metros, y lo mismo ocurre con los mapas.\nEs una buena práctica cartográfica añadir una barra de escala o algún otro indicador de distancia en los mapas para demostrar la relación entre las distancias en la página o la pantalla y las distancias sobre el terreno.\nDel mismo modo, es importante especificar formalmente las unidades en las que se miden los datos geométricos o las celdas para proporcionar un contexto, y garantizar que los cálculos posteriores se realicen en contexto.Una característica novedosa de los datos geométricos en los objetos sf es que tienen soporte nativo para las unidades.\nEsto significa que la distancia, el área y otros cálculos geométricos en sf devuelven valores que vienen con un atributo de unidades, definido por el paquete Units (E. Pebesma, Mailund, Hiebert 2016).\nEsto es ventajoso, ya que evita la confusión causada por las diferentes unidades (la mayoría de los SRC utilizan metros, algunos utilizan pies) y proporciona información sobre la dimensionalidad.\nEsto se demuestra en el siguiente fragmento de código, que calcula la superficie de Luxemburgo:\n\nEl resultado está en unidades de metros cuadrados (m2), lo que demuestra que el resultado representa un espacio bidimensional.\nEsta información, almacenada como un atributo (que los lectores interesados pueden descubrir con attributes(st_area(luxembourg))), puede aportar cálculos posteriores que utilicen unidades, como la densidad de población (que se mide en personas por unidad de superficie, normalmente por km2).\nInformar de las unidades evita confusiones.\nPor ejemplo, en el caso de Luxemburgo, si se especificaran las unidades, se podría suponer erróneamente que se trata de hectáreas.\nPara traducir la enorme cifra un tamaño más digerible, resulta tentador dividir los resultados por un millón (el número de metros cuadrados en un kilómetro cuadrado):Sin embargo, el resultado se vuelve dar incorrectamente como metros cuadrados.\nLa solución es establecer las unidades correctas con el paquete Units:Las unidades tienen la misma importancia en el caso de los datos ráster.\nSin embargo, hasta ahora sf es el único paquete espacial que soporta unidades, lo que significa que las personas que trabajan con datos ráster deben abordar los cambios en las unidades de análisis (por ejemplo, la conversión de la anchura de los píxeles de unidades imperiales decimales) con cuidado.\nEl objeto my_rast (véase más arriba) utiliza una proyección WGS84 con grados decimales como unidades.\nEn consecuencia, su resolución también se da en grados decimales, pero hay que conocerla, ya que la función res() simplemente devuelve un vector numérico.Si utilizáramos la proyección UTM, las unidades cambiarían.De nuevo, el comando res() devuelve un vector numérico sin ninguna unidad, lo que nos obliga saber que la unidad de la proyección UTM es el metro.","code":"\nluxembourg = world[world$name_long == \"Luxembourg\", ]\nst_area(luxembourg) # requiere del paquete s2 en versiones recientes de sf\n#> 2.41e+09 [m^2]\nst_area(luxembourg) / 1000000\n#> 2409 [m^2]\nunits::set_units(st_area(luxembourg), km^2)\n#> 2409 [km^2]\nres(my_rast)\n#> [1] 0.000833 0.000833\nrepr = project(my_rast, \"EPSG:26912\")\nres(repr)"},{"path":"spatial-class.html","id":"ex2","chapter":"2 Datos geográficos en R","heading":"2.6 Ejercicios","text":"","code":""},{"path":"attr.html","id":"attr","chapter":"3 Attribute data operations","heading":"3 Attribute data operations","text":"","code":""},{"path":"attr.html","id":"prerequisites","chapter":"3 Attribute data operations","heading":"Prerequisites","text":"chapter requires following packages installed attached:also relies spData, loads datasets used code examples chapter:","code":"\nlibrary(sf)      # vector data package introduced in Chapter 2\nlibrary(terra)   # raster data package introduced in Chapter 2\nlibrary(dplyr)   # tidyverse package for data frame manipulation\nlibrary(spData)  # spatial data package introduced in Chapter 2"},{"path":"attr.html","id":"introduction","chapter":"3 Attribute data operations","heading":"3.1 Introduction","text":"Attribute data non-spatial information associated geographic (geometry) data.\nbus stop provides simple example: position typically represented latitude longitude coordinates (geometry data), addition name.\nElephant & Castle / New Kent Road stop London, example coordinates -0.098 degrees longitude 51.495 degrees latitude can represented POINT (-0.098 51.495) sfc representation described Chapter 2.\nAttributes name attribute POINT feature (use Simple Features terminology) topic chapter.Another example elevation value (attribute) specific grid cell raster data.\nUnlike vector data model, raster data model stores coordinate grid cell indirectly, meaning distinction attribute spatial information less clear.\nillustrate point, think pixel 3rd row 4th column raster matrix.\nspatial location defined index matrix: move origin four cells x direction (typically east right maps) three cells y direction (typically south ).\nraster’s resolution defines distance x- y-step specified header.\nheader vital component raster datasets specifies pixels relate geographic coordinates (see also Chapter ??).teaches manipulate geographic objects based attributes names bus stops vector dataset elevations pixels raster dataset.\nvector data, means techniques subsetting aggregation (see Sections 3.2.1 3.2.3).\nSections 3.2.4 3.2.5 demonstrate join data onto simple feature objects using shared ID create new variables, respectively.\noperations spatial equivalent:\n[ operator base R, example, works equally subsetting objects based attribute spatial objects; can also join attributes two geographic datasets using spatial joins.\ngood news: skills developed chapter cross-transferable.\nChapter ?? extends methods presented spatial world.deep dive various types vector attribute operations next section, raster attribute data operations covered Section 3.3, demonstrates create raster layers containing continuous categorical attributes extracting cell values one layer (raster subsetting).\nSection 3.3.2 provides overview ‘global’ raster operations can used summarize entire raster datasets.","code":""},{"path":"attr.html","id":"vector-attribute-manipulation","chapter":"3 Attribute data operations","heading":"3.2 Vector attribute manipulation","text":"Geographic vector datasets well supported R thanks sf class, extends base R’s data.frame.\nLike data frames, sf objects one column per attribute variable (‘name’) one row per observation feature (e.g., per bus station).\nsf objects differ basic data frames geometry column class sfc can contain range geographic entities (single ‘multi’ point, line, polygon features) per row.\ndescribed Chapter 2, demonstrated generic methods plot() summary() work sf objects.\nsf also provides generics allow sf objects behave like regular data frames, shown printing class’s methods:Many (aggregate(), cbind(), merge(), rbind() [) manipulating data frames.\nrbind(), example, binds rows two data frames together, one ‘top’ .\n$<- creates new columns.\nkey feature sf objects store spatial non-spatial data way, columns data.frame.geometry column sf objects typically called geometry geom name can used.\nfollowing command, example, creates geometry column named g:st_sf(data.frame(n = world$name_long), g = world$geom)sf objects can also extend tidyverse classes data frames, tibble tbl.\n.\nThus sf enables full power R’s data analysis capabilities unleashed geographic data, whether use base R tidyverse functions data analysis.\n\n(See Rdatatable/data.table#2273 discussion compatibility sf objects fast data.table package.)\nusing capabilities worth re-capping discover basic properties vector data objects.\nLet’s start using base R functions learn world dataset **spData* package:world contains ten non-geographic columns (one geometry list column) almost 200 rows representing world’s countries.\nfunction st_drop_geometry() keeps attributes data sf object, words removing geometry:Dropping geometry column working attribute data can useful; data manipulation processes can run faster work attribute data geometry columns always needed.\ncases, however, makes sense keep geometry column, explaining column ‘sticky’ (remains attribute operations unless specifically dropped).\nNon-spatial data operations sf objects change object’s geometry appropriate (e.g., dissolving borders adjacent polygons following aggregation).\nBecoming skilled geographic attribute data manipulation means becoming skilled manipulating data frames.many applications, tidyverse package dplyr offers effective approach working data frames.\nTidyverse compatibility advantage sf predecessor sp, pitfalls avoid (see supplementary tidyverse-pitfalls vignette geocompr.github.io details).","code":"\nmethods(class = \"sf\") # methods for sf objects, first 12 shown\n#>  [1] aggregate             cbind                 coerce               \n#>  [4] initialize            merge                 plot                 \n#>  [7] print                 rbind                 [                    \n#> [10] [[<-                  $<-                   show                 \nclass(world) # it's an sf object and a (tidy) data frame\n#> [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\ndim(world)   # it is a 2 dimensional object, with 177 rows and 11 columns\n#> [1] 177  11\nworld_df = st_drop_geometry(world)\nclass(world_df)\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\nncol(world_df)\n#> [1] 10"},{"path":"attr.html","id":"vector-attribute-subsetting","chapter":"3 Attribute data operations","heading":"3.2.1 Vector attribute subsetting","text":"Base R subsetting methods include operator [ function subset().\nkey dplyr subsetting functions filter() slice() subsetting rows, select() subsetting columns.\napproaches preserve spatial components attribute data sf objects, using operator $ dplyr function pull() return single attribute column vector lose attribute data, see.\n\nsection focuses subsetting sf data frames; details subsetting vectors non-geographic data frames recommend reading section section 2.7 Introduction R (rcoreteam_introduction_2021?) Chapter 4 Advanced R Programming (wickham_advanced_2019?), respectively.[ operator can subset rows columns.\nIndices placed inside square brackets placed directly data frame object name specify elements keep.\ncommand object[, j] means ’return rows represented columns represented j, j typically contain integers TRUEs FALSEs (indices can also character strings, indicating row column names).\nobject[5, 1:3], example, means ’return data containing 5th row columns 1 3: result data frame 1 row 3 columns, fourth geometry column ’s sf object.\nLeaving j empty returns rows columns, world[1:5, ] returns first five rows 11 columns.\nexamples demonstrate subsetting base R.\nGuess number rows columns sf data frames returned command check results computer (see end chapter exercises):demonstration utility using logical vectors subsetting shown code chunk .\ncreates new object, small_countries, containing nations whose surface area smaller 10,000 km2:intermediary i_small (short index representing small countries) logical vector can used subset seven smallest countries world surface area.\nconcise command, omits intermediary object, generates result:base R function subset() provides another way achieve result:Base R functions mature, stable widely used, making rock solid choice, especially contexts reproducibility reliability key.\ndplyr functions enable ‘tidy’ workflows people (authors book included) find intuitive productive interactive data analysis, especially combined code editors RStudio enable auto-completion column names.\nKey functions subsetting data frames (including sf data frames) dplyr functions demonstrated .\n\n\n\nselect() selects columns name position.\nexample, select two columns, name_long pop, following command:Note: equivalent command base R (world[, c(\"name_long\", \"pop\")]), sticky geom column remains.\nselect() also allows selecting range columns help : operator:can remove specific columns - operator:Subset rename columns time new_name = old_name syntax:worth noting command concise base R equivalent, requires two lines code:select() also works ‘helper functions’ advanced subsetting operations, including contains(), starts_with() num_range() (see help page ?select details).dplyr verbs return data frame, can extract single column vector pull().\n\n\n\ncan get result base R list subsetting operators $ [[, three following commands return numeric vector:slice() row-equivalent select().\nfollowing code chunk, example, selects rows 1 6:filter() dplyr’s equivalent base R’s subset() function.\nkeeps rows matching given criteria, e.g., countries area certain threshold, high average life expectancy, shown following examples:standard set comparison operators can used filter() function, illustrated Table 3.1:TABLE 3.1: Comparison operators return Booleans (TRUE/FALSE).","code":"\nworld[1:6, ]    # subset rows by position\nworld[, 1:3]    # subset columns by position\nworld[1:6, 1:3] # subset rows and columns by position\nworld[, c(\"name_long\", \"pop\")] # columns by name\nworld[, c(T, T, F, F, F, F, F, T, T, F, F)] # by logical indices\nworld[, 888] # an index representing a non-existent column\ni_small = world$area_km2 < 10000\nsummary(i_small) # a logical vector\n#>    Mode   FALSE    TRUE \n#> logical     170       7\nsmall_countries = world[i_small, ]\nsmall_countries = world[world$area_km2 < 10000, ]\nsmall_countries = subset(world, area_km2 < 10000)\nworld1 = dplyr::select(world, name_long, pop)\nnames(world1)\n#> [1] \"name_long\" \"pop\"       \"geom\"\n# all columns between name_long and pop (inclusive)\nworld2 = dplyr::select(world, name_long:pop)\n# all columns except subregion and area_km2 (inclusive)\nworld3 = dplyr::select(world, -subregion, -area_km2)\nworld4 = dplyr::select(world, name_long, population = pop)\nworld5 = world[, c(\"name_long\", \"pop\")] # subset columns by name\nnames(world5)[names(world5) == \"pop\"] = \"population\" # rename column manually\npull(world, pop)\nworld$pop\nworld[[\"pop\"]]\nslice(world, 1:6)\nworld7 = filter(world ,area_km2 < 10000) # countries with a small area\nworld7 = filter(world, lifeExp > 82)      # with high life expectancy"},{"path":"attr.html","id":"chaining-commands-with-pipes","chapter":"3 Attribute data operations","heading":"3.2.2 Chaining commands with pipes","text":"Key workflows using dplyr functions ‘pipe’ operator %>% (since R 4.1.0 native pipe |>), takes name Unix pipe | (Grolemund Wickham 2016).\nPipes enable expressive code: output previous function becomes first argument next function, enabling chaining.\nillustrated , countries Asia filtered world dataset, next object subset columns (name_long continent) first five rows (result shown).chunk shows pipe operator allows commands written clear order:\nrun top bottom (line--line) left right.\nalternative %>% nested function calls, harder read:","code":"\nworld7 = world %>%\n  filter(continent == \"Asia\") %>%\n  dplyr::select(name_long, continent) %>%\n  slice(1:5)\nworld8 = slice(\n  dplyr::select(\n    filter(world, continent == \"Asia\"),\n    name_long, continent),\n  1:5)"},{"path":"attr.html","id":"vector-attribute-aggregation","chapter":"3 Attribute data operations","heading":"3.2.3 Vector attribute aggregation","text":"\n\nAggregation involves summarizing data one ‘grouping variables,’ typically columns data frame aggregated (geographic aggregation covered next chapter).\nexample attribute aggregation calculating number people per continent based country-level data (one row per country).\nworld dataset contains necessary ingredients: columns pop continent, population grouping variable, respectively.\naim find sum() country populations continent, resulting smaller data frame (aggregation form data reduction can useful early step working large datasets).\ncan done base R function aggregate() follows:result non-spatial data frame six rows, one per continent, two columns reporting name population continent (see Table 3.2 results top 3 populous continents).aggregate() generic function means behaves differently depending inputs.\nsf provides method aggregate.sf() activated automatically x sf object argument provided:resulting world_agg2 object spatial object containing 8 features representing continents world (open ocean).\ngroup_by() %>% summarize() dplyr equivalent aggregate(), variable name provided group_by() function specifying grouping variable information summarized passed summarize() function, shown :approach may seem complex benefits: flexibility, readability, control new column names.\nflexibility illustrated command , calculates population also area number countries continent:previous code chunk pop, area (sqkm) n column names result, sum() n() aggregating functions.\naggregating functions return sf objects rows representing continents geometries containing multiple polygons representing land mass associated islands (works thanks geometric operation ‘union,’ explained Section ??).Let’s combine learned far dplyr functions, chaining multiple commands summarize attribute data countries worldwide continent.\nfollowing command calculates population density (mutate()), arranges continents number countries contain (dplyr::arrange()), keeps 3 populous continents (top_n()), result presented Table 3.2):TABLE 3.2: top 3 populous continents ordered population density (people per square km).","code":"\nworld_agg1 = aggregate(pop ~ continent, FUN = sum, data = world, na.rm = TRUE)\nclass(world_agg1)\n#> [1] \"data.frame\"\nworld_agg2 = aggregate(world[\"pop\"], list(world$continent), FUN = sum, na.rm = TRUE)\nclass(world_agg2)\n#> [1] \"sf\"         \"data.frame\"\nnrow(world_agg2)\n#> [1] 8\nworld_agg3 = world %>%\n  group_by(continent) %>%\n  summarize(pop = sum(pop, na.rm = TRUE))\nworld_agg4  = world %>% \n  group_by(continent) %>%\n  summarize(pop = sum(pop, na.rm = TRUE), `area (sqkm)` = sum(area_km2), n = n())\nworld_agg5 = world %>% \n  st_drop_geometry() %>%                      # drop the geometry for speed\n  dplyr::select(pop, continent, area_km2) %>% # subset the columns of interest  \n  group_by(continent) %>%                     # group by continent and summarize:\n  summarize(Pop = sum(pop, na.rm = TRUE), Area = sum(area_km2), N = n()) %>%\n  mutate(Density = round(Pop / Area)) %>%     # calculate population density\n  top_n(n = 3, wt = Pop) %>%                  # keep only the top 3\n  arrange(desc(N))                            # arrange in order of n. countries"},{"path":"attr.html","id":"vector-attribute-joining","chapter":"3 Attribute data operations","heading":"3.2.4 Vector attribute joining","text":"Combining data different sources common task data preparation.\nJoins combining tables based shared ‘key’ variable.\ndplyr multiple join functions including left_join() inner_join() — see vignette(\"two-table\") full list.\nfunction names follow conventions used database language SQL (Grolemund Wickham 2016, chap. 13); using join non-spatial datasets sf objects focus section.\ndplyr join functions work data frames sf objects, important difference geometry list column.\nresult data joins can either sf data.frame object.\ncommon type attribute join spatial data takes sf object first argument adds columns data.frame specified second argument.\n\ndemonstrate joins, combine data coffee production world dataset.\ncoffee data data frame called coffee_data spData package (see ?coffee_data details).\n3 columns:\nname_long names major coffee-producing nations coffee_production_2016 coffee_production_2017 contain estimated values coffee production units 60-kg bags year.\n‘left join,’ preserves first dataset, merges world coffee_data:input datasets share ‘key variable’ (name_long) join worked without using argument (see ?left_join details).\nresult sf object identical original world object two new variables (column indices 11 12) coffee production.\ncan plotted map, illustrated Figure 3.1, generated plot() function :\nFIGURE 3.1: World coffee production (thousand 60-kg bags) country, 2017. Source: International Coffee Organization.\njoining work, ‘key variable’ must supplied datasets.\ndefault dplyr uses variables matching names.\ncase, world_coffee world objects contained variable called name_long, explaining message Joining, = \"name_long\".\nmajority cases variable names , two options:Rename key variable one objects match.Use argument specify joining variables.latter approach demonstrated renamed version coffee_data:Note name original object kept, meaning world_coffee new object world_coffee2 identical.\nAnother feature result number rows original dataset.\nAlthough 47 rows data coffee_data, 177 country records kept intact world_coffee world_coffee2:\nrows original dataset match assigned NA values new coffee production variables.\nwant keep countries match key variable?\ncase inner join can used:Note result inner_join() 45 rows compared 47 coffee_data.\nhappened remaining rows?\ncan identify rows match using setdiff() function follows:result shows Others accounts one row present world dataset name Democratic Republic Congo accounts :\nabbreviated, causing join miss .\nfollowing command uses string matching (regex) function stringr package confirm Congo, Dem. Rep. :fix issue, create new version coffee_data update name.\ninner_join()ing updated data frame returns result 46 coffee-producing nations:also possible join direction: starting non-spatial dataset adding variables simple features object.\ndemonstrated , starts coffee_data object adds variables original world dataset.\ncontrast previous joins, result another simple feature object, data frame form tidyverse tibble:\noutput join tends match first argument:section covers majority joining use cases.\ninformation, recommend Grolemund Wickham (2016), join vignette geocompkg package accompanies book, documentation data.table package.13\nAnother type join spatial join, covered next chapter (Section ??).","code":"\nworld_coffee = left_join(world, coffee_data)\n#> Joining, by = \"name_long\"\nclass(world_coffee)\n#> [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\nnames(world_coffee)\n#>  [1] \"iso_a2\"                 \"name_long\"              \"continent\"             \n#>  [4] \"region_un\"              \"subregion\"              \"type\"                  \n#>  [7] \"area_km2\"               \"pop\"                    \"lifeExp\"               \n#> [10] \"gdpPercap\"              \"geom\"                   \"coffee_production_2016\"\n#> [13] \"coffee_production_2017\"\nplot(world_coffee[\"coffee_production_2017\"])\ncoffee_renamed = rename(coffee_data, nm = name_long)\nworld_coffee2 = left_join(world, coffee_renamed, by = c(name_long = \"nm\"))\nworld_coffee_inner = inner_join(world, coffee_data)\n#> Joining, by = \"name_long\"\nnrow(world_coffee_inner)\n#> [1] 45\nsetdiff(coffee_data$name_long, world$name_long)\n#> [1] \"Congo, Dem. Rep. of\" \"Others\"\n(drc = stringr::str_subset(world$name_long, \"Dem*.+Congo\"))\n#> [1] \"Democratic Republic of the Congo\"\ncoffee_data$name_long[grepl(\"Congo,\", coffee_data$name_long)] = drc\nworld_coffee_match = inner_join(world, coffee_data)\n#> Joining, by = \"name_long\"\nnrow(world_coffee_match)\n#> [1] 46\ncoffee_world = left_join(coffee_data, world)\n#> Joining, by = \"name_long\"\nclass(coffee_world)\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\""},{"path":"attr.html","id":"vec-attr-creation","chapter":"3 Attribute data operations","heading":"3.2.5 Creating attributes and removing spatial information","text":"Often, like create new column based already existing columns.\nexample, want calculate population density country.\nneed divide population column, pop, area column, area_km2 unit area square kilometers.\nUsing base R, can type:Alternatively, can use one dplyr functions - mutate() transmute().\nmutate() adds new columns penultimate position sf object (last one reserved geometry):difference mutate() transmute() latter drops existing columns (except sticky geometry column):unite() tidyr package (provides many useful functions reshaping datasets, including pivot_longer()) pastes together existing columns.\nexample, want combine continent region_un columns new column named con_reg.\nAdditionally, can define separator (: colon :) defines values input columns joined, original columns removed (: TRUE):separate() function opposite unite(): splits one column multiple columns using either regular expression character positions.\nfunction also comes tidyr package.dplyr function rename() base R function setNames() useful renaming columns.\nfirst replaces old name new one.\nfollowing command, example, renames lengthy name_long column simply name:setNames() changes column names , requires character vector name matching column.\nillustrated , outputs world object, short names:important note attribute data operations preserve geometry simple features.\nmentioned outset chapter, can useful remove geometry.\n, explicitly remove .\nHence, approach select(world, -geom) unsuccessful instead use st_drop_geometry().14","code":"\nworld_new = world # do not overwrite our original data\nworld_new$pop_dens = world_new$pop / world_new$area_km2\nworld %>% \n  mutate(pop_dens = pop / area_km2)\nworld %>% \n  transmute(pop_dens = pop / area_km2)\nworld_unite = world %>%\n  unite(\"con_reg\", continent:region_un, sep = \":\", remove = TRUE)\nworld_separate = world_unite %>% \n  separate(con_reg, c(\"continent\", \"region_un\"), sep = \":\")\nworld %>% \n  rename(name = name_long)\nnew_names = c(\"i\", \"n\", \"c\", \"r\", \"s\", \"t\", \"a\", \"p\", \"l\", \"gP\", \"geom\")\nworld %>% \n  setNames(new_names)\nworld_data = world %>% st_drop_geometry()\nclass(world_data)\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\""},{"path":"attr.html","id":"manipulating-raster-objects","chapter":"3 Attribute data operations","heading":"3.3 Manipulating raster objects","text":"contrast vector data model underlying simple features (represents points, lines polygons discrete entities space), raster data represent continuous surfaces.\nsection shows raster objects work creating scratch, building Section ??.\nunique structure, subsetting operations raster datasets work different way, demonstrated Section 3.3.1.\nfollowing code recreates raster dataset used Section 2.3.4, result illustrated Figure 3.2.\ndemonstrates rast() function works create example raster named elev (representing elevations).result raster object 6 rows 6 columns (specified nrow ncol arguments), minimum maximum spatial extent x y direction (xmin, xmax, ymin, ymax).\nvals argument sets values cell contains: numeric data ranging 1 36 case.\nRaster objects can also contain categorical values class logical factor variables R.\nfollowing code creates raster representing grain sizes (Figure 3.2):raster object stores corresponding look-table “Raster Attribute Table” (RAT) list data frames, can viewed cats(grain) (see ?cats() information).\nelement list layer raster.\nalso possible use function levels() retrieving adding new replacing existing factor levels:\nFIGURE 3.2: Raster datasets numeric (left) categorical values (right).\n","code":"\nelev = rast(nrows = 6, ncols = 6, resolution = 0.5, \n            xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n            vals = 1:36)\ngrain_order = c(\"clay\", \"silt\", \"sand\")\ngrain_char = sample(grain_order, 36, replace = TRUE)\ngrain_fact = factor(grain_char, levels = grain_order)\ngrain = rast(nrows = 6, ncols = 6, resolution = 0.5, \n             xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n             vals = grain_fact)\nlevels(grain)[[1]] = c(levels(grain)[[1]], wetness = c(\"wet\", \"moist\", \"dry\"))\nlevels(grain)\n#> [[1]]\n#> [1] \"clay\"  \"silt\"  \"sand\"  \"wet\"   \"moist\" \"dry\""},{"path":"attr.html","id":"raster-subsetting","chapter":"3 Attribute data operations","heading":"3.3.1 Raster subsetting","text":"Raster subsetting done base R operator [, accepts variety inputs:\nRow-column indexingCell IDsCoordinates (see Section ??)Another spatial object (see Section ??), show first two options since can considered non-spatial operations.\nneed spatial object subset another output spatial object, refer spatial subsetting.\nTherefore, latter two options shown next chapter (see Section ??).first two subsetting options demonstrated commands —\nreturn value top left pixel raster object elev (results shown):Subsetting multi-layered raster objects return cell value(s) layer.\nexample, c(elev, grain)[1] returns data frame one row two columns — one layer.\nextract values complete rows, can also use values().Cell values can modified overwriting existing values conjunction subsetting operation.\nfollowing code chunk, example, sets upper left cell elev 0 (results shown):Leaving square brackets empty shortcut version values() retrieving values raster.\nMultiple cells can also modified way:Replacing values multilayered rasters can done matrix many columns layers rows replaceable cells (results shown):","code":"\n# row 1, column 1\nelev[1, 1]\n# cell ID 1\nelev[1]\nelev[1, 1] = 0\nelev[]\nelev[1, c(1, 2)] = 0\ntwo_layers = c(grain, elev) \ntwo_layers[1] = cbind(c(0), c(4))\ntwo_layers[]"},{"path":"attr.html","id":"summarizing-raster-objects","chapter":"3 Attribute data operations","heading":"3.3.2 Summarizing raster objects","text":"terra contains functions extracting descriptive statistics entire rasters.\nPrinting raster object console typing name returns minimum maximum values raster.\nsummary() provides common descriptive statistics – minimum, maximum, quartiles number NAs continuous rasters number cells class categorical rasters.\nsummary operations standard deviation (see ) custom summary statistics can calculated global().\nAdditionally, freq() function allows get frequency table categorical values.Raster value statistics can visualized variety ways.\nSpecific functions boxplot(), density(), hist() pairs() work also raster objects, demonstrated histogram created command (shown):case desired visualization function work raster objects, one can extract raster data plotted help values() (Section 3.3.1).\nDescriptive raster statistics belong -called global raster operations.\ntypical raster processing operations part map algebra scheme, covered next chapter (Section ??).\nfunction names clash packages (e.g., function name extract() exist terra tidyr packages). addition loading packages referring functions verbosely (e.g., tidyr::extract()), another way prevent function names clashes unloading offending package detach(). following command, example, unloads terra package (can also done package tab resides default right-bottom pane RStudio): detach(“package:terra,” unload = TRUE, force = TRUE). force argument makes sure package detached even packages depend . , however, may lead restricted usability packages depending detached package, therefore recommended.\n","code":"\nglobal(elev, sd)\nhist(elev)"},{"path":"attr.html","id":"exercises","chapter":"3 Attribute data operations","heading":"3.4 Exercises","text":"exercises use us_states us_states_df datasets spData package.\nmust attached package, packages used attribute operations chapter (sf, dplyr, terra) commands library(spData) attempting exercisesus_states spatial object (class sf), containing geometry attributes (including name, region, area, population) states within contiguous United States.\nus_states_df data frame (class data.frame) containing name additional variables (including median income poverty level, years 2010 2015) US states, including Alaska, Hawaii Puerto Rico.\ndata comes United States Census Bureau, documented ?us_states ?us_states_df.E1. Create new object called us_states_name contains NAME column us_states object using either base R ([) tidyverse (select()) syntax.\nclass new object makes geographic?E2. Select columns us_states object contain population data.\nObtain result using different command (bonus: try find three ways obtaining result).\nHint: try use helper functions, contains starts_with dplyr (see ?contains).E3. Find states following characteristics (bonus find plot ):Belong Midwest region.Belong West region, area 250,000 km2and 2015 population greater 5,000,000 residents (hint: may need use function units::set_units() .numeric()).Belong South region, area larger 150,000 km2 total population 2015 larger 7,000,000 residents.E4. total population 2015 us_states dataset?\nminimum maximum total population 2015?E5. many states region?E6. minimum maximum total population 2015 region?\ntotal population 2015 region?E7. Add variables us_states_df us_states, create new object called us_states_stats.\nfunction use ?\nvariable key datasets?\nclass new object?E8. us_states_df two rows us_states.\ncan find ? (hint: try use dplyr::anti_join() function)E9. population density 2015 state?\npopulation density 2010 state?E10. much population density changed 2010 2015 state?\nCalculate change percentages map .E11. Change columns’ names us_states lowercase. (Hint: helper functions - tolower() colnames() may help.)E12. Using us_states us_states_df create new object called us_states_sel.\nnew object two variables - median_income_15 geometry.\nChange name median_income_15 column Income.E13. Calculate change number residents living poverty level 2010 2015 state. (Hint: See ?us_states_df documentation poverty level columns.)\nBonus: Calculate change percentage residents living poverty level state.E14. minimum, average maximum state’s number people living poverty line 2015 region?\nBonus: region largest increase people living poverty line?E15. Create raster scratch nine rows columns resolution 0.5 decimal degrees (WGS84).\nFill random numbers.\nExtract values four corner cells.E16. common class example raster grain (hint: modal())?E17. Plot histogram boxplot data(dem, package = \"spDataLarge\") raster.","code":""}]
