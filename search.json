[{"path":"index.html","id":"welcome","chapter":"Welcome","heading":"Welcome","text":"online home Geocomputación con R, book geographic data analysis, visualization modeling.Note: first edition book published CRC Press R Series.\ncan buy book CRC Press, Amazon, see archived first edition open source book platform bookdown.org.Inspired bookdown Free Open Source Software Geospatial (FOSS4G) movement, book open source.\nensures contents reproducible publicly accessible people worldwide.online version book hosted geocompr.robinlovelace.net kept --date GitHub Actions, provides information ‘build status’ follows:version book built GH Actions 2021-09-30.","code":""},{"path":"index.html","id":"how-to-contribute","chapter":"Welcome","heading":"How to contribute?","text":"bookdown makes editing book easy editing wiki, provided GitHub account (sign-github.com).\nlogged-GitHub, click ‘Edit page’ icon right panel book website.\ntake editable version source R Markdown file generated page ’re .raise issue book’s content (e.g. code running) make feature request, check-issue tracker.Maintainers contributors must follow repository’s CODE CONDUCT.","code":""},{"path":"index.html","id":"reproducibility","chapter":"Welcome","heading":"Reproducibility","text":"quickest way reproduce contents book ’re new geographic data R may web browser, thanks Binder.\nClicking link open new window containing RStudio Server web browser, enabling open chapter files running code chunks test code reproducible.see something like image , congratulations, ’s worked can start exploring Geocomputación con R cloud-based environment (aware mybinder.org user guidelines):\nFIGURE 0.1: Screenshot reproducible code contained Geocomputación con R running RStudio Server browser served Binder\nreproduce code book computer, need recent version R --date packages.\ncan installed using remotes package.installing book’s dependencies, able reproduce code chunks book’s chapters.\nclone book’s repo navigate geocompr folder, able reproduce contents following command:See project’s GitHub repo details reproducing book.","code":"\ninstall.packages(\"remotes\")\nremotes::install_github(\"geocompr/geocompkg\")\nremotes::install_github(\"nowosad/spData\")\nremotes::install_github(\"nowosad/spDataLarge\")\n\n# During development work on the 2nd edition you may also need dev versions of\n# other packages to build the book, e.g.:\nremotes::install_github(\"rspatial/terra\")\nremotes::install_github(\"mtennekes/tmap\")\nbookdown::serve_book()"},{"path":"index.html","id":"supporting-the-project","chapter":"Welcome","heading":"Supporting the project","text":"find book useful, please support :Telling people personCommunicating book digital media, e.g., via #geocompr hashtag Twitter (see Guestbook geocompr.github.io) letting us know courses using bookCiting linking-‘Starring’ geocompr GitHub repositoryReviewing , e.g., Amazon GoodreadsAsking questions making suggestion content via GitHub Twitter.Buying copyFurther details can found github.com/Robinlovelace/geocompr.work licensed Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.","code":""},{"path":"foreword-1st-edition.html","id":"foreword-1st-edition","chapter":"Foreword (1st Edition)","heading":"Foreword (1st Edition)","text":"‘spatial’ R always broad, seeking provide integrate tools geography, geoinformatics, geocomputation spatial statistics anyone interested joining : joining asking interesting questions, contributing fruitful research questions, writing improving code.\n, ‘spatial’ R always included open source code, open data reproducibility.‘spatial’ R also sought open interaction many branches applied spatial data analysis, also implement new advances data representation methods analysis expose cross-disciplinary scrutiny.\nbook demonstrates, often alternative workflows similar data similar results, may learn comparisons others create understand workflows.\nincludes learning similar communities around Open Source GIS complementary languages Python, Java .R’s wide range spatial capabilities never evolved without people willing share creating adapting.\nmight include teaching materials, software, research practices (reproducible research, open data), combinations .\nR users also benefitted greatly ‘upstream’ open source geo libraries GDAL, GEOS PROJ.book clear example , curious willing join , can find things need match aptitudes.\nadvances data representation workflow alternatives, ever increasing numbers new users often without applied quantitative command-line exposure, book kind really needed.\nDespite effort involved, authors supported pressing forward publication., fresh book ready go; authors tried many tutorials workshops, readers instructors able benefit knowing contents continue tried people like .\nEngage authors wider R-spatial community, see value choice building workflows important, enjoy applying learn things care .Roger BivandBergen, September 2018","code":""},{"path":"preface.html","id":"preface","chapter":"Preface","heading":"Preface","text":"","code":""},{"path":"preface.html","id":"who-this-book-is-for","chapter":"Preface","heading":"Who this book is for","text":"book people want analyze, visualize model geographic data open source software.\nbased R, statistical programming language powerful data processing, visualization geospatial capabilities.\nbook covers wide range topics interest wide range people many different backgrounds, especially:People learned spatial analysis skills using desktop Geographic Information System (GIS), QGIS, ArcGIS, GRASS SAGA, want access powerful (geo)statistical visualization programming language benefits command-line approach (Sherman 2008):\n\nadvent ‘modern’ GIS software, people want point click way life. ’s good, tremendous amount flexibility power waiting command line.\nPeople learned spatial analysis skills using desktop Geographic Information System (GIS), QGIS, ArcGIS, GRASS SAGA, want access powerful (geo)statistical visualization programming language benefits command-line approach (Sherman 2008):advent ‘modern’ GIS software, people want point click way life. ’s good, tremendous amount flexibility power waiting command line.Graduate students researchers fields specializing geographic data including Geography, Remote Sensing, Planning, GIS Geographic Data ScienceGraduate students researchers fields specializing geographic data including Geography, Remote Sensing, Planning, GIS Geographic Data ScienceAcademics post-graduate students working geographic data — fields Geology, Regional Science, Biology Ecology, Agricultural Sciences, Archaeology, Epidemiology, Transport Modeling, broadly defined Data Science — require power flexibility R researchAcademics post-graduate students working geographic data — fields Geology, Regional Science, Biology Ecology, Agricultural Sciences, Archaeology, Epidemiology, Transport Modeling, broadly defined Data Science — require power flexibility R researchApplied researchers analysts public, private third-sector organizations need reproducibility, speed flexibility command-line language R applications dealing spatial data diverse Urban Transport Planning, Logistics, Geo-marketing (store location analysis) Emergency PlanningApplied researchers analysts public, private third-sector organizations need reproducibility, speed flexibility command-line language R applications dealing spatial data diverse Urban Transport Planning, Logistics, Geo-marketing (store location analysis) Emergency PlanningThe book designed intermediate--advanced R users interested geocomputation R beginners prior experience geographic data.\nnew R geographic data, discouraged: provide links materials describe nature spatial data beginner’s perspective Chapter 2 links provided .","code":""},{"path":"preface.html","id":"how-to-read-this-book","chapter":"Preface","heading":"How to read this book","text":"book divided three parts:Part : Foundations, aimed getting --speed geographic data R.Part II: Extensions, covers advanced techniques.Part III: Applications, real-world problems.chapters get progressively harder recommend reading book order.\nmajor barrier geographical analysis R steep learning curve.\nchapters Part aim address providing reproducible code simple datasets ease process getting started.important aspect book teaching/learning perspective exercises end chapter.\nCompleting develop skills equip confidence needed tackle range geospatial problems.\nSolutions exercises, number extended examples, provided book’s supporting website, geocompr.github.io.Impatient readers welcome dive straight practical examples, starting Chapter 2.\nHowever, recommend reading wider context Geocomputación con R Chapter 1 first.\nnew R, also recommend learning language attempting run code chunks provided chapter (unless ’re reading book understanding concepts).\nFortunately R beginners R supportive community developed wealth resources can help.\nparticularly recommend three tutorials: R Data Science (Grolemund Wickham 2016) Efficient R Programming (Gillespie Lovelace 2016), especially Chapter 2 (installing setting-R/RStudio) Chapter 10 (learning learn), introduction R (Venables, Smith, Team 2017).","code":""},{"path":"preface.html","id":"why-r","chapter":"Preface","heading":"Why R?","text":"Although R steep learning curve, command-line approach advocated book can quickly pay .\n’ll learn subsequent chapters, R effective tool tackling wide range geographic data challenges.\nexpect , practice, R become program choice geospatial toolbox many applications.\nTyping executing commands command-line , many cases, faster pointing--clicking around graphical user interface (GUI) desktop GIS.\napplications Spatial Statistics modeling R may realistic way get work done.outlined Section ??, many reasons using R geocomputation:\nR well-suited interactive use required many geographic data analysis workflows compared languages.\nR excels rapidly growing fields Data Science (includes data carpentry, statistical learning techniques data visualization) Big Data (via efficient interfaces databases distributed computing systems).\nFurthermore R enables reproducible workflow: sharing scripts underlying analysis allow others build-work.\nensure reproducibility book made source code available github.com/Robinlovelace/geocompr.\nfind script files code/ folder generate figures:\ncode generating figure provided main text book, name script file generated provided caption (see example caption Figure ??).languages Python, Java C++ can used geocomputation excellent resources learning geocomputation without R, discussed Section ??.\nNone provide unique combination package ecosystem, statistical capabilities, visualization options, powerful IDEs offered R community.\nFurthermore, teaching use one language (R) depth, book equip concepts confidence needed geocomputation languages.","code":""},{"path":"preface.html","id":"real-world-impact","chapter":"Preface","heading":"Real-world impact","text":"Geocomputación con R equip knowledge skills tackle wide range issues, including scientific, societal environmental implications, manifested geographic data.\ndescribed Section ??, geocomputation using computers process geographic data:\nalso real-world impact.\ninterested wider context motivations behind book, read ; covered Chapter 1.","code":""},{"path":"preface.html","id":"acknowledgements","chapter":"Preface","heading":"Acknowledgements","text":"Many thanks everyone contributed directly indirectly via code hosting collaboration site GitHub, including following people contributed direct via pull requests: prosoitos, florisvdh, katygregg, rsbivand, KiranmayiV, zmbc, erstearns, MikeJohnPage, eyesofbambi, nickbearman, tyluRp, marcosci, giocomai, KHwong12, LaurieLBaker, MarHer90, mdsumner, pat-s, gisma, ateucher, annakrystalli, DarrellCarvalho, kant, gavinsimpson, Henrik-P, Himanshuteli, yutannihilation, jbixon13, yvkschaefer, katiejolly, layik, mpaulacaldas, mtennekes, mvl22, ganes1410, richfitz, wdearden, yihui, chihinl, cshancock, gregor-d, jasongrahn, p-kono, pokyah, schuetzingit, sdesabbata, tim-salabim, tszberkowitz.\nSpecial thanks Marco Sciaini, created front cover image, also published code generated (see code/frontcover.R book’s GitHub repo).\nDozens people contributed online, raising commenting issues, providing feedback via social media.\n#geocompr hashtag live !like thank John Kimmel CRC Press, worked us two years take ideas early book plan production via four rounds peer review.\nreviewers deserve special mention : detailed feedback expertise substantially improved book’s structure content.thank Patrick Schratz Alexander Brenning University Jena fruitful discussions input Chapters ?? ??.\nthank Emmanuel Blondel Food Agriculture Organization United Nations expert input section web services;\nMichael Sumner critical input many areas book, especially discussion algorithms Chapter 10;\nTim Appelhans David Cooley key contributions visualization chapter (Chapter 8);\nKaty Gregg, proofread every chapter greatly improved readability book.Countless others mentioned contributed myriad ways.\nfinal thank software developers make Geocomputación con R possible.\nEdzer Pebesma (created sf package), Robert Hijmans (created raster) Roger Bivand (laid foundations much R-spatial software) made high performance geographic computing possible R.","code":""},{"path":"intro.html","id":"intro","chapter":"1 Introducción","heading":"1 Introducción","text":"Este libro trata de utilizar el poder de los ordenadores para hacer cosas con los datos geográficos.\nEnseña una serie de habilidades espaciales, entre las que se incluyen: la lectura, escritura y manipulación de datos geográficos; la elaboración de mapas estáticos e interactivos; la aplicación de la geocomputación para resolver problemas del mundo real; y la modelización de fenómenos geográficos.\nAl demostrar cómo se pueden enlazar varias operaciones geográficas, en “trozos de código” reproducibles que intercalan la prosa, el libro también enseña un flujo de trabajo transparente y, por tanto, científico.\nAprender utilizar la gran cantidad de herramientas geoespaciales disponibles en la línea de comandos de R puede ser emocionante, pero crear otras nuevas puede ser realmente liberador.\nEl uso del enfoque basado en la línea de comandos que se enseña lo largo del libro, y las técnicas de programación que se tratan en el capítulo ??, pueden ayudar eliminar las restricciones tu creatividad impuestas por el software.\nPor lo tanto, después de leer el libro y completar los ejercicios, deberías sentirte capacitado con una sólida comprensión de las posibilidades abiertas por las impresionantes capacidades geográficas de R, nuevas habilidades para resolver problemas del mundo real con datos geográficos, y la capacidad de comunicar tu trabajo con mapas y código reproducible.En las últimas décadas, el software libre y de código abierto dedicado al ámbito geoespacial (FOSS4G) ha progresado un ritmo asombroso.\nGracias organizaciones como OSGeo, el análisis de datos geográficos ha dejado de ser algo exclusivo de quienes disponen de caros hardware y software: ahora cualquiera puede descargar y ejecutar bibliotecas espaciales de alto rendimiento.\nLos Sistemas de Información Geográfica (SIG, o GIS en inglés) de código abierto, como QGIS, han hecho accesible el análisis geográfico en todo el mundo. Los programas SIG tienden enfatizar las interfaces gráficas para el usuario (GUIs), con la consecuencia deseada de desalentar la reproducibilidad (aunque muchos pueden utilizarse desde la línea de comandos, como veremos en el capítulo ??).\nR, por el contrario, hace énfasis en la interfaz de la línea de comandos (CLI). Una comparación simplista entre los diferentes enfoques se ilustra en la Tabla 1.1.TABLE 1.1: Diferencias de énfasis entre los paquetes software (Interfaz gráfica del usuario (Graphical User Interface, GUI en inglés) de los Sistemas de Información Geográfica (GIS) y R).Este libro está motivado por la importancia de la reproducibilidad para la investigación científica (véase la nota inferior).\nSu objetivo es hacer más accesibles los flujos de trabajo de los análisis de datos geográficos reproducibles, y demostrar el poder del software geoespacial abierto disponible desde la línea de comandos.\n“Las interfaces para otros software forman parte de R” (Eddelbuettel Balamuta 2018).\nEsto significa que, además de las destacadas capacidades “internas”, R permite el acceso muchas otras bibliotecas de software espacial, explicadas en la sección ?? y demostradas en el capítulo ??.\nSin embargo, antes de entrar en los detalles del software, vale la pena dar un paso atrás y pensar en lo que entendemos por geocomputación.La reproducibilidad es una de las principales ventajas de las interfaces de línea de comandos, pero ¿qué significa en la práctica?\nLa definimos del siguiente modo:“Un proceso en el que los mismos resultados pueden ser generados por otros utilizando un código públicamente accesible”.","code":""},{"path":"intro.html","id":"qué-es-la-geocomputación","chapter":"1 Introducción","heading":"1.1 ¿Qué es la geocomputación?","text":"‘Geocomputación’ es un término joven, que se remonta la primera conferencia sobre el tema en 1996.1Lo que distingue la geocomputación del término comúnmente utilizado (en aquel momento) “geografía cuantitativa”, según propusieron sus primeros defensores, es su énfasis en las aplicaciones “creativas y experimentales” (Longley et al. 1998) y en el desarrollo de nuevas herramientas y métodos (Openshaw Abrahart 2000):\n“La geocomputación consiste en utilizar los distintos tipos de geodatos y en desarrollar geoherramientas relevantes dentro del contexto general de un enfoque ‘científico’”.\nEste libro pretende ir más allá de la enseñanza de los métodos y el código; al final de él, deberías ser capaz de utilizar tus conocimientos de geocomputación para realizar “un trabajo práctico que sea beneficioso o útil” (Openshaw Abrahart 2000).Sin embargo, nuestro enfoque difiere de los primeros en adoptarlo, como Stan Openshaw, en su énfasis en la reproducibilidad y la colaboración.\nprincipios del siglo XXI, era realista esperar que los lectores pudieran reproducir los ejemplos de código, debido las barreras que impedían el acceso al hardware, el software y los datos necesarios.\nSi avanzamos dos décadas, las cosas han progresado rápidamente.\nCualquiera que tenga acceso un ordenador portátil con aproximadamente 4 GB de RAM puede esperar de forma realista poder instalar y ejecutar software de geocomputación sobre conjuntos de datos de acceso público, que están más disponibles que nunca (como veremos en el capítulo ??).2\ndiferencia de los primeros trabajos en este campo, todo el trabajo presentado en este libro es reproducible utilizando el código y los datos de ejemplo proporcionados junto con el libro, en paquetes de R como spData, cuya instalación se trata en el capítulo 2.La geocomputación está estrechamente relacionada con otros términos como: Ciencia de la Información Geográfica (GIScience); Geomática; Geoinformática; Ciencia de la Información Espacial; Ingeniería de la Geoinformación (Longley 2015); y Ciencia de los Datos Geográficos (GDS).\nTodos los términos comparten el énfasis en un enfoque “científico” (que implica que es reproducible y falsable) influenciado por los SIG, aunque sus orígenes y principales campos de aplicación difieren.\nLa GDS, por ejemplo, enfatiza las habilidades de la “ciencia de datos” y los grandes conjuntos de datos, mientras que la Geoinformática tiende centrarse en las estructuras de datos.\nPero los solapamientos entre los términos son mayores que las diferencias entre ellos y utilizamos la geocomputación como un sinónimo aproximado que los engloba todos:\ntodos tratan de utilizar los datos geográficos para el trabajo científico aplicado.\nSin embargo, diferencia de los primeros usuarios del término, pretendemos dar entender que existe un campo académico cohesionado llamado “Geocomputación” (o “GeoComputación”, como lo llamaba Stan Openshaw).\nEn cambio, definimos el término de la siguiente manera: trabajar con datos geográficos de forma computacional, centrándose en el código, la reproducibilidad y la modularidad.La geocomputación es un término reciente pero está influenciado por ideas antiguas.\nPuede considerarse parte de la Geografía, la cual tiene más de 2000 años de historia (Talbert 2014); y una extensión de los Sistemas de Información Geográfica (SIG) (Neteler Mitasova 2008), los cuales surgieron en la década de 1960 (Coppock Rhind 1991).Sin embargo, la geografía ha desempeñado un papel importante la hora de explicar e influir la relación de la humanidad con el mundo natural mucho antes de la invención del ordenador.\nLos viajes de Alexander von Humboldt Sudamérica principios del siglo XIX ilustran este papel:\nlas observaciones resultantes solo sentaron las bases de las tradiciones de la geografía física y vegetal, sino que también allanaron el camino hacia las políticas de protección del mundo natural (Wulf 2015).\nEste libro pretende contribuir la “Tradición Geográfica” (Livingstone 1992) aprovechando la potencia de los ordenadores modernos y el software de código abierto.Los vínculos del libro con disciplinas más antiguas se reflejaron en los títulos sugeridos para el libro: Geografía con R y R para SIG.\nCada uno tiene sus ventajas.\nEl primero transmite el mensaje de que comprende mucho más que datos espaciales:\nlos datos de atributos espaciales se entremezclan inevitablemente con los datos geométricos, y la Geografía trata de algo más que de dónde está algo en el mapa.\nEl segundo comunica que este un libro sobre el uso de R como un SIG, para realizar operaciones espaciales sobre datos geográficos (Bivand, Pebesma, Gómez-Rubio 2013).\nSin embargo, el término SIG transmite algunas connotaciones (véase la Tabla 1.1) que simplemente comunican una de las mayores fortalezas de R:\nsu capacidad basada en la consola para cambiar sin problemas entre las tareas de procesamiento, modelado y visualización de datos geográficos y geográficos.\nPor el contrario, el término geocomputación implica una programación reproducible y creativa.\nPor supuesto, los algoritmos (geocomputacionales) son herramientas poderosas que pueden llegar ser altamente complejas.\nSin embargo, todos los algoritmos se componen de partes más pequeñas.\nAl enseñarte sus fundamentos y su estructura subyacente, pretendemos capacitarte para crear tus propias soluciones innovadoras los problemas de datos geográficos.","code":""},{"path":"intro.html","id":"por-qué-usar-r-para-la-geocomputación","chapter":"1 Introducción","heading":"1.2 ¿Por qué usar R para la geocomputación?","text":"Los primeros geógrafos utilizaron diversas herramientas, como barómetros, brújulas y sextantes, para avanzar en el conocimiento del mundo (Wulf 2015). Solo con la invención del cronómetro marino en 1761 fue posible calcular la longitud en el mar, lo que permitió los barcos tomar rutas más directas.Hoy en día es difícil imaginar tal falta de datos geográficos.\nTodos los teléfonos inteligentes tienen un receptor de posicionamiento global (GPS) y una multitud de sensores en dispositivos que van desde satélites y vehículos semiautónomos hasta científicos ciudadanos que miden incesantemente cada parte del mundo.\nEl ritmo de producción de datos es abrumador.\nUn vehículo autónomo, por ejemplo, puede generar 100 GB de datos al día (Economist 2016).\nLos datos de teledetección de los satélites se han vuelto demasiado grandes para analizar los datos correspondientes con un solo ordenador, lo que ha dado lugar iniciativas como OpenEO.Esta “revolución de los geodatos” impulsa la demanda de equipos informáticos de alto rendimiento y de software eficientes y escalables para manejar y extraer la señal del ruido, con el fin de comprender y quizás cambiar el mundo.\nLas bases de datos espaciales permiten almacenar y generar subconjuntos manejables de los vastos almacenes de datos geográficos, haciendo que las interfaces para obtener conocimientos de ellos sean herramientas vitales para el futuro.\nR es una de esas herramientas, con capacidades avanzadas de análisis, modelización y visualización.\nEn este contexto, el libro se centra en el lenguaje en sí (véase Wickham 2014).\nEn su lugar, utilizamos R como una “herramienta para trabajar” para entender el mundo, de forma similar al uso que Humboldt hizo de las herramientas para obtener una comprensión profunda de la naturaleza en toda su complejidad e interconexiones (véase Wulf 2015).\nAunque la programación puede parecer una actividad reduccionista, el objetivo es enseñar geocomputación con R solo por diversión, sino para entender el mundo.R es un lenguaje y entorno de código abierto y multiplataforma para la computación estadística y los gráficos (r-project.org/).\nCon una amplia gama de paquetes, R también permite la estadística geoespacial avanzada, la modelización y la visualización.\n\nLos nuevos entornos de desarrollo integrados (IDE), como RStudio, han hecho que R sea más fácil de usar para muchos, facilitando la elaboración de mapas con un panel dedicado la visualización interactiva.En su esencia, R es un lenguaje de programación funcional orientado objetos (Wickham 2014), y fue diseñado específicamente como una interfaz interactiva para otro software (Chambers 2016).\nEste último también incluye muchos “puentes” hacia el hallazgo de un tesoro del software SIG, “geolibrerías” y funciones (véase el capítulo ??).\nPor tanto, es ideal para crear rápidamente “geoherramientas”, sin necesidad de dominar lenguajes de nivel inferior (en comparación con R) como C, FORTRAN o Java (véase la sección ??).\n\nEsto puede ser como liberarse del metafórico “techo de cristal” impuesto por los sistemas de información geográfica basados en GUI o patentados (véase la Tabla 1.1 para una definición de GUI).\nAdemás, R facilita el acceso otros lenguajes:\nlos paquetes Rcpp y reticulate permiten acceder código de C++ y Python, por ejemplo.\nEsto significa que R puede utilizarse como “puente” hacia una amplia gama de programas geoespaciales (véase la sección ??).Otro ejemplo que muestra la flexibilidad y la evolución de las capacidades geográficas de R es la elaboración de mapas interactivos.\nComo veremos en el Capítulo ??, la afirmación de que R tiene “facilidades interactivas [para elaborar gráficos] limitadas” (Bivand, Pebesma, Gómez-Rubio 2013) ya es cierta.\nAsí lo demuestra el siguiente fragmento de código, que crea la Figura 1.1 (las funciones que generan el gráfico se tratan en la Sección ??).\nFIGURE 1.1: Los marcadores azules indican la procedencia de los autores. El mapa base es una imagen en mosaico de la Tierra de noche proporcionada por la NASA. Interactúa con la versión en línea en geocompr.robinlovelace.net, por ejemplo, ampliando la imagen y haciendo clic en las ventanas emergentes.\nHace unos años habría sido difícil elaborar la Figura 1.1 con R, más aún en forma de mapa interactivo.\nEsto ilustra la flexibilidad de R y cómo, gracias desarrollos como knitr y leaflet, puede utilizarse como interfaz con otro software, un tema que se repetirá lo largo de este libro.\nEl uso del código de R, por tanto, permite enseñar geocomputación con referencia ejemplos reproducibles como el proporcionado en la Figura 1.1 en lugar de conceptos abstractos.","code":"\nlibrary(leaflet)\npopup = c(\"Robin\", \"Jakub\", \"Jannes\", \"Mireia\")\nleaflet() %>%\n  addProviderTiles(\"NASAGIBS.ViirsEarthAtNight2012\") %>%\n  addMarkers(c(-3, 23, 11, 2), c(52, 53, 49, 42), popup = popup)"},{"path":"intro.html","id":"software-para-geocomputación","chapter":"1 Introducción","heading":"1.3 Software para geocomputación","text":"R es un poderoso lenguaje para la geocomputación, pero hay muchas otras opciones para el análisis de datos geográficos que ofrecen miles de funciones geográficas.\nEl conocimiento de otros lenguajes para la geocomputación ayudará decidir cuándo una herramienta diferente puede ser más apropiada para una tarea específica, y situar R en el amplio ecosistema geoespacial.\nEsta sección presenta brevemente los lenguajes C++, Java y Python para la geocomputación, como preparación para el capítulo ??.Una importante característica de R (y de Python) es que es un lenguaje interpretado.\nEsto es ventajoso porque permite la programación interactiva en un bucle de lectura-evaluación-impresión (REPL):\nel código introducido en la consola se ejecuta inmediatamente y el resultado se imprime, en lugar de esperar la etapa intermedia de compilación. Por otra parte, los lenguajes compilados, como C++ y Java, tienden ejecutarse más rápidamente (una vez que han sido compilados).C++ proporciona la base de muchos paquetes SIG, como QGIS, GRASS y SAGA, por lo que es un punto de partida apropiado.\nEl C++ bien escrito es muy rápido, lo que lo convierte en una buena opción para aplicaciones de rendimiento crítico, como el procesamiento de grandes conjuntos de datos geográficos, pero es más difícil de aprender que Python o R.\nEl C++ se ha vuelto más accesible con el paquete Rcpp, el cual proporciona una buena \" vía de entrada \" la programación en C para los usuarios de R.\nEl dominio de estos lenguajes de bajo nivel abre la posibilidad de crear nuevos “geoalgoritmos” de alto rendimiento y de comprender mejor el funcionamiento del software SIG (véase el capítulo ??).Java es otro lenguaje importante y versátil para la geocomputación.\nLos paquetes de SIG gvSig, OpenJump y uDig están escritos en Java.\nHay muchas bibliotecas de SIG escritas en Java, como GeoTools y JTS, la Topología Suite de Java (GEOS es un puerto C++ de JTS).\nAdemás, muchas aplicaciones de servidores de mapas utilizan Java, como Geoserver/Geonode, deegree y 52°North WPS.La sintaxis orientada objetos de Java es similar la de C++.\nUna de las principales ventajas de Java es que es independiente de las plataformas (lo que es inusual para un lenguaje compilado) y es altamente escalable, lo cual lo convierte en un lenguaje adecuado para IDEs como RStudio, con el cual se ha escrito este libro.\nJava tiene menos herramientas para el modelado estadístico y la visualización que Python o R, aunque puede utilizarse para la ciencia de datos (Brzustowicz 2017).Python es un lenguaje importante para la geocomputación, especialmente porque muchos SIG de escritorio, como GRASS, SAGA y QGIS, proporcionan una API de Python (véase el capítulo ??).\nAl igual que R, es una herramienta popular para la ciencia de los datos.\nAmbos lenguajes están orientados objetos y tienen muchas áreas de solapamiento, lo cual ha llevado iniciativas como el paquete reticulate, que facilita el acceso Python desde R, y la iniciativa de Ursa Labs para apoyar las bibliotecas portátiles en beneficio de todo el ecosistema de ciencia de datos de código abierto.En la práctica, tanto R como Python tienen sus puntos fuertes y, hasta cierto punto, cuál de ellos se utiliza es menos importante que el ámbito de aplicación y la comunicación de los resultados.\nEl aprendizaje de cualquiera de los dos permite empezar aprender el otro.\nSin embargo, R tiene grandes ventajas sobre Python para la geocomputación.\nEntre ellas se encuentra el hecho de que soporta mucho mejor los modelos de datos geográficos vectoriales y rasterizados en el propio lenguaje (véase el capítulo 2) y las correspondientes posibilidades de visualización (véanse los capítulos 2 y ??).\nIgualmente importante es el hecho de que R tiene un soporte incomparable para la estadística, incluida la estadística espacial, con cientos de paquetes (diferencia de Python) que soportan miles de métodos estadísticos.La mayor ventaja de Python es que es un lenguaje de programación de propósito general.\nSe utiliza en muchos ámbitos, como el software de escritorio, los juegos de ordenador, los sitios web y la ‘ciencia de los datos’.\nPython es menudo el único lenguaje compartido entre diferentes comunidades (de geocomputación) y puede considerarse como el “pegamento” que mantiene unidos muchos programas de SIG.\nSe puede acceder muchos geoalgoritmos, incluidos los de QGIS y ArcMap, desde la línea de comandos de Python, lo que lo convierte en un lenguaje idóneo para iniciarse en los SIG de línea de comandos.^[Los módulos de Python que proporcionan acceso los geoalgoritmos incluyen grass.script para GRASS,\nsaga-python para SAGA-GIS,\nprocessing para QGIS y arcpy para ArcGIS.\n]Sin embargo, para la estadística espacial y el modelado predictivo, R es considerablemente mejor.\nEsto significa que haya que elegir entre R o Python: Python soporta la mayoría de las técnicas estadísticas comunes (aunque R tiende soportar antes los nuevos desarrollos en estadística espacial) y muchos conceptos aprendidos en Python pueden aplicarse al mundo de R.\nAl igual que R, Python también soporta el análisis y la manipulación de datos geográficos con paquetes como osgeo, Shapely, NumPy y PyGeoProcessing (Garrard 2016).","code":""},{"path":"intro.html","id":"el-ecosistema-espacial-de-r","chapter":"1 Introducción","heading":"1.4 El ecosistema espacial de R","text":"Hay muchas maneras de manejar datos geográficos en R, con docenas de paquetes en el área.3\nEn este libro nos esforzamos por enseñar el estado del arte en el campo, al tiempo que nos aseguramos de que los métodos estén preparados para el futuro.\nAl igual que muchas áreas de desarrollo de software, el ecosistema espacial de R está evolucionando rápidamente (Figura 1.2).\nPuesto que R es de código abierto, estos desarrollos pueden construirse fácilmente partir de trabajos anteriores, “subiendo hombros de gigantes”, como dijo Isaac Newton en 1675.\nEste enfoque es ventajoso porque fomenta la colaboración y evita “reinventar la rueda”.\nEl paquete sf (tratado en el capítulo 2), por ejemplo, se basa en su predecesor sp.El aumento del tiempo de desarrollo (y del interés) en ‘R-spatial’ se ha producido tras la concesión de una subvención por parte del R Consortium para el desarrollo del soporte para Funciones Simples, un estándar y modelo de código abierto para almacenar y acceder geometrías vectoriales.\nEsto dio lugar al paquete sf (tratado en la sección 2.2.1).\nMúltiples sitios reflejan el inmenso interés por sf.\nEsto es especialmente cierto en el caso de los archivos de R-sig-Geo Archives, una lista de correos electrónicos en abierto que contiene mucha sabiduría de R-spatial acumulada lo largo de los años.\nFIGURE 1.2: La popularidad de los paquetes espaciales en R. El eje Y muestra el número medio de descargas por día, dentro de una ventana móvil de 30 días, de paquetes espaciales destacados.\nCabe destacar que los cambios en la comunidad de R en general, como por ejemplo el paquete de procesamiento de datos dplyr (publicado en 2014), han influido en los cambios del ecosistema espacial de R.\nJunto con otros paquetes que tienen un estilo compartido y un énfasis en los “datos ordenados” (“tidy data”) (incluyendo, por ejemplo, ggplot2), dplyr se colocó en el “metapaquete” tidyverse finales de 2016.El enfoque de tidyverse, centrado en los datos de forma larga y en las funciones rápidas de nombre intuitivo, se ha hecho inmensamente popular.\nEsto ha dado lugar una demanda de “datos geográficos ordenados” que ha sido satisfecha en parte por sf y otros enfoques como tabularaster.\nUna característica evidente del tidyverse es la tendencia que los paquetes trabajen en armonía.\nexiste un ‘geoverso’ equivalente, pero hay intentos de armonización entre los paquetes alojados en la organización r-spatial y el número creciente de paquetes que utilizan sf (Tabla 1.2).TABLE 1.2: Los 5 paquetes más descargados que dependen de sf, en términos de número medio de descargas por día durante el mes anterior. partir del 2021-08-22 hay 383 paquetes que importan sf.","code":""},{"path":"intro.html","id":"la-historia-de-r-spatial","chapter":"1 Introducción","heading":"1.5 La historia de R-spatial","text":"El uso de paquetes espaciales recientes como sf tiene muchas ventajas, pero también es importante ser consciente de la historia de las capacidades espaciales de R: muchas funciones, casos de uso y material didáctico están contenidos en paquetes más antiguos.\nEstos pueden seguir siendo útiles hoy en día, siempre que se sepa dónde buscar.\n\nLas capacidades espaciales de R se originaron en los primeros paquetes espaciales del lenguaje S (Bivand Gebhardt 2000).\n\nEn la década de 1990 se desarrollaron numerosos scripts en S y un puñado de paquetes para la estadística espacial.\nLos paquetes de R surgieron partir de ellos y en el año 2000 había paquetes de R para varios métodos espaciales “análisis de patrones puntuales, geoestadística, análisis exploratorio de datos espaciales y econometría espacial”, según un artículo presentado en GeoComputation 2000 (Bivand Neteler 2000).\nAlgunos de ellos, especialmente spatial, sgeostat y splancs, siguen estando disponibles en CRAN (Rowlingson Diggle 1993, 2017; Venables Ripley 2002; Majure Gebhardt 2016).Un artículo posterior en R News (el predecesor de R Journal) contenía una visión general del software estadístico espacial en R en ese momento, gran parte del cual se basaba en código anterior escrito para S/S-PLUS (Ripley 2001).\nEsta visión general describía paquetes para el suavizado y la interpolación espacial, incluyendo akima y geoR (Akima Gebhardt 2016; Jr Diggle 2016), y el análisis de patrones de puntos, incluyendo splancs (Rowlingson Diggle 2017) y spatstat (Baddeley, Rubak, Turner 2015).La siguiente publicación de R News (Volumen 1/3) volvió poner los paquetes espaciales en el punto de mira, con una introducción más detallada splancs y un comentario sobre las perspectivas futuras de la estadística espacial (Bivand 2001).\nAdemás, la publicación introdujo dos paquetes para probar la autocorrelación espacial que finalmente se convirtieron en parte de spdep (Bivand 2017).\nEn particular, el comentario menciona la necesidad de estandarizar las interfaces espaciales, los mecanismos eficientes para el intercambio de datos con SIG y el manejo de metadatos espaciales como los sistemas de referencia de coordenadas (CRS).maptools (escrito por Nicholas Lewin-Koh; Bivand Lewin-Koh 2017) es otro paquete importante de esta época.\nInicialmente, maptools solo contenía una envoltura alrededor de shapelib y permitía la lectura de ESRI Shapefiles en listas anidadas de geometría.\nLa clase S3 correspondiente y hoy en día obsoleta llamada “Map” almacenaba esta lista junto un dataframe de atributos.\nEl trabajo sobre la representación de la clase “Map” fue, sin embargo, importante, ya que alimentó directamente sp antes de su publicación en CRAN.En 2003, Roger Bivand publicó una revisión extendida de los paquetes espaciales.\nPropuso un sistema de clases para soportar los “objetos de datos ofrecidos por GDAL”, incluyendo los tipos ‘fundamentales’ punto, línea, polígono y raster.\nAdemás, sugería que las interfaces con bibliotecas externas debían ser la base de los paquetes modulares de R (Bivand 2003).\nEn gran medida, estas ideas se materializaron en los paquetes rgdal y sp.\nEstos proporcionaron una base para el análisis de datos espaciales con R, tal como se describe en Análisis de datos espaciales aplicados con R (Applied Spatial Data Analysis R en inglés) (ASDAR) (Bivand, Pebesma, Gómez-Rubio 2013), publicado por primera vez en 2008.\nDiez años más tarde, las capacidades espaciales de R han evolucionado sustancialmente, pero siguen basándose en las ideas expuestas por Bivand (2003):\nlas interfaces para GDAL y PROJ, por ejemplo, siguen potenciando las capacidades de /O de datos geográficos de alto rendimiento y de transformación de CRS (véanse los capítulos ?? y ??, respectivamente).rgdal, publicado en 2003, proporcionó vínculos GDAL para R que mejoraron en gran medida su capacidad para importar datos de formatos de datos geográficos que antes estaban disponibles.\nLa versión inicial sólo admitía controladores raster, pero las mejoras posteriores proporcionaron soporte para sistemas de referencia de coordenadas (través de la librería PROJ), reproyecciones e importación de formatos de archivos vectoriales (véase el capítulo ?? para más información sobre los formatos de archivo).\nMuchas de estas capacidades adicionales fueron desarrolladas por Barry Rowlingson y publicadas en el código base de rgdal en 2006 (véase Rowlingson et al. 2003 y R-help(véase Rowlingson et al. 2003 y la lista de correos electrónicos de R-help para el contexto).sp, publicado en 2005, superó la incapacidad de R para distinguir entre los objetos espaciales y los espaciales (Pebesma Bivand 2005).\nsp surgió de un taller celebrado en Viena en 2003 y estuvo alojado en sourceforge antes de migrar R-Forge.\n\n\nAntes de 2005, las coordenadas geográficas se trataban generalmente como cualquier otro número.\nsp cambió esto con sus clases y métodos genéricos que soportan puntos, líneas, polígonos y cuadrículas, y datos de atributos.sp almacena información como el cuadro delimitador, el sistema de referencia de coordenadas y los atributos en ranuras de objetos espaciales que utilizan el sistema de clases S4, lo que permite que las operaciones de datos funcionen con datos geográficos (véase la sección ??).\nAdemás, sp proporciona métodos genéricos como summary() y plot() para datos geográficos.\nEn la década siguiente, las clases sp se popularizaron rápidamente para los datos geográficos en R y el número de paquetes que dependían de él se incrementó de unos 20 en 2008 más de 100 en 2013 (Bivand, Pebesma, Gómez-Rubio 2013).En 2018, casi 500 paquetes dependen de sp, lo que lo convierte en una parte importante del ecosistema de R.\nEntre los paquetes R más destacados que utilizan sp se encuentran: gstat, para geoestadística espacial y espacio-temporal; geosphere, para trigonometría esférica; y adehabitat, utilizado para el análisis de la selección de hábitat por parte de los animales (E. Pebesma Graeler 2018; Calenge 2006; Hijmans 2016).Mientras que rgdal y sp resolvían muchos problemas espaciales, R seguía careciendo de la capacidad de realizar operaciones geométricas (véase el capítulo ??).\nColin Rundel abordó este problema desarrollando rgeos, una interfaz de R para la librería de geometría en código abierto (GEOS) durante un proyecto de Google Summer Code en 2010 (Bivand Rundel 2018).\nrgeos permitió GEOS manipular objetos sp, con funciones como gIntersection().Otra limitación de sp — su limitado apoyo los datos raster — fue superada por raster, publicado por primera vez en 2010 (Hijmans 2017).\nSu sistema de clases y sus funciones soportan una serie de operaciones de rasterización, como se indica en la sección ??.\nUna característica clave de raster es su capacidad para trabajar con conjuntos de datos que son demasiado grandes para caber en la memoria RAM (la interfaz de R con PostGIS admite operaciones fuera del disco sobre datos geográficos vectoriales).\nraster también admite el álgebra de mapas (véase la sección ??).Paralelamente estos desarrollos de sistemas de clases y métodos, llegó el apoyo R como interfaz para el software SIG dedicado.\nGRASS (R. S. Bivand 2000) y los paquetes posteriores spgrass6 y rgrass7 (para GRASS GIS 6 y 7, respectivamente) fueron ejemplos destacados en esta dirección (Bivand 2016a, 2016b).\nOtros ejemplos de puentes entre R y SIG son RSAGA (Brenning, Bangs, Becker 2018, publicado por primera vez en 2008), RPyGeo (Brenning 2012, publicado por primera vez en 2008) y RQGIS (Muenchow, Schratz, Brenning 2017, publicado por primera vez en 2016) (véase el capítulo ??).La visualización fue un foco de atención al principio, ya que la mayor parte del desarrollo de R-spatial se centró en el análisis y las operaciones geográficas.\nsp proporcionó métodos para la elaboración de mapas utilizando el sistema de graficación de base y de lattice, pero la demanda estaba creciendo para las capacidades de elaboración de mapas avanzados, especialmente después del lanzamiento de ggplot2 en 2007.\nggmap amplió las capacidades espaciales de ggplot2 (Kahle Wickham 2013), facilitando el acceso los segmentos del “basemap” desde servicios en línea como Google Maps.\nAunque ggmap facilitaba la elaboración de mapas con ggplot2, su utilidad estaba limitada por la necesidad de fortificar los objetos espaciales, lo que significa convertirlos en largos dataframes.\nAunque esto funciona bien para los puntos, es computacionalmente ineficiente para las líneas y los polígonos, ya que cada coordenada (vértice) se convierte en una fila, lo que da lugar enormes dataframes para representar geometrías complejas.\nAunque la visualización geográfica tendía centrarse en los datos vectoriales, la visualización rasterizada está soportada en raster y recibió un impulso con el lanzamiento de rasterVis, el cual se describe en un libro sobre el tema de la visualización de datos espaciales y temporales (Lamigueiro 2018).\npartir de 2018, la creación de mapas en R es un tema candente con paquetes dedicados como tmap, leaflet y mapview, todos ellos compatibles con el sistema de clases proporcionado por sf, en el cual se centra el siguiente capítulo (véase el capítulo ?? para obtener más información sobre la visualización).","code":""},{"path":"intro.html","id":"ejercicios","chapter":"1 Introducción","heading":"1.6 Ejercicios","text":"","code":""},{"path":"spatial-class.html","id":"spatial-class","chapter":"2 Datos geográficos en R","heading":"2 Datos geográficos en R","text":"","code":""},{"path":"spatial-class.html","id":"prerrequisitos","chapter":"2 Datos geográficos en R","heading":"Prerrequisitos","text":"Este es el primer capítulo práctico del libro y, por lo tanto, conlleva algunos requisitos de software.\nSuponemos que ya tienes instalada una versión actualizada de R y que te sientes cómodo utilizando el software con una interfaz de línea de comandos como el entorno de desarrollo integrado (IDE) RStudio.\nSi eres nuevo en R, te recomendamos leer el capítulo 2 del libro en línea Efficient R Programming de Gillespie Lovelace (2016) y aprender los fundamentos del lenguaje con recursos como R Data Science de Grolemund Wickham (2016).\nOrganiza tu trabajo (por ejemplo, con proyectos de RStudio) y asigna los scripts nombres sensatos como 02-chapter.R para documentar el código que escribes medida que aprendes.\nLos paquetes utilizados en este capítulo pueden instalarse con los siguientes comandos:4Si estás trabajando con Mac o Linux, es posible que el comando anterior para instalar sf funcione la primera vez.\nEstos sistemas operativos () tienen “requisitos del sistema” que se describen en el README del paquete.\nSe pueden encontrar varias instrucciones específicas para cada en línea, como el artículo Instalación de R 4.0 en Ubuntu 20.04 (Installation R 4.0 Ubuntu 20.04 en inglés) en el blog rtask.thinkr.fr.Todos los paquetes necesarios para reproducir el contenido del libro se pueden instalar con el siguiente comando:\nremotes::install_github(\"geocompr/geocompkg\").\nLos paquetes necesarios se pueden “cargar” (técnicamente se adjuntan) con la función library() de la siguiente manera:La salida de library(sf) informa de las versiones de las bibliotecas geográficas clave (key geographic libraries), como GEOS, la cual ya está utilizando el paquete, como se indica en la Sección 2.2.1.Los demás paquetes instalados contienen datos que se utilizarán en el libro:","code":"\ninstall.packages(\"sf\")\ninstall.packages(\"terra\")\ninstall.packages(\"spData\")\ninstall.packages(\"spDataLarge\", repos = \"https://nowosad.r-universe.dev\")\nlibrary(sf)          # clases y funciones para datos vectoriales\n#> Linking to GEOS 3.9.0, GDAL 3.2.1, PROJ 7.2.1\nlibrary(terra)      # clases y funciones para datos rasterizados\nlibrary(spData)        # cargar datos geográficos\nlibrary(spDataLarge)   # cargar datos geográficos de mayor tamaño"},{"path":"spatial-class.html","id":"intro-spatial-class","chapter":"2 Datos geográficos en R","heading":"2.1 Introducción","text":"En este capítulo se explicarán brevemente los modelos de datos geográficos fundamentales: vectorial y rasterizado.\nIntroduciremos la teoría detrás de cada modelo de datos y las disciplinas en las que predominan, antes de demostrar su implementación en R.El modelo de datos vectoriales representa el mundo mediante puntos, líneas y polígonos.\nEstos tienen bordes discretos y bien definidos, lo que significa que los conjuntos de datos vectoriales suelen tener un alto nivel de precisión (pero necesariamente exactitud, como veremos en el apartado ??).\nEl modelo de datos ráster divide la superficie en celdas de tamaño constante.\nLos conjuntos de datos ráster son la base de las imágenes de fondo utilizadas en la cartografía web y han sido una fuente vital de datos geográficos desde los orígenes de la fotografía aérea y los dispositivos de teledetección por satélite.\nLos rásteres agregan características espacialmente específicas una resolución determinada, lo que significa que son consistentes en el espacio y escalables (existen muchos conjuntos de datos ráster nivel mundial).¿Cuál utilizar?\nLa respuesta depende probablemente de su ámbito de aplicación:Los datos vectoriales tienden dominar las ciencias sociales porque los asentamientos humanos tienden tener fronteras discretasLos datos rasterizados predominan en las ciencias medioambientales debido la dependencia de los datos de teledetecciónEn algunos campos hay mucho solapamiento y los conjuntos de datos ráster y vectoriales pueden utilizarse conjuntamente:\nlos ecologistas y los demógrafos, por ejemplo, suelen utilizar tanto datos vectoriales como rasterizados.\nAdemás, es posible la conversión entre ambas formas (véase el apartado ??).\nIndependientemente de si tu trabajo implica un mayor uso de los conjuntos de datos vectoriales o rasterizados, merece la pena comprender el modelo de datos subyacente antes de utilizarlos, como se explica en los capítulos siguientes.\nEste libro utiliza los paquetes sf y raster para trabajar con datos vectoriales y conjuntos de datos raster, respectivamente.","code":""},{"path":"spatial-class.html","id":"datos-vectoriales","chapter":"2 Datos geográficos en R","heading":"2.2 Datos vectoriales","text":"El modelo de datos vectoriales geográficos se basa en puntos situados dentro de un sistema de referencia de coordenadas (SRC, CRS en inglés).\nLos puntos pueden representar características autónomas (por ejemplo, la ubicación de una parada de autobús) o pueden estar vinculados entre sí para formar geometrías más complejas, como líneas y polígonos.\nLa mayoría de las geometrías de puntos contienen sólo dos dimensiones (los SRC tridimensionales contienen un valor \\(z\\) adicional, que suele representar la altura sobre el nivel del mar).En este sistema, Londres, por ejemplo, puede representarse con las coordenadas c(-0.1, 51.5).\nEsto significa que su ubicación es -0,1 grados al este y 51,5 grados al norte del origen.\nEn este caso, el origen se encuentra 0 grados de longitud (el Primer Meridiano o Meridiano de Greenwich) y 0 grados de latitud (Ecuador) en un SRC geográfico (‘lon/lat’) (Figura 2.1, panel izquierdo).\nEl mismo punto también podría aproximarse en un SRC proyectado con valores ‘Este/Norte’ de c(530000, 180000) en la British National Grid, lo que significa que Londres se encuentra 530 km al Este y 180 km al Norte del \\(origen\\) del SRC.\nEsto puede comprobarse visualmente: algo más de 5 ‘casillas’ -áreas cuadradas delimitadas por las líneas grises de la cuadrícula de 100 km de ancho- separan el punto que representa Londres del origen (Figura 2.1, panel derecho).La ubicación del origen de National Grid, en el mar más allá del Suroeste de la península, garantiza que la mayoría de las ubicaciones en el Reino Unido tengan valores positivos de Orientación y Longitud.5\nHay más aspectos sobre los SRC, como se describe en las secciones 2.4 y ??, pero, para los propósitos de esta sección, es suficiente saber que las coordenadas consisten en dos números que representan la distancia desde un origen, generalmente en \\(x\\) y luego \\(y\\) para las dimensiones.\nFIGURE 2.1: Ilustración de datos vectoriales (puntos) en los que la ubicación de Londres (la X roja) se representa con referencia un origen (el círculo azul). El gráfico de la izquierda representa un SRC geográfico con un origen 0° tanto para la longitud como para la latitud. El gráfico de la derecha representa un SRC proyectado con el origen situado en el mar al Suroeste peninsular.\nsf es un paquete que proporciona un sistema de clases para datos vectoriales geográficos.\nsf sólo sustituye sp, sino que también proporciona una interfaz de línea de comandos consistente para GEOS y GDAL, sustituyendo rgeos y rgdal (descritos en la Sección ??).\nEsta sección presenta las clases sf como preparación para los capítulos siguientes (los capítulos @ref(geometric-operations y ?? cubren la interfaz de GEOS y GDAL, respectivamente).","code":""},{"path":"spatial-class.html","id":"intro-sf","chapter":"2 Datos geográficos en R","heading":"2.2.1 Introducción a Simple Features","text":"Simple Features (en ocasiones también llamado Simple feature access (SFA)) es un estándar abierto desarrollado y respaldado por el Open Geospatial Consortium (OGC), una organización sin ánimo de lucro cuyas actividades volveremos tratar en un capítulo posterior (en la sección ??.\n\nSimple Features es un modelo de datos jerárquico que representa una amplia gama de tipos de geometría.\nDe los 17 tipos de geometría que soporta la especificación, solo 7 se utilizan en la gran mayoría de las investigaciones geográficas (véase la figura 2.2);\nestos tipos de geometría básicos son totalmente compatibles con el paquete de R sf (E. Pebesma 2018).6\nFIGURE 2.2: Tipos de Simple Features compatibles con sf.\nsf puede representar todos los tipos de geometría vectorial comunes (las clases de datos rasterizados son soportadas por sf): puntos, líneas, polígonos y sus respectivas versiones ‘multi’ (que agrupan elementos del mismo tipo en una sola función).\n\n\nsf también soporta colecciones geométricas, las cuales pueden contener múltiples tipos de geometrías en un solo objeto.\nsf proporciona la misma funcionalidad (y más) que previamente se ofrecía en tres paquetes: sp para las clases de datos (E. Pebesma Bivand 2018), rgdal para la lectura/escritura de datos través de una interfaz para GDAL y PROJ (Bivand, Keitt, Rowlingson 2018) y rgeos para las operaciones espaciales través de una interfaz para GEOS (Bivand Rundel 2018).\nPara reiterar el mensaje del capítulo 1, los paquetes geográficos de R tienen una larga historia de interfaces con librerías de bajo nivel, y sf mantiene esta tradición con una interfaz unificada con versiones recientes de la librería GEOS para operaciones geométricas, la librería GDAL para leer y escribir archivos de datos geográficos, y la librería PROJ para representar y transformar sistemas de referencia de coordenadas proyectadas.\nEste es un logro notable que reduce el espacio necesario para ‘cambiar de contexto’ entre diferentes paquetes y permite el acceso librerías geográficas de alto rendimiento.\nLa documentación sobre sf puede encontrarse en su sitio web y en 6 ‘viñetas’, que pueden cargarse de la siguiente manera:Como se explica en la primera viñeta, los objetos ‘Simple Feature’ en R se almacenan en un marco de datos, con los datos geográficos ocupando una columna especial, normalmente llamada ‘geom’ o ‘geometry’.\nUtilizaremos el conjunto de datos world proporcionado por el paquete spData, cargado al principio de este capítulo (véase nowosad.github.io/spData para ver una lista de conjuntos de datos cargados por el paquete).\nworld es un objeto espacial que contiene columnas espaciales y atributos, cuyos nombres son devueltos por la función names() (la última columna contiene la información geográfica):El contenido de la columna geom proporciona los objetos sf sus poderes espaciales: world$geom es una ‘columna lista’ que contiene todas las coordenadas de los polígonos de cada uno de los países.\n\nEl paquete sf proporciona un método plot() para visualizar los datos geográficos:\nel siguiente comando crea la Figura 2.3.\nFIGURE 2.3: Un gráfico espacial del mundo utilizando el paquete sf, con un panel por cada atributo del conjunto de datos.\nObserva que en lugar de crear un único mapa, como harían la mayoría de los programas SIG, el comando plot() ha creado múltiples mapas, uno para cada variable en los conjuntos de datos de world.\nEste procedimiento puede ser útil para explorar la distribución espacial de diferentes variables y se trata más adelante, en la sección 2.2.3.Poder tratar los objetos espaciales como marcos de datos ordinarios pero con poderes espaciales tiene muchas ventajas, especialmente si ya estás acostumbrado trabajar con marcos de datos.\nLa función summary(), por ejemplo, proporciona una útil visión general de las variables dentro del objeto world.Aunque sólo hemos seleccionado una variable para el comando summary, éste también emite un informe sobre la geometría.\nEsto demuestra el comportamiento “pegajoso” de las columnas con geometrías de los objetos sf, lo que significa que los datos geométricos se mantienen menos que el usuario las elimine deliberadamente, como veremos en la sección ??.\nEl resultado proporciona un rápido resumen de los datos espaciales y espaciales contenidos en world: la media de la esperanza de vida es de 71 años (oscilando entre menos de 51 y más de 83 años, con una mediana de 73 años) en todos los países.Merece la pena profundizar en el comportamiento y el contenido básicos de este objeto Simple feature, que puede considerarse útilmente como un ‘marco de datos espaciales’ (‘Spatial data frame’ en inglés).Los objetos sf son fáciles de subdividir.\nEl código siguiente muestra sus dos primeras filas y tres columnas.\nEl resultado muestra dos diferencias importantes en comparación con un data.frame normal: la inclusión de datos geográficos adicionales (tipo de geometría, dimensión, bbox e información SRC - epsg (SRID), proj4string), y la presencia de una columna de geometría, aquí denominada geom:Todo esto puede parecer bastante complejo, especialmente para un sistema de clases que se supone que es sencillo.\nSin embargo, hay buenas razones para organizar las cosas de esta manera y utilizar sf.Antes de describir cada tipo de geometría que permite el paquete sf, vale la pena dar un paso atrás para entender los bloques de construcción de los objetos sf.\nLa sección 2.2.8 muestra cómo los objetos Simple features son marcos de datos, con columnas especiales de geometría.\nEstas columnas espaciales suelen llamarse geom o geometry: world$geom se refiere al elemento espacial del objeto world descrito previamente.\nEstas columnas de geometría son ‘columnas lista’ de la clase sfc (véase el apartado 2.2.7).\nsu vez, los objetos sfc (Simple Feature geometry list-Column) se componen de uno o varios objetos de la clase sfg (Simple Feature Geometries): geometrías simples que se describen en la sección 2.2.6.\n\nPara entender cómo funcionan los componentes espaciales de simple features, es vital entender las geometrías simples (sfg).\nPor este motivo, en el apartado 2.2.5 se tratan todos los tipos de sfg actualmente admitidos, antes de pasar describir cómo pueden representarse en R partir de objetos sfg, los cuales constituyen las bases de los objetos sfc y, eventualmente, la totalidad de los objetos sf.","code":"\nvignette(package = \"sf\") # ver qué viñetas están disponibles\nvignette(\"sf1\")          # introducción al paquete\nnames(world)\n#>  [1] \"iso_a2\"    \"name_long\" \"continent\" \"region_un\" \"subregion\" \"type\"     \n#>  [7] \"area_km2\"  \"pop\"       \"lifeExp\"   \"gdpPercap\" \"geom\"\nplot(world)\nsummary(world[\"lifeExp\"])\n#>     lifeExp                geom    \n#>  Min.   :50.6   MULTIPOLYGON :177  \n#>  1st Qu.:65.0   epsg:4326    :  0  \n#>  Median :72.9   +proj=long...:  0  \n#>  Mean   :70.9                      \n#>  3rd Qu.:76.8                      \n#>  Max.   :83.6                      \n#>  NA's   :10\nworld_mini = world[1:2, 1:3]\nworld_mini\n#> Simple feature collection with 2 features and 3 fields\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -180 ymin: -18.3 xmax: 180 ymax: -0.95\n#> Geodetic CRS:  WGS 84\n#> # A tibble: 2 × 4\n#>   iso_a2 name_long continent                                                geom\n#>   <chr>  <chr>     <chr>                                      <MULTIPOLYGON [°]>\n#> 1 FJ     Fiji      Oceania   (((-180 -16.6, -180 -16.5, -180 -16, -180 -16.1, -…\n#> 2 TZ     Tanzania  Africa    (((33.9 -0.95, 31.9 -1.03, 30.8 -1.01, 30.4 -1.13,…"},{"path":"spatial-class.html","id":"por-qué-simple-features","chapter":"2 Datos geográficos en R","heading":"2.2.2 ¿Por qué Simple Features?","text":"Simple features es un modelo de datos ampliamente aceptado que subyace en las estructuras de datos de muchas aplicaciones SIG, incluyendo QGIS y PostGIS.\nUna de las principales ventajas es que el uso del modelo de datos garantiza la transferencia de tu trabajo otras configuraciones, por ejemplo, importar desde y exportar hacia otras bases de datos espaciales.\nUna pregunta más específica desde la perspectiva de R es “¿por qué utilizar el paquete sf cuando sp ya está probado y comprobado?” Hay muchas razones (relacionadas con las ventajas del modelo Simple features):Lectura y escritura rápida de datosMejora del rendimiento de los gráficosLos objetos sf pueden ser tratados como marcos de datos en la mayoría de las operacionesLas funciones sf pueden combinarse mediante el operador %>% y funcionan bien con la colección tidyverse de paquetes RLos nombres de las funciones sf son relativamente coherentes e intuitivos (todos comienzan por st_)Debido estas ventajas, algunos paquetes espaciales (como tmap, mapview y tidycensus) han añadido compatibilidades con sf.\nSin embargo, la mayoría de los paquetes tardarán muchos años en hacer la transición y algunos nunca la harán.\nAfortunadamente, éstos aún pueden seguir utilizándose en un flujo de trabajo basado en objetos sf, convirtiéndolos la clase Spatial utilizada en sp:Los objetos espaciales pueden volver convertirse en sf de la misma manera o con st_as_sf():","code":"\nlibrary(sp)\nworld_sp = as(world, Class = \"Spatial\")\n# sp functions ...\nworld_sf = st_as_sf(world_sp)"},{"path":"spatial-class.html","id":"basic-map","chapter":"2 Datos geográficos en R","heading":"2.2.3 Elaboración de un mapa básico","text":"Los mapas básicos pueden crearse en sf con plot().\nPor defecto, esto crea un gráfico compuesto de varios paneles (como spplot() de sp), un sub-gráfico para cada variable del objeto, como se ilustra en el panel de la izquierda en la Figura 2.4.\nSe produce una leyenda o “clave” con una paleta de colores continua si el objeto que se va trazar tiene una sola variable (véase el panel de la derecha).\nLos colores también pueden establecerse con col =, aunque esto creará una paleta continua ni una leyenda.\n\nFIGURE 2.4: Gráficos con sf, con múltiples variables (izquierda) y con una única variable (derecha).\nLos gráficos se añaden como capas las imágenes existentes estableciendo add = TRUE.7\nPara demostrar esto, y para proporcionar una muestra del contenido cubierto en los capítulos ?? y ?? sobre las operaciones de atributos y datos espaciales, el siguiente fragmento de código combina países de Asia:Ahora podemos representar el continente asiático sobre un mapa del mundo.\nTen en cuenta que el primer gráfico sólo debe tener una variable para que add = TRUE funcione.\nSi el primer gráfico tiene una leyenda, debe usarse reset = FALSE (el resultado se muestra):Añadir capas de esta manera puede servir para verificar la correspondencia geográfica entre capas: la función plot() es rápida de ejecutar y requiere pocas líneas de código, pero crea mapas interactivos con una amplia gama de opciones.\nPara la creación de mapas más avanzados, recomendamos utilizar paquetes de visualización dedicados ello, como tmap (véase el capítulo ??).","code":"\n\nplot(world[3:6])\nplot(world[\"pop\"])\nworld_asia = world[world$continent == \"Asia\", ]\nasia = st_union(world_asia)\nplot(world[\"pop\"], reset = FALSE)\nplot(asia, add = TRUE, col = \"red\")"},{"path":"spatial-class.html","id":"base-args","chapter":"2 Datos geográficos en R","heading":"2.2.4 Argumentos básicos de plot()","text":"Hay varias formas de modificar los mapas con el método plot() de sf.\nDado que sf amplía los métodos de representación gráfica básicos de R, los argumentos de plot() como main = (que especifica el título del mapa) funcionan con los objetos sf (véase ?graphics::plot y ?par).8\n\nLa figura 2.5 ilustra esta flexibilidad superponiendo círculos, cuyos diámetros (fijados con cex =) representan las poblaciones de los países, en un mapa del mundo.\nSe puede crear una versión proyectada de esta figura con los siguientes comandos (véanse los ejercicios al final de este capítulo y el script 02-contplot.R para reproducir la Figura 2.5):\nFIGURE 2.5: Continentes por países (representados por colores) y poblaciones de 2015 (representadas por círculos, con área proporcional su población).\nEl código anterior utiliza la función st_centroid() para convertir un tipo de geometría (polígonos) en otra (puntos) (véase el capítulo ??), cuya estética se modifica mediante el argumento cex.\nEl método de graficación de sf también tiene argumentos específicos para los datos geográficos. expandBB, por ejemplo, puede usarse para representar un objeto sf en su contexto:\ntoma un vector numérico de longitud cuatro que expande el contorno del gráfico relativo cero en el siguiente orden: abajo, izquierda, arriba, derecha.\nEsto se utiliza para dibujar India en el contexto de sus gigantescos vecinos asiáticos, con énfasis en China al este, en el siguiente fragmento de código, que genera la Figura 2.6 (véanse los ejercicios más adelante sobre la adición de texto los gráficos):\nFIGURE 2.6: India en su contexto, mostrando el resultado del argumento expandBB.\nNótese el uso de [0] para mantener sólo la columna de geometría y lwd para enfatizar India.\nVéase la sección ?? para otras técnicas de visualización para representar distintos tipos de geometrías, el tema de la siguiente sección.","code":"\nplot(world[\"continent\"], reset = FALSE)\ncex = sqrt(world$pop) / 10000\nworld_cents = st_centroid(world, of_largest = TRUE)\nplot(st_geometry(world_cents), add = TRUE, cex = cex)\nindia = world[world$name_long == \"India\", ]\nplot(st_geometry(india), expandBB = c(0, 0.2, 0.1, 1), col = \"gray\", lwd = 3)\nplot(world_asia[0], add = TRUE)"},{"path":"spatial-class.html","id":"geometry","chapter":"2 Datos geográficos en R","heading":"2.2.5 Tipos de geometrías","text":"Las geometrías son los componentes básicos de Simple features.\nSimple features en R pueden adoptar uno de los 17 tipos de geometría compatibles con el paquete sf.\n\n\nEn este capítulo nos centraremos en los siete tipos más utilizados: PUNTO, LÍNEA, POLÍGONO, MULTIPUNTO, MULTILÍNEA, MULTIPOLÍGONO y COLECCIÓN GEOMÉTRICA.\nEncontrarás la lista completa de tipos disponibles en el manual de PostGIS.Por lo general, la codificación estándar para Simple features es la binaria conocida (well-known binary en inglés (WKB)) o el texto conocido (well-known text en inglés (WKT)).\n\n\n\nLas representaciones de WKB suelen ser cadenas hexadecimales fácilmente legibles para los ordenadores.\nPor ello, los SIG y las bases de datos espaciales utilizan WKB para transferir y almacenar objetos geométricos.\nWKT, por otra parte, es una descripción de texto legible para el ser humano de Simple features.\nAmbos formatos son intercambiables, y si debemos presentar uno, naturalmente elegiremos la representación WKT.Las bases de cada tipo de geometría son los puntos.\nUn punto es simplemente una coordenada en el espacio 2D, 3D o 4D (véase vignette(\"sf1\") para más información) así como (véase el panel izquierdo de la figura 2.7):\nPOINT (5 2)\nUna cadena de líneas es una secuencia de puntos con una línea recta que los une, por ejemplo (véase el panel central de la figura 2.7):LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)Un polígono es una secuencia de puntos que forman un anillo cerrado y sin intersecciones.\nCerrado significa que el primer y el último punto de un polígono tienen las mismas coordenadas (véase el panel derecho de la figura 2.7).[\nPor definición, un polígono tiene un límite exterior (anillo exterior) y puede tener cero o más límites interiores (anillos interiores), también conocidos como agujeros.\nUn polígono con agujeros serían, por ejemplo, POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4))]\nPolígono cerrado: POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))\nFIGURE 2.7: Ilustración de geometrías de puntos, líneas y polígonos.\nHasta ahora hemos creado geometrías con una sola entidad geométrica por objeto.\nSin embargo, sf también permite la existencia de múltiples geometrías dentro de un único elemento (de ahí el término “colección de geometrías”) utilizando la versión “multi” de cada tipo de geometría:\nMultipunto: MULTIPOINT (5 2, 1 3, 3 4, 3 2)Multilínea: MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))Multipolígono: MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5), (0 2, 1 2, 1 3, 0 3, 0 2)))\nFIGURE 2.8: Illustration multi* geometries.\nPor último, una colección de geometrías puede contener cualquier combinación de geometrías, incluidos (multi)puntos y cadenas de líneas (véase la figura 2.9):\nColección de geometrías: GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2), LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))\nFIGURE 2.9: Ilustración de una colección de geometrías.\n","code":""},{"path":"spatial-class.html","id":"sfg","chapter":"2 Datos geográficos en R","heading":"2.2.6 Geometrías de Simple features (sfg)","text":"La clase sfg (Simple feature geometry en inglés) representa los diferentes tipos de geometrías de Simple features en R: punto, línea, polígono (y sus equivalentes ‘multi’, como multipuntos) o colección de geometrías.\nPor lo general, te ahorras la tediosa tarea de crear geometrías por tu cuenta, ya que puedes simplemente importar un archivo espacial ya existente.\nSin embargo, existe un conjunto de funciones para crear objetos sfg desde cero si es necesario.\nLos nombres de estas funciones son sencillos y coherentes, ya que todas comienzan con el prefijo st_ y terminan con el nombre del tipo de geometría en minúsculas:Punto: st_point()Línea: st_linestring()Polígono: st_polygon()Multipunto: st_multipoint()Multilínea: st_multilinestring()Multipolígono: st_multipolygon()Colección geométrica: st_geometrycollection()Los objetos sfg pueden crearse partir de tres tipos de datos básicos de R:Un vector numérico: un solo puntoUna matriz: un conjunto de puntos, donde cada fila representa un punto, un multipunto o una líneaUna lista: una colección de objetos como matrices, multilíneas o colecciones de geometríasLa función st_point() crea puntos únicos partir de vectores numéricos:Los resultados muestran que los tipos de punto XY (coordenadas 2D), XYZ (coordenadas 3D) y XYZM (3D con una variable adicional, normalmente la precisión de la medición) se crean partir de vectores de longitud 2, 3 y 4, respectivamente.\nEl tipo XYM debe especificarse mediante el argumento dim (que es la abreviatura de dimensión).Por el contrario, utiliza matrices en el caso de los objetos multipunto (st_multipoint()) y en líneas (st_linestring()):Por último, utiliza listas para la creación de multilíneas, (multi)polígonos y colecciones de geometrías:","code":"\nst_point(c(5, 2))                 # XY point\n#> POINT (5 2)\nst_point(c(5, 2, 3))              # XYZ point\n#> POINT Z (5 2 3)\nst_point(c(5, 2, 1), dim = \"XYM\") # XYM point\n#> POINT M (5 2 1)\nst_point(c(5, 2, 3, 1))           # XYZM point\n#> POINT ZM (5 2 3 1)\n# la función rbind simplifica la creación de matrices\n## MULTIPUNTO\nmultipoint_matrix = rbind(c(5, 2), c(1, 3), c(3, 4), c(3, 2))\nst_multipoint(multipoint_matrix)\n#> MULTIPOINT ((5 2), (1 3), (3 4), (3 2))\n## LÍNEA\nlinestring_matrix = rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2))\nst_linestring(linestring_matrix)\n#> LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)\n## POLÍGONO\npolygon_list = list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))\nst_polygon(polygon_list)\n#> POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))\n## POLÍGONO no cerrado\npolygon_border = rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))\npolygon_hole = rbind(c(2, 4), c(3, 4), c(3, 3), c(2, 3), c(2, 4))\npolygon_with_hole_list = list(polygon_border, polygon_hole)\nst_polygon(polygon_with_hole_list)\n#> POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4))\n## MULTILÍNEA\nmultilinestring_list = list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), \n                            rbind(c(1, 2), c(2, 4)))\nst_multilinestring((multilinestring_list))\n#> MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))\n## MULTIPOLÍGONO\nmultipolygon_list = list(list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))),\n                         list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2))))\nst_multipolygon(multipolygon_list)\n#> MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5)), ((0 2, 1 2, 1 3, 0 3, 0 2)))\n## COLECCIÓN GEOMÉTRICA\ngemetrycollection_list = list(st_multipoint(multipoint_matrix),\n                              st_linestring(linestring_matrix))\nst_geometrycollection(gemetrycollection_list)\n#> GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2),\n#>   LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))"},{"path":"spatial-class.html","id":"sfc","chapter":"2 Datos geográficos en R","heading":"2.2.7 Columnas de simple features (sfc)","text":"Un objeto sfg contiene una sola geometría de Simple feature.\nUna columna de simple feature (Simple feature column en inglés (sfc)) es una lista de objetos sfg, que además puede contener información sobre el sistema de referencia de coordenadas en uso.\nPor ejemplo, para combinar dos objetos simple feature en un objeto con dos elementos, podemos utilizar la función st_sfc().\n\nEsto es importante puesto que sfc representa la columna de geometría en los marcos de datos sf:En la mayoría de los casos, un objeto sfc contiene objetos del mismo tipo de geometría.\nPor lo tanto, cuando convirtamos objetos sfg de tipo polígono en una columna de sfg, acabaríamos también con un objeto sfc de tipo polígono, lo cual puede verificarse con st_geometry_type().\nIgualmente, una columna de geometría de multilíneas resultaría en un objeto sfc de tipo multilíneas:También es posible crear un objeto sfc partir de objetos sfg con diferentes tipos de geometrías:Como se ha mencionado anteriormente, los objetos sfc pueden almacenar adicionalmente información sobre los sistemas de referencia de coordenadas (SRC).\nPara especificar un determinado SRC, podemos utilizar los atributos epsg (SRID) o proj4string de un objeto sfc.\nEl valor por defecto de epsg (SRID) y proj4string es NA (disponible o Available en inglés), como se puede comprobar con st_crs():Todas las geometrías de un objeto sfc deben tener el mismo SRC.\nPodemos añadir el sistema de referencia de coordenadas como argumento crs de st_sfc().\nEste argumento acepta un número entero con el código epsg como 4326, el cual añade automáticamente el ‘proj4string’ (véase la sección 2.4):También acepta un proj4string sin procesar (el resultado se muestra):","code":"\n# PUNTO sfc \npoint1 = st_point(c(5, 2))\npoint2 = st_point(c(1, 3))\npoints_sfc = st_sfc(point1, point2)\npoints_sfc\n#> Geometry set for 2 features \n#> Geometry type: POINT\n#> Dimension:     XY\n#> Bounding box:  xmin: 1 ymin: 2 xmax: 5 ymax: 3\n#> CRS:           NA\n#> POINT (5 2)\n#> POINT (1 3)\n# POLÍGONO sfc \npolygon_list1 = list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))\npolygon1 = st_polygon(polygon_list1)\npolygon_list2 = list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2)))\npolygon2 = st_polygon(polygon_list2)\npolygon_sfc = st_sfc(polygon1, polygon2)\nst_geometry_type(polygon_sfc)\n#> [1] POLYGON POLYGON\n#> 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n# MULTILÍNEA sfc \nmultilinestring_list1 = list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), \n                            rbind(c(1, 2), c(2, 4)))\nmultilinestring1 = st_multilinestring((multilinestring_list1))\nmultilinestring_list2 = list(rbind(c(2, 9), c(7, 9), c(5, 6), c(4, 7), c(2, 7)), \n                            rbind(c(1, 7), c(3, 8)))\nmultilinestring2 = st_multilinestring((multilinestring_list2))\nmultilinestring_sfc = st_sfc(multilinestring1, multilinestring2)\nst_geometry_type(multilinestring_sfc)\n#> [1] MULTILINESTRING MULTILINESTRING\n#> 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n# GEOMETRÍA sfc \npoint_multilinestring_sfc = st_sfc(point1, multilinestring1)\nst_geometry_type(point_multilinestring_sfc)\n#> [1] POINT           MULTILINESTRING\n#> 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\nst_crs(points_sfc)\n#> Coordinate Reference System: NA\n# definición EPSG \npoints_sfc_wgs = st_sfc(point1, point2, crs = 4326)\nst_crs(points_sfc_wgs)\n#> Coordinate Reference System:\n#>   User input: EPSG:4326 \n#>   wkt:\n#> GEOGCRS[\"WGS 84\",\n#>     DATUM[\"World Geodetic System 1984\",\n#>         ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n#>             LENGTHUNIT[\"metre\",1]]],\n#>     PRIMEM[\"Greenwich\",0,\n#>         ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>     CS[ellipsoidal,2],\n#>         AXIS[\"geodetic latitude (Lat)\",north,\n#>             ORDER[1],\n#>             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>         AXIS[\"geodetic longitude (Lon)\",east,\n#>             ORDER[2],\n#>             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>     USAGE[\n#>         SCOPE[\"Horizontal component of 3D system.\"],\n#>         AREA[\"World.\"],\n#>         BBOX[-90,-180,90,180]],\n#>     ID[\"EPSG\",4326]]\n# definición PROJ4STRING \nst_sfc(point1, point2, crs = \"+proj=longlat +datum=WGS84 +no_defs\")"},{"path":"spatial-class.html","id":"sf","chapter":"2 Datos geográficos en R","heading":"2.2.8 La clase sf","text":"Los apartados 2.2.5 2.2.7 tratan de objetos puramente geométricos, ‘sf geometry’ y ‘sf column’ respectivamente.\nEstos son bloques de construcción geográficos de datos vectoriales geográficos representados como simple features.\nEl último bloque de construcción son los atributos geográficos, los cuales representan el nombre de la función u otros atributos como los valores medidos, los grupos y otras cosas.\nPara ilustrar los atributos, representaremos una temperatura de 25°C en Londres el 21 de junio de 2017.\nEste ejemplo contiene una geometría (las coordenadas), y tres atributos con tres clases diferentes (nombre del lugar, temperatura y fecha).9\nLos objetos de clase sf representan esos datos combinando los atributos (data.frame) con la columna de geometrías simple (sfc).\nÉstos son creados con st_sf() como se ilustra continuación, lo cual crea el ejemplo de Londres descrito anteriormente:¿Qué ha pasado? En primer lugar, las coordenadas se utilizaron para crear la geometría simple feature (sfg).\nEn segundo lugar, la geometría se convirtió en una columna de geometrías simple feature (sfc), con un SRC.\nEn tercer lugar, los atributos se almacenaron en un data.frame, que se combinó con el objeto sfc con st_sf().\nEsto da como resultado un objeto sf, como se demuestra continuación (se omiten algunos resultados):El resultado muestra que los objetos sf tienen en realidad dos clases, sf y data.frame.\nsf son simplemente marcos de datos (tablas cuadradas), pero con atributos espaciales almacenados en una columna con forma de lista, normalmente llamada geometría, como se describe en el apartado 2.2.1.\nEsta dualidad es fundamental para el concepto de simple features:\nla mayoría de las veces, un sf puede tratarse y comportarse como un data.frame.\nSimple features son, en esencia, marcos de datos con una extensión espacial.","code":"\nlnd_point = st_point(c(0.1, 51.5))                 # objeto sfg \nlnd_geom = st_sfc(lnd_point, crs = 4326)           # objeto sfc \nlnd_attrib = data.frame(                           # objeto data.frame \n  name = \"London\",\n  temperature = 25,\n  date = as.Date(\"2017-06-21\")\n  )\nlnd_sf = st_sf(lnd_attrib, geometry = lnd_geom)    # objeto sf \nlnd_sf\n#> Simple feature collection with 1 features and 3 fields\n#> ...\n#>     name temperature       date         geometry\n#> 1 London          25 2017-06-21 POINT (0.1 51.5)\nclass(lnd_sf)\n#> [1] \"sf\"         \"data.frame\""},{"path":"spatial-class.html","id":"datos-rasterizados","chapter":"2 Datos geográficos en R","heading":"2.3 Datos rasterizados","text":"El modelo de datos espaciales rasterizados representa el mundo con la cuadrícula continua de celdas (menudo también llamadas píxeles; 2.10:).\nEste modelo de datos suele referirse las llamadas cuadrículas regulares, en las que cada celda tiene el mismo tamaño constante, y en este libro nos centraremos únicamente en las cuadrículas regulares.\nSin embargo, existen otros tipos de cuadrículas, como las cuadrículas rotadas, cizalladas, rectilíneas y curvilíneas (véase el capítulo 1 de Pebesma Bivand (2022) o el capítulo 2 de Tennekes Nowosad (2022))).El modelo de datos ráster suele consistir en una cabecera ráster\ny una matriz (con filas y columnas) que representa celdas igualmente espaciadas (menudo también llamadas píxeles; Figura 2.10:).10\nLa cabecera ráster define el sistema de referencia de coordenadas, la extensión y el origen.\n\n\nEl origen (o punto de partida) suele ser la coordenada de la esquina inferior izquierda de la matriz (el paquete terra, sin embargo, utiliza la esquina superior izquierda, por defecto (Figura 2.10:B)).\nLa cabecera define la extensión mediante el número de columnas, el número de filas y la resolución del tamaño de las celdas.\nPor lo tanto, partiendo del origen, podemos acceder fácilmente cada celda y modificarla utilizando su ID (Figura 2.10:B) o especificando explícitamente las filas y las columnas.\nEsta representación matricial evita almacenar explícitamente las coordenadas de los cuatro puntos de las esquinas (de hecho, sólo almacena una coordenada, el origen) de cada celda, como ocurriría con los polígonos vectoriales rectangulares.\nEsto y el álgebra de mapas (apartado (map-algebra)) hacen que el procesamiento de rásters sea mucho más eficiente y rápido que el de datos vectoriales.\nSin embargo, diferencia de los datos vectoriales, la celda de una capa ráster sólo puede contener un único valor. El valor puede ser numérico o categórico (Figura 2.10:C).\nFIGURE 2.10: Tipos de datos ráster: () IDs de celdas, (B) valores de celdas, (C) un mapa raster coloreado.\nLos mapas ráster suelen representar fenómenos continuos como la elevación, la temperatura, la densidad de población o los datos espectrales (Figura 2.11).\nPor supuesto, también podemos representar características discretas, como las clases de suelo o de cobertura del suelo, con la ayuda de un modelo de datos raster (Figura 2.11).\nEn consecuencia, los límites discretos de estas características se difuminan y, dependiendo de la tarea espacial, podría ser más adecuada una representación vectorial.\nFIGURE 2.11: Ejemplos de rásters continuos y categóricos.\n","code":""},{"path":"spatial-class.html","id":"paquetes-de-r-para-el-manejo-de-datos-rasterizados","chapter":"2 Datos geográficos en R","heading":"2.3.1 Paquetes de R para el manejo de datos rasterizados","text":"","code":""},{"path":"spatial-class.html","id":"introducción-a-terra","chapter":"2 Datos geográficos en R","heading":"2.3.2 Introducción a terra","text":"El paquete terra soporta objetos raster en R.\nProporciona un amplio conjunto de funciones para crear, leer, exportar, manipular y procesar conjuntos de datos raster.\nAparte de la manipulación general de datos ráster, terra proporciona muchas funciones de bajo nivel que pueden constituir la base para desarrollar una funcionalidad ráster más avanzada.\n\nterra también permite trabajar con grandes conjuntos de datos ráster que son demasiado grandes para caber en una memoria principal.\nEn este caso, terra ofrece la posibilidad de dividir el raster en fragmentos más pequeños, y los procesa iterativamente en lugar de cargar todo el archivo raster en la RAM.Para ilustrar los conceptos de terra, utilizaremos los conjuntos de datos de spDataLarge.\nSe trata de unos cuantos objetos ráster y un objeto vectorial que cubren una zona del Parque Nacional de Zion (Utah, EE.UU.).\nPor ejemplo, srtm.tif es un modelo digital de elevación de esta zona (para más detalles, véase su documentación con ?srtm).\nEn primer lugar, vamos crear un objeto SpatRaster llamado my_rast:Al escribir el nombre del raster en la consola, el resultado será la cabecera del raster (dimensiones, resolución, extensión, SRC) y alguna información adicional (clase, fuente de datos, resumen de los valores del ráster):Las funciones dedicadas informan de cada componente: dim(my_rast) retorna el número de filas, columnas y capas; ncell() el número de celdas (píxeles); res() la resolución espacial; ext() su extensión espacial; y crs() su sistema de referencia de coordenadas (la reproyección raster se trata en la Sección ??).\ninMemory() informa de si los datos raster están almacenados en memoria o en disco.help(\"terra-package\") retorna una lista completa de todas las funciones disponibles de terra","code":"\nraster_filepath = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nmy_rast = rast(raster_filepath)\nmy_rast\n#> class       : SpatRaster \n#> dimensions  : 457, 465, 1  (nrow, ncol, nlyr)\n#> resolution  : 0.000833, 0.000833  (x, y)\n#> extent      : -113, -113, 37.1, 37.5  (xmin, xmax, ymin, ymax)\n#> coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#> source      : srtm.tif \n#> name        : srtm \n#> min value   : 1024 \n#> max value   : 2892"},{"path":"spatial-class.html","id":"basic-map-raster","chapter":"2 Datos geográficos en R","heading":"2.3.3 Elaboración de mapas básicos","text":"Al igual que el paquete sf, terra también proporciona métodos plot() para sus propias clases.\n\nFIGURE 2.12: Gráfico raster básico.\nExisten otros enfoques para representar datos ráster en R que quedan fuera del alcance de esta sección, por ejemplo:paquetes como tmap para crear mapas estáticos e interactivos de objetos raster y vectoriales (véase el capítulo ??)funciones, por ejemplo levelplot() del paquete rasterVis, para crear facetas, una técnica común para visualizar el cambio en el tiempo","code":"\nplot(my_rast)"},{"path":"spatial-class.html","id":"raster-classes","chapter":"2 Datos geográficos en R","heading":"2.3.4 Clases ráster","text":"La clase SpatRaster representa un objeto raster en terra.\nLa forma más fácil de crear un objeto raster en R es leer un archivo raster desde el disco o desde un servidor (Sección ??).\nEl paquete terra soporta numerosos controles con la ayuda de la librería GDAL.\nLos rásters de los archivos suelen ser leídos en su totalidad en la memoria RAM, excepción de su cabecera y un puntero al propio archivo.Los rásters también pueden crearse desde cero utilizando la misma función rast().\nEsto se ilustra en el siguiente fragmento de código, que da como resultado un nuevo objeto SpatRaster.\nEl raster resultante consta de 36 celdas (6 columnas y 6 filas especificadas por nrows y ncols) centradas alrededor del Primer Meridiano y el Ecuador (ver parámetros xmin, xmax, ymin y ymax).\nEl SRC por defecto de los objetos ráster es WGS84, pero puede cambiarse con el argumento crs.\nEsto significa que la unidad de la resolución está en grados, que fijamos en 0,5 (resolución).\nLos valores (vals) se asignan cada celda: 1 la celda 1, 2 la celda 2, y así sucesivamente.\nRecuerda: rast() rellena las celdas por filas (diferencia de matrix()) empezando por la esquina superior izquierda, lo que significa que la fila superior contiene los valores del 1 al 6, la segunda del 7 al 12, etc.Para otras formas de crear objetos ráster, véase ?rast.La clase SpatRaster también maneja múltiples capas, que suelen corresponder un único archivo de satélite multiespectral o una serie temporal de rásters.nlyr() recupera el número de capas almacenadas en un objeto ‘SpatRaster’:","code":"\nsingle_raster_file = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nsingle_rast = rast(raster_filepath)\nnew_raster = rast(nrows = 6, ncols = 6, resolution = 0.5, \n                  xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n                  vals = 1:36)\nmulti_raster_file = system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmulti_rast = rast(multi_raster_file)\nmulti_rast\n#> class       : SpatRaster \n#> dimensions  : 1428, 1128, 4  (nrow, ncol, nlyr)\n#> resolution  : 30, 30  (x, y)\n#> extent      : 301905, 335745, 4111245, 4154085  (xmin, xmax, ymin, ymax)\n#> coord. ref. : WGS 84 / UTM zone 12N (EPSG:32612) \n#> source      : landsat.tif \n#> names       : lan_1, lan_2, lan_3, lan_4 \n#> min values  :  7550,  6404,  5678,  5252 \n#> max values  : 19071, 22051, 25780, 31961\nnlyr(multi_rast)\n#> [1] 4"},{"path":"spatial-class.html","id":"crs-intro","chapter":"2 Datos geográficos en R","heading":"2.4 Sistemas de referencia de coordenadas","text":"Los tipos de datos espaciales vectoriales y ráster comparten conceptos intrínsecos los datos espaciales.\nQuizás el más fundamental sea el Sistema de Referencia de Coordenadas (SRC), que define cómo se relacionan los elementos espaciales de los datos con la superficie de la Tierra (u otros cuerpos).\nLos SRC son geográficos o proyectados, tal y como se ha introducido al principio de este capítulo (véase la figura 2.1).\nEn esta sección se explicará cada tipo, sentando las bases para la Sección ?? sobre transformaciones de SRC.","code":""},{"path":"spatial-class.html","id":"sistemas-de-coordenadas-geográficas","chapter":"2 Datos geográficos en R","heading":"2.4.1 Sistemas de coordenadas geográficas","text":"\nLos sistemas de coordenadas geográficas identifican cualquier ubicación en la superficie de la Tierra mediante dos valores: la longitud y la latitud (véase el panel izquierdo de la figura 2.13 y 2.14).\nLa longitud es la ubicación en la dirección Este-Oeste en distancia angular desde el plano del Primer Meridiano (también conocido como Meridiano de Greenwich).\nLa latitud es la distancia angular al Norte o al Sur del plano ecuatorial.\nPor tanto, las distancias en los SRC geográficos se miden en metros.\nEsto tiene importantes consecuencias, como se demuestra en la sección ??.La superficie de la Tierra en los sistemas de coordenadas geográficas se representa mediante una superficie esférica o elipsoidal.\nLos modelos esféricos suponen que la Tierra es una esfera perfecta de un radio determinado; tienen la ventaja de la simplicidad pero, al mismo tiempo, son inexactos: ¡la Tierra es una esfera!\nLos modelos elipsoidales se definen mediante dos parámetros: el radio ecuatorial y el radio polar.\nÉstos son adecuados porque la Tierra está comprimida: el radio ecuatorial es unos 11,5 km más largo que el radio polar (Maling 1992).^[El grado de compresión se suele denominar aplanamiento, definido en función del radio ecuatorial (\\(\\)) y el radio polar (\\(b\\)) de la siguiente manera \\(f = (- b) / \\). También se pueden utilizar los términos elipticidad y compresión.\nDebido que \\(f\\) es un valor bastante pequeño, los modelos de elipsoides digitales utilizan el “aplanamiento inverso” (\\(rf = 1/f\\)) para definir la compresión de la Tierra.\nLos valores de \\(\\) y \\(rf\\) en varios modelos elipsoidales pueden verse ejecutando sf_proj_info(type = \"ellps\").\n]Los elipsoides forman parte de un componente más amplio de los SRC: el datum.\nÉste contiene información sobre el elipsoide que debe utilizarse y la relación precisa entre las coordenadas cartesianas y la ubicación en la superficie de la Tierra.\n\nHay dos tipos de datum: geocéntrico y local.\nEn un dato geocéntrico, como el WGS84, el centro es el centro de gravedad de la Tierra y la precisión de las proyecciones está optimizada para una ubicación específica.\nEn un dato local, como el NAD83, la superficie elipsoidal se desplaza para alinearse con la superficie de un lugar concreto.\n\n","code":""},{"path":"spatial-class.html","id":"sistemas-de-referencia-de-coordenadas-proyectadas","chapter":"2 Datos geográficos en R","heading":"2.4.2 Sistemas de referencia de coordenadas proyectadas","text":"\nLos SRC proyectados se basan en coordenadas cartesianas sobre una superficie implícitamente plana (panel derecho de las Figuras 2.13 y 2.14).\nTienen un origen, unos ejes x e y y una unidad de medida lineal como los metros.\nTodos los SRC proyectados se basan en un SRC geográfico, descrito en la sección anterior, y se apoyan en proyecciones cartográficas para convertir la superficie tridimensional de la Tierra en valores de Este y Norte (x e y) en un SRC proyectado.Esta transición puede realizarse sin añadir algunas deformaciones.\nPor tanto, algunas propiedades de la superficie terrestre se distorsionan en este proceso, como el área, la dirección, la distancia y la forma.\nUn sistema de coordenadas proyectado puede conservar sólo una o dos de esas propiedades.\nLas proyecciones suelen denominarse en función de la propiedad que preservan: las de áreas iguales preservan el área, la azimutal preserva la dirección, la equidistante preserva la distancia y la conformal preserva la forma local.Existen tres grupos principales de tipos de proyección: cónica, cilíndrica y planar (azimutal).\nEn una proyección cónica, la superficie de la Tierra se proyecta en un cono lo largo de una única línea de tangencia o de dos líneas de tangencia.\nLas distorsiones se minimizan lo largo de las líneas de tangencia y aumentan con la distancia desde esas líneas en esta proyección.\nPor lo tanto, es la más adecuada para los mapas de zonas de latitud media.\nUna proyección cilíndrica representa la superficie en un cilindro.\nEsta proyección también puede crearse tocando la superficie de la Tierra lo largo de una sola línea de tangencia o de dos líneas de tangencia.\nLas proyecciones cilíndricas son las que más se utilizan para cartografiar el mundo en su totalidad.\nUna proyección plana proyecta los datos sobre una superficie plana que toca el globo en un punto o lo largo de una línea de tangencia.\nSe suele utilizar para cartografiar regiones polares.\nsf_proj_info(type = \"proj\") ofrece una lista de las proyecciones disponibles que admite la librería PROJ.\nFIGURE 2.13: Ejemplos de sistemas de coordenadas geográficas (WGS 84; izquierda) y proyectadas (NAD83 / zona UTM 12N; derecha) para datos vectoriales.\n\nFIGURE 2.14: Ejemplos de sistemas de coordenadas geográficas (WGS 84; izquierda) y proyectadas (NAD83 / zona UTM 12N; derecha) para datos rasterizados.\n","code":""},{"path":"spatial-class.html","id":"crs-in-r","chapter":"2 Datos geográficos en R","heading":"2.4.3 SRC en R","text":"\n\n\nDos formas recomendables de describir los SRC en R son () los identificadores de sistemas de referencia espacial (Spatial Reference System Identifiers en inglés (SRID)) o (b) las definiciones de texto conocidas (WKT2).\nAmbos enfoques tienen ventajas y desventajas.Un código epsg suele ser más corto y, por tanto, más fácil de recordar.\nEl código también se refiere un solo sistema de referencia de coordenadas bien definido.Los paquetes espaciales de R admiten una amplia gama de SRC y utilizan la biblioteca PROJ, establecida desde hace tiempo.\n\n\n\n\nEn sf el SRC de un objeto puede ser recuperado usando st_crs().\nPara ello, necesitamos leer un conjunto de datos vectoriales:Nuestro nuevo objeto, new_vector, es un polígono que representa los límites del Parque Nacional de Zion (?zion).En los casos en que falta un sistema de referencia de coordenadas (SRC) o se establece un SRC incorrecto, se puede utilizar la función st_set_crs():El mensaje de advertencia nos informa de que la función st_set_crs() transforma los datos de un SRC otro.La función crs() se puede utilizar para acceder la información del SRC desde un objeto SpatRaster:La misma función, crs(), se utiliza para establecer un SRC para los objetos raster.Es importante destacar que las funciones st_crs() y crs() alteran los valores de las coordenadas ni las geometrías.\nSu función es sólo la de establecer los metadatos sobre el objeto SRC.\nAmpliaremos los SRC y explicaremos cómo proyectar de un SRC otro en el capítulo ??.","code":"\nvector_filepath = system.file(\"vector/zion.gpkg\", package = \"spDataLarge\")\nnew_vector = st_read(vector_filepath)\nst_crs(new_vector) # get CRS\n#> Coordinate Reference System:\n#>   User input: UTM Zone 12, Northern Hemisphere \n#>   wkt:\n#> BOUNDCRS[\n#>     SOURCECRS[\n#>         PROJCRS[\"UTM Zone 12, Northern Hemisphere\",\n#>             BASEGEOGCRS[\"GRS 1980(IUGG, 1980)\",\n#>                 DATUM[\"unknown\",\n#>                     ELLIPSOID[\"GRS80\",6378137,298.257222101,\n#>                         LENGTHUNIT[\"metre\",1,\n#>                             ID[\"EPSG\",9001]]]],\n#>                 PRIMEM[\"Greenwich\",0,\n#>                     ANGLEUNIT[\"degree\",0.0174532925199433]]],\n#>             CONVERSION[\"UTM zone 12N\",\n#>                 METHOD[\"Transverse Mercator\",\n#>                     ID[\"EPSG\",9807]],\n#>                 PARAMETER[\"Latitude of natural origin\",0,\n#>                     ANGLEUNIT[\"degree\",0.0174532925199433],\n#>                     ID[\"EPSG\",8801]],\n#>                 PARAMETER[\"Longitude of natural origin\",-111,\n#>                     ANGLEUNIT[\"degree\",0.0174532925199433],\n#>                     ID[\"EPSG\",8802]],\n#>                 PARAMETER[\"Scale factor at natural origin\",0.9996,\n#>                     SCALEUNIT[\"unity\",1],\n#>                     ID[\"EPSG\",8805]],\n#>                 PARAMETER[\"False easting\",500000,\n#>                     LENGTHUNIT[\"Meter\",1],\n#>                     ID[\"EPSG\",8806]],\n#>                 PARAMETER[\"False northing\",0,\n#>                     LENGTHUNIT[\"Meter\",1],\n#>                     ID[\"EPSG\",8807]],\n#>                 ID[\"EPSG\",16012]],\n#>             CS[Cartesian,2],\n#>                 AXIS[\"(E)\",east,\n#>                     ORDER[1],\n#>                     LENGTHUNIT[\"Meter\",1]],\n#>                 AXIS[\"(N)\",north,\n#>                     ORDER[2],\n#>                     LENGTHUNIT[\"Meter\",1]]]],\n#>     TARGETCRS[\n#>         GEOGCRS[\"WGS 84\",\n#>             DATUM[\"World Geodetic System 1984\",\n#>                 ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n#>                     LENGTHUNIT[\"metre\",1]]],\n#>             PRIMEM[\"Greenwich\",0,\n#>                 ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>             CS[ellipsoidal,2],\n#>                 AXIS[\"latitude\",north,\n#>                     ORDER[1],\n#>                     ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>                 AXIS[\"longitude\",east,\n#>                     ORDER[2],\n#>                     ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>             ID[\"EPSG\",4326]]],\n#>     ABRIDGEDTRANSFORMATION[\"Transformation from GRS 1980(IUGG, 1980) to WGS84\",\n#>         METHOD[\"Position Vector transformation (geog2D domain)\",\n#>             ID[\"EPSG\",9606]],\n#>         PARAMETER[\"X-axis translation\",0,\n#>             ID[\"EPSG\",8605]],\n#>         PARAMETER[\"Y-axis translation\",0,\n#>             ID[\"EPSG\",8606]],\n#>         PARAMETER[\"Z-axis translation\",0,\n#>             ID[\"EPSG\",8607]],\n#>         PARAMETER[\"X-axis rotation\",0,\n#>             ID[\"EPSG\",8608]],\n#>         PARAMETER[\"Y-axis rotation\",0,\n#>             ID[\"EPSG\",8609]],\n#>         PARAMETER[\"Z-axis rotation\",0,\n#>             ID[\"EPSG\",8610]],\n#>         PARAMETER[\"Scale difference\",1,\n#>             ID[\"EPSG\",8611]]]]\nnew_vector = st_set_crs(new_vector, \"EPSG:26912\") # set CRS\n#> Warning: st_crs<- : replacing crs does not reproject data; use st_transform for\n#> that\ncrs(my_rast) # get CRS\n#> [1] \"GEOGCRS[\\\"WGS 84\\\",\\n    DATUM[\\\"World Geodetic System 1984\\\",\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"geodetic latitude (Lat)\\\",north,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        AXIS[\\\"geodetic longitude (Lon)\\\",east,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    ID[\\\"EPSG\\\",4326]]\"\nmy_rast2 = my_rast\ncrs(my_rast2) = \"EPSG:26912\" # set CRS"},{"path":"spatial-class.html","id":"paquete-units","chapter":"2 Datos geográficos en R","heading":"2.5 Paquete Units","text":"Una característica importante de los SRC es que contienen información sobre las unidades espaciales.\nEstá claro que es vital saber si las medidas de una casa están en pies o en metros, y lo mismo ocurre con los mapas.\nEs una buena práctica cartográfica añadir una barra de escala o algún otro indicador de distancia en los mapas para demostrar la relación entre las distancias en la página o la pantalla y las distancias sobre el terreno.\nDel mismo modo, es importante especificar formalmente las unidades en las que se miden los datos geométricos o las celdas para proporcionar un contexto, y garantizar que los cálculos posteriores se realicen en contexto.Una característica novedosa de los datos geométricos en los objetos sf es que tienen soporte nativo para las unidades.\nEsto significa que la distancia, el área y otros cálculos geométricos en sf devuelven valores que vienen con un atributo de unidades, definido por el paquete Units (Pebesma, Mailund, Hiebert 2016).\nEsto es ventajoso, ya que evita la confusión causada por las diferentes unidades (la mayoría de los SRC utilizan metros, algunos utilizan pies) y proporciona información sobre la dimensionalidad.\nEsto se demuestra en el siguiente fragmento de código, que calcula la superficie de Luxemburgo:\n\nEl resultado está en unidades de metros cuadrados (m2), lo que demuestra que el resultado representa un espacio bidimensional.\nEsta información, almacenada como un atributo (que los lectores interesados pueden descubrir con attributes(st_area(luxembourg))), puede aportar cálculos posteriores que utilicen unidades, como la densidad de población (que se mide en personas por unidad de superficie, normalmente por km2).\nInformar de las unidades evita confusiones.\nPor ejemplo, en el caso de Luxemburgo, si se especificaran las unidades, se podría suponer erróneamente que se trata de hectáreas.\nPara traducir la enorme cifra un tamaño más digerible, resulta tentador dividir los resultados por un millón (el número de metros cuadrados en un kilómetro cuadrado):Sin embargo, el resultado se vuelve dar incorrectamente como metros cuadrados.\nLa solución es establecer las unidades correctas con el paquete Units:Las unidades tienen la misma importancia en el caso de los datos ráster.\nSin embargo, hasta ahora sf es el único paquete espacial que soporta unidades, lo que significa que las personas que trabajan con datos ráster deben abordar los cambios en las unidades de análisis (por ejemplo, la conversión de la anchura de los píxeles de unidades imperiales decimales) con cuidado.\nEl objeto my_rast (véase más arriba) utiliza una proyección WGS84 con grados decimales como unidades.\nEn consecuencia, su resolución también se da en grados decimales, pero hay que conocerla, ya que la función res() simplemente devuelve un vector numérico.Si utilizáramos la proyección UTM, las unidades cambiarían.De nuevo, el comando res() devuelve un vector numérico sin ninguna unidad, lo que nos obliga saber que la unidad de la proyección UTM es el metro.","code":"\nluxembourg = world[world$name_long == \"Luxembourg\", ]\nst_area(luxembourg) # requiere del paquete s2 en versiones recientes de sf\n#> 2.41e+09 [m^2]\nst_area(luxembourg) / 1000000\n#> 2409 [m^2]\nunits::set_units(st_area(luxembourg), km^2)\n#> 2409 [km^2]\nres(my_rast)\n#> [1] 0.000833 0.000833\nrepr = project(my_rast, \"EPSG:26912\")\nres(repr)"},{"path":"spatial-class.html","id":"ex2","chapter":"2 Datos geográficos en R","heading":"2.6 Ejercicios","text":"Akima, Hiroshi, Albrecht Gebhardt. 2016. Akima: Interpolation Irregularly Regularly Spaced Data.Baddeley, Adrian, Ege Rubak, Rolf Turner. 2015. Spatial Point Patterns: Methodology Applications R. CRC Press.Bivand, Roger. 2001. “Spatial Data Analysis.” R News 1 (3): 13–17.———. 2003. “Approaches Classes Spatial Data R.” Proceedings DSC, edited Kurt Hornik, Friedrich Leisch, Achim Zeileis.———. 2016a. Rgrass7: Interface GRASS 7 Geographical Information System R.———. 2016b. Spgrass6: Interface GRASS 6 R.———. 2017. Spdep: Spatial Dependence: Weighting Schemes, Statistics Models.Bivand, Roger, Albrecht Gebhardt. 2000. “Implementing Functions Spatial Statistical Analysis Using Language.” Journal Geographical Systems 2 (3): 307–17. https://doi.org/10.1007/PL00011460.Bivand, Roger, Tim Keitt, Barry Rowlingson. 2018. Rgdal: Bindings ’Geospatial’ Data Abstraction Library. https://CRAN.R-project.org/package=rgdal.Bivand, Roger, Nicholas Lewin-Koh. 2017. Maptools: Tools Reading Handling Spatial Objects.Bivand, Roger, Markus Neteler. 2000. “Open Source Geocomputation: Using R Data Analysis Language Integrated GRASS GIS PostgreSQL Data Base Systems.” Proceedings 5th International Conference GeoComputation, edited Markus Neteler Roger S. Bivand.Bivand, Roger, Edzer J Pebesma, Virgilio Gómez-Rubio. 2013. Applied Spatial Data Analysis R. Vol. 747248717. Springer.Bivand, Roger, Colin Rundel. 2018. Rgeos: Interface Geometry Engine - Open Source (’Geos’). https://CRAN.R-project.org/package=rgeos.Bivand, Roger S. 2000. “Using R Statistical Data Analysis Language GRASS 5.0 GIS Database Files.” Computers & Geosciences 26 (9): 1043–52. https://doi.org/10.1016/S0098-3004(00)00057-1.Brenning, Alexander. 2012. ArcGIS Geoprocessing R via Python.Brenning, Alexander, Donovan Bangs, Marc Becker. 2018. RSAGA: SAGA Geoprocessing Terrain Analysis. https://CRAN.R-project.org/package=RSAGA.Brzustowicz, Michael R. 2017. Data Science Java: [Practical Methods Scientists Engineers]. First. Beijing Boston Farnham: OReilly.Calenge, C. 2006. “Package Adehabitat R Software: Tool Analysis Space Habitat Use Animals.” Ecological Modelling 197: 1035. https://doi.org/10.1016/j.ecolmodel.2006.03.017.Chambers, John M. 2016. Extending R. CRC Press.Coppock, J Terry, David W Rhind. 1991. “History GIS.” Geographical Information Systems: Principles Applications, Vol. 1. 1 (1): 21–43.Eddelbuettel, Dirk, James Joseph Balamuta. 2018. “Extending R C++: Brief Introduction Rcpp.” American Statistician 72 (1): 28–36. https://doi.org/10/gdg3fb.Garrard, Chris. 2016. Geoprocessing Python. Shelter Island, NY: Manning Publications.Gillespie, Colin, Robin Lovelace. 2016. Efficient R Programming: Practical Guide Smarter Programming. O’Reilly Media.Grolemund, Garrett, Hadley Wickham. 2016. R Data Science. O’Reilly Media.Hijmans, Robert J. 2016. Geosphere: Spherical Trigonometry.———. 2017. Raster: Geographic Data Analysis Modeling. https://CRAN.R-project.org/package=raster.Jr, Paulo J. Ribeiro, Peter J. Diggle. 2016. geoR: Analysis Geostatistical Data.Kahle, D, Hadley Wickham. 2013. “Ggmap: Spatial Visualization Ggplot2.” R Journal 5: 144–61. https://doi.org/10.32614/RJ-2013-014.Lamigueiro, Oscar Perpinan. 2018. Displaying Time Series, Spatial, Space-Time Data R. Second. Boca Raton: Chapman Hall/CRC.Livingstone, David N. 1992. Geographical Tradition: Episodes History Contested Enterprise. Oxford, UK ; Cambridge, USA: John Wiley & Sons Ltd.Longley, Paul. 2015. Geographic Information Science & Systems. Fourth edition. Hoboken, NJ: Wiley.Longley, Paul ., Sue M. Brooks, Rachael McDonnell, Bill MacMillan, eds. 1998. Geocomputation: Primer. Chichester, Eng. ; New York: Wiley.Majure, James J., Albrecht Gebhardt. 2016. Sgeostat: Object-Oriented Framework Geostatistical Modeling S+.Maling, D. H. 1992. Coordinate Systems Map Projections. Second. Oxford ; New York: Pergamon Press.Muenchow, Jannes, Patrick Schratz, Alexander Brenning. 2017. “RQGIS: Integrating R QGIS Statistical Geocomputing.” R Journal 9 (2): 409–28. https://doi.org/10/gf3d48.Neteler, Markus, Helena Mitasova. 2008. Open Source GIS: GRASS GIS Approach. Third. New York, NY: Springer.Openshaw, Stan, Robert J. Abrahart, eds. 2000. Geocomputation. London ; New York: CRC Press.Pebesma, Edzer. 2018. “Simple Features R: Standardized Support Spatial Vector Data.” R Journal. https://doi.org/10/gf2ztt.Pebesma, Edzer, Roger Bivand. 2018. Sp: Classes Methods Spatial Data. https://CRAN.R-project.org/package=sp.———. 2022. Spatial Data Science Applications R.Pebesma, Edzer, Benedikt Graeler. 2018. Gstat: Spatial Spatio-Temporal Geostatistical Modelling, Prediction Simulation. https://CRAN.R-project.org/package=gstat.Pebesma, Edzer J, Roger S Bivand. 2005. “Classes Methods Spatial Data R.” R News 5 (2): 9–13.Pebesma, Edzer, Thomas Mailund, James Hiebert. 2016. “Measurement Units R.” R Journal 8 (2): 486–94. https://doi.org/10/gkb5pd.Pebesma, Edzer, Daniel Nüst, Roger Bivand. 2012. “R Software Environment Reproducible Geoscientific Research.” Eos, Transactions American Geophysical Union 93 (16): 163–63. https://doi.org/10/gd8djc.Ripley, Brian D. 2001. “Spatial Statistics R.” R News 1 (2): 14–15.Rowlingson, Barry, Adrian Baddeley, Rolf Turner, Peter Diggle. 2003. “Rasp: Package Spatial Statistics.” Proceedings 3rd International Workshop Distributed Statistical Computing, edited Kurt Hornik.Rowlingson, Barry, Peter Diggle. 2017. Splancs: Spatial Space-Time Point Pattern Analysis.Rowlingson, B. S, P. J Diggle. 1993. “Splancs: Spatial Point Pattern Analysis Code S-Plus.” Computers & Geosciences 19 (5): 627–55. https://doi.org/10/dvzffd.Sherman, Gary. 2008. Desktop GIS: Mapping Planet Open Source Tools. Pragmatic Bookshelf.Talbert, Richard J. . 2014. Ancient Perspectives: Maps Place Mesopotamia, Egypt, Greece, Rome. University Chicago Press.Tennekes, Martijn, Jakub Nowosad. 2022. Elegant Informative Maps Tmap.Economist. 2016. “Autonomous Car’s Reality Check.” Economist.Venables, W. N., B. D. Ripley. 2002. Modern Applied Statistics S. Fourth. New York: Springer.Venables, W. N., D. M. Smith, R Core Team. 2017. Introduction R. Notes R: Programming Environment Data Analysis Graphics.Wickham, Hadley. 2014. Advanced R. CRC Press.Wulf, Andrea. 2015. Invention Nature: Alexander von Humboldt’s New World. New York: Alfred . Knopf.","code":""}]
