[{"path":"index.html","id":"bienvenido","chapter":"Bienvenido","heading":"Bienvenido","text":"Esta es la versión web de Geocomputación con R, un libro sobre análisis, visualización y modelado de datos geográficos.Nota: La primera edición del libro en inglés ha sido publicada por CRC Press en la [Serie R] (https://www.routledge.com/Chapman--HallCRC--R-Series/book-series/CRCTHERSER).\nPuedes comprar el libro en CRC Press, o en Amazon y acceder la primera edición archivada en la plataforma para libros en abierto bookdown.org.Inspirado en bookdown y en el movimiento del software libre y de código abierto para el sector geoespacial (FOSS4G), este libro es de código abierto.\nEsto garantiza que su contenido sea reproducible y accesible al público en todo el mundo.La versión online del libro está alojada en geocompr.robinlovelace.net y se mantiene actualizada gracias GitHub Actions, que proporciona información sobre su “estado de construcción” de la siguiente manera:Esta versión del libro fue elaborada en GH Actions el 2022-02-03.","code":""},{"path":"index.html","id":"cómo-contribuir","chapter":"Bienvenido","heading":"¿Cómo contribuir?","text":"bookdown hace que editar un libro sea tan fácil como editar una wiki, siempre que tengas una cuenta en (sign-github.com).\nUna vez iniciada tu sesión en GitHub, haz clic en el icono “Editar esta página” (‘Edit page’ en inglés) en el panel derecho del sitio web del libro.\nEsto te llevará una versión editable del archivo original de R Markdown que ha generado la página en la que te encuentras.Para plantear un problema sobre el contenido del libro (por ejemplo, que el código se ejecute) o hacer una solicitud de funcionalidad, consulte el rastreador de problemas.Los responsables del mantenimiento y los colaboradores deben seguir el CÓDIGO DE CONDUCTA de este repositorio.","code":""},{"path":"index.html","id":"reproducibilidad","chapter":"Bienvenido","heading":"Reproducibilidad","text":"Para reproducir el código del libro, se necesita una versión reciente de R y que los paquetes estén actualizados. Estos pueden ser instalados con el siguiente comando (que requiere del paquete remotes):La forma más rápida de reproducir los contenidos del libro si eres principiante en tratar datos geográficos en R puede ser en el navegador web, gracias Binder.Al hacer clic en el siguiente enlace se abrirá una nueva ventana con RStudio Server en su navegador web, lo que te permitirá abrir archivos de capítulos y ejecutar trozos de código para comprobar que el código es reproducible.Si ves algo como la imagen de abajo, enhorabuena, ha funcionado y puedes empezar explorar Geocomputación con R en un entorno en la nube (siendo consciente de las normas de uso de mybinder.org):\nFIGURE 0.1: Screenshot reproducible code contained Geocomputación con R running RStudio Server browser served Binder\nPara reproducir el código del libro en tu propio ordenador, necesitarás una versión reciente de R con paquetes actualizados.\nEstos pueden ser instalados usando la librería remotes.Después de instalar las dependencias del libro, deberías ser capaz de reproducir los fragmentos de código de cada uno de los capítulos del libro.\nSi clonas el repo del libro y accedes la carpeta geocompr, deberías poder reproducir el contenido con el siguiente comando:Echa un vistazo al repositorio de GitHub para los detalles sobre la reproducción del libro.","code":"\ninstall.packages(\"remotes\")\nremotes::install_github(\"geocompr/geocompkg\")\nremotes::install_github(\"nowosad/spData\")\nremotes::install_github(\"nowosad/spDataLarge\")\n\n# Durante el desarrollo de la segunda edición tal vez necesites versiones de desarrollo de\n# otros paquetes para construir el libro, p.ej.:\nremotes::install_github(\"rspatial/terra\")\nremotes::install_github(\"mtennekes/tmap\")\nbookdown::serve_book()"},{"path":"index.html","id":"apoya-el-proyecto","chapter":"Bienvenido","heading":"Apoya el proyecto","text":"Si encuentras el libro útil, por favor, apóyalo mediante:Hablando de él en personaComunicando sobre el libro en medios digitales, por ejemplo, través del hashtag #geocompr en Twitter (véase nuestro Libro de visitas) o haciéndonos saber sobre cursos en los que se utiliza el libroCitándolo o enlazándoloPoniendo estrellas en el repositorio GitHub de geocomprHaciendo reseñas, por ejemplo, en Amazon o GoodreadsHaciendo preguntas o sugerencias sobre el contenido través de GitHub o Twitter.Comprando un ejemplar en papelPuedes encontrar más detalles en github.com/Robinlovelace/geocompr.work licensed Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.","code":""},{"path":"prólogo-1a-edición.html","id":"prólogo-1a-edición","chapter":"Prólogo (1a Edición)","heading":"Prólogo (1a Edición)","text":"Hacer “espacial” en R siempre ha sido una cuestión muy amplia, buscando proporcionar e integrar herramientas de geografía, geoinformática, geocomputación y estadística espacial para cualquier persona interesada en participar: participar en la formulación de preguntas interesantes, contribuir con preguntas fructíferas para la investigación, y escribir y mejorar el código.\nEs decir, hacer “espacial” en R siempre ha incluido código abierto, datos abiertos y reproducibilidad.Hacer “espacial” en R también ha buscado estar abierto la interacción con muchas ramas del análisis de datos espaciales aplicados, y también implementar nuevos avances en la representación de datos y métodos de análisis para exponerlos al escrutinio interdisciplinario.\nComo demuestra este libro, menudo existen flujos de trabajo alternativos para obtener resultados similares partir de datos similares, y podemos aprender de las comparaciones con la forma en que otros crean y entienden sus flujos de trabajo.\nEsto incluye aprender de comunidades similares en torno los SIG de código abierto y lenguajes complementarios como Python, Java, etc.La amplia variedad de capacidades espaciales de R nunca habría evolucionado sin personas dispuestas compartir lo que están creando o adaptando.\nEsto puede incluir material didáctico, software, prácticas de investigación (investigación reproducible, datos abiertos) y combinaciones de todos ellos.\nLos usuarios de R también se han beneficiado enormemente de las bibliotecas geográficas de código abierto como GDAL, GEOS y PROJ.Este libro es un claro ejemplo de que, si eres curioso y estás dispuesto participar, puedes encontrar cosas que es necesario hacer y que se ajustan tus aptitudes.\nCon los avances en la representación de datos y las alternativas de flujo de trabajo, y el número cada vez mayor de nuevos usuarios que menudo están expuestos la línea de comandos cuantitativa aplicada, un libro de este tipo es realmente necesario.\npesar del esfuerzo que supone, los autores se han apoyado mutuamente para sacar adelante la publicación.Por lo tanto, este libro fresco está listo para funcionar; sus autores lo han probado durante muchos seminarios y talleres, por lo que los lectores e instructores podrán beneficiarse de saber que los contenidos han sido y siguen siendo probados por personas como ellos.\nComprométete con los autores y con la comunidad R-spatial, observa el valor de tener más opciones en la construcción de tus flujos de trabajo y, lo más importante, disfruta aplicando lo que aprendes aquí en cosas que te interesan.Roger BivandBergen, September 2018","code":""},{"path":"prefacio.html","id":"prefacio","chapter":"Prefacio","heading":"Prefacio","text":"","code":""},{"path":"prefacio.html","id":"a-quién-va-dirigido-este-libro","chapter":"Prefacio","heading":"A quién va dirigido este libro","text":"Este libro está dirigido personas que quieren analizar, visualizar y modelar datos geográficos con software de código abierto.\nSe basa en R, un lenguaje de programación estadístico que tiene potentes capacidades de procesamiento de datos, de visualización y geoespaciales.\nEl libro cubre una extensa variedad de temas y puede ser de interés para un amplio abanico de personas de campos muy distintos, especialmente:Personas que han aprendido realizar análisis espaciales con un Sistema de Información Geográfica (SIG) de escritorio, como QGIS, ArcGIS, GRASS o SAGA, que quieran acceder un potente lenguaje de programación de (geo)estadística y de visualización y las ventajas de un entorno de línea de comandos (Sherman 2008):\n\nCon la llegada del software SIG “moderno,” la mayoría de la gente quiere apuntar y hacer clic en su camino por la vida. Eso está bien, pero hay una enorme cantidad de flexibilidad y poder esperándote en las líneas de comandos.\nPersonas que han aprendido realizar análisis espaciales con un Sistema de Información Geográfica (SIG) de escritorio, como QGIS, ArcGIS, GRASS o SAGA, que quieran acceder un potente lenguaje de programación de (geo)estadística y de visualización y las ventajas de un entorno de línea de comandos (Sherman 2008):Con la llegada del software SIG “moderno,” la mayoría de la gente quiere apuntar y hacer clic en su camino por la vida. Eso está bien, pero hay una enorme cantidad de flexibilidad y poder esperándote en las líneas de comandos.Estudiantes graduados e investigadores de campos especializados en datos geográficos, como la geografía, la teledetección, la planificación, los SIG y la ciencia de los datos geográficosEstudiantes graduados e investigadores de campos especializados en datos geográficos, como la geografía, la teledetección, la planificación, los SIG y la ciencia de los datos geográficosAcadémicos y estudiantes que trabajan con datos geográficos — en campos como la Geología, la Ciencia Regional, la Biología y la Ecología, las Ciencias Agrícolas, la Arqueología, la Epidemiología, la Modelización del Transporte, y la Ciencia de los Datos en sentido amplio — los cuales requieren la potencia y la flexibilidad de R para su investigaciónAcadémicos y estudiantes que trabajan con datos geográficos — en campos como la Geología, la Ciencia Regional, la Biología y la Ecología, las Ciencias Agrícolas, la Arqueología, la Epidemiología, la Modelización del Transporte, y la Ciencia de los Datos en sentido amplio — los cuales requieren la potencia y la flexibilidad de R para su investigaciónInvestigadores y analistas aplicados en organizaciones públicas, privadas o del tercer sector que necesitan la reproducibilidad, la velocidad y la flexibilidad de un lenguaje de línea de comandos como R en aplicaciones que tratan datos espaciales tan diversos como la planificación urbana y del transporte, la logística, el geomarketing (análisis de localización de tiendas) y la planificación de emergenciasInvestigadores y analistas aplicados en organizaciones públicas, privadas o del tercer sector que necesitan la reproducibilidad, la velocidad y la flexibilidad de un lenguaje de línea de comandos como R en aplicaciones que tratan datos espaciales tan diversos como la planificación urbana y del transporte, la logística, el geomarketing (análisis de localización de tiendas) y la planificación de emergenciasEl libro está diseñado para usuarios de R de nivel intermedio-avanzado interesados en la geocomputación y para principiantes en R que tengan experiencia previa con datos geográficos.\nSi eres nuevo tanto en R como trabajando con datos geográficos, te desanimes: proporcionamos enlaces materiales adicionales y describimos la naturaleza de los datos espaciales desde una perspectiva de principiante en el capítulo 2 y en los enlaces que se proporcionan continuación.","code":""},{"path":"prefacio.html","id":"cómo-leer-este-libro","chapter":"Prefacio","heading":"Cómo leer este libro","text":"El libro está dividido en tres partes:Parte : Fundamentos, destinado ponerte al día con los datos geográficos en R.Parte II: Extensiones, las cuales cubren técnicas avanzadas.Parte III: Aplicaciones, para los problemas del mundo real.Los capítulos se vuelven progresivamente más difíciles, por lo que recomendamos leer el libro en orden.\nUno de los principales obstáculos para el análisis geográfico en R es su pronunciada curva de aprendizaje.\nLos capítulos de la primera parte pretenden abordar esta cuestión proporcionando código reproducible en conjuntos de datos sencillos que deberían facilitar el proceso de iniciación.Un aspecto importante del libro desde el punto de vista de la enseñanza/aprendizaje son los ejercicios al final de cada capítulo.\nAl completarlos, desarrollarás tus habilidades y obtendrás la confianza necesaria para abordar distintos problemas geoespaciales.\nLas soluciones los ejercicios, así como varios ejemplos ampliados, se encuentran en la web de apoyo del libro, en geocompr.github.io.Los lectores impacientes pueden sumergirse directamente en los ejemplos prácticos, los cuales comienzan en el capítulo 2.\nSin embargo, recomendamos leer primero el amplio contexto de Geocomputación con R en el capítulo 1.\nSi eres nuevo en R, también te recomendamos que aprendas más sobre el lenguaje antes de intentar ejecutar los bloques de código proporcionados en cada capítulo (menos que estés leyendo el libro para entender los conceptos).\nAfortunadamente para los principiantes de R, la comunidad de apoyo ha desarrollado una gran cantidad de recursos que pueden ayudar.\nNosotros particularmente recomendamos tres tutoriales: R para Ciencia de Datos (Grolemund Wickham 2016) y Programación eficiente con R (Gillespie Lovelace 2016), especialmente Capítulo 2 (sobre la instalación y configuración de R/RStudio) y Capítulo 10 (sobre aprender aprender), y Una introducción R (Venables, Smith, Team 2017).","code":""},{"path":"prefacio.html","id":"por-qué-r","chapter":"Prefacio","heading":"¿Por qué R?","text":"Aunque R tiene una curva de aprendizaje pronunciada, el método de línea de comandos que se defiende en este libro puede ser rápidamente rentable.\nComo aprenderás en los capítulos siguientes, R es una herramienta eficaz para abordar una gran variedad de retos relacionados con los datos geográficos.\nEsperamos que, con la práctica, R se convierta en el programa elegido en tu caja de herramientas geoespaciales para muchas aplicaciones.\nEscribir y ejecutar comandos en la línea de comandos es, en muchos casos, más rápido que apuntar y hacer clic en la interfaz gráfica de usuario (GUI) de un SIG de escritorio.\nPara algunas aplicaciones, como la estadística espacial y el modelado, R puede ser la única forma realista de llevar cabo el trabajo.Como se indica en la Sección ??, hay muchas razones para usar R para la geocomputación:\nR se adapta bien al uso interactivo que requieren muchos flujos de trabajo de análisis de datos geográficos en comparación con otros lenguajes.\nR destaca en los campos de rápido crecimiento de la Ciencia de Datos (que incluye la carpintería de datos, las técnicas de aprendizaje estadístico y la visualización de datos) y el Big Data (través de interfaces eficientes con bases de datos y sistemas de computación distribuidos).\nAdemás, R permite un flujo de trabajo reproducible: compartir las secuencias de comandos subyacentes tu análisis permitirá que otros se basen en tu trabajo.\nPara garantizar la reproducibilidad en este libro, hemos puesto disposición su código fuente en github.com/Robinlovelace/geocompr.\nAllí encontrarás archivos en la carpeta code/ que generan figuras:\nCuando el código que genera una figura se proporciona en el texto principal del libro, el nombre del archivo que la generó se proporciona en el pie de foto (véase, por ejemplo, el pie de foto de la figura ??).\nOtros lenguajes como Python, Java y C++ pueden utilizarse para la geocomputación y existen excelentes recursos para aprender geocomputación sin R, como se discute en la sección ??.\nNinguno de ellos proporciona la combinación única de ecosistema de paquetes, capacidades estadísticas, opciones de visualización y potentes IDEs que ofrece la comunidad R.\nAdemás, al enseñar utilizar un lenguaje (R) en profundidad, este libro te proporcionará los conceptos y la confianza necesarios para realizar geocomputación en otros lenguajes.","code":""},{"path":"prefacio.html","id":"impacto-en-el-mundo-real","chapter":"Prefacio","heading":"Impacto en el mundo real","text":"Geocomputación con R proporcionará los conocimientos y las habilidades necesarias para abordar una amplia variedad de cuestiones, incluidas aquellas con implicaciones científicas, sociales y medioambientales, que se manifiestan en los datos geográficos.\nComo se describe en la sección @ref(qué-es-la-geocomputación), la geocomputación sólo consiste en utilizar ordenadores para procesar datos geográficos:\ntambién se trata del impacto en el mundo real.\nSi estás interesado en un contexto más amplio y las motivaciones que hay detrás de este libro, sigue leyendo; se tratan en el capítulo 1.","code":""},{"path":"prefacio.html","id":"agradecimientos","chapter":"Prefacio","heading":"Agradecimientos","text":"Muchas gracias todos los que han contribuido directa e indirectamente través del código de alojamiento y colaboración través de GitHub, incluyendo las siguientes personas que contribuyeron directamente través de solicitudes de extracción (pull requests): prosoitos, florisvdh, katygregg, rsbivand, KiranmayiV, zmbc, erstearns, MikeJohnPage, eyesofbambi, nickbearman, tyluRp, marcosci, giocomai, KHwong12, LaurieLBaker, MarHer90, mdsumner, pat-s, gisma, ateucher, annakrystalli, DarrellCarvalho, kant, gavinsimpson, Henrik-P, Himanshuteli, yutannihilation, jbixon13, yvkschaefer, katiejolly, layik, mpaulacaldas, mtennekes, mvl22, ganes1410, richfitz, wdearden, yihui, chihinl, cshancock, gregor-d, jasongrahn, p-kono, pokyah, schuetzingit, sdesabbata, tim-salabim, tszberkowitz.\nUn agradecimiento especial Marco Sciaini, que sólo creó la imagen de la portada, sino que también publicó el código que la generó (véase code/frontcover.R en el repositorio de GitHub del libro).\nDocenas de personas más contribuyeron en línea, planteando y comentando cuestiones, y proporcionando comentarios través de las redes sociales.¡El hashtag #geocompr seguirá vivo!Nos gustaría dar las gracias John Kimmel, de CRC Press, que ha trabajado con nosotros durante dos años para convertir nuestras ideas iniciales de un plan de libro en la producción final través de cuatro rondas de revisión.\nLos revisores merecen una mención especial: sus detallados comentarios y su experiencia mejoraron sustancialmente la estructura y el contenido del libro.Damos las gracias Patrick Schratz y Alexander Brenning, de la Universidad de Jena, por sus fructíferas discusiones y aportaciones los capítulos ?? y ??.\nDamos las gracias Emmanuel Blondel, de la Organización de las Naciones Unidas para la Agricultura y la Alimentación, por su aportación experta la sección sobre servicios web;\nMichael Sumner, por su aportación crítica en muchas áreas del libro, especialmente en la discusión de los algoritmos del capítulo 10;\nTim Appelhans y David Cooley, por sus contribuciones clave al capítulo sobre visualización (capítulo 8);\ny Katy Gregg, que corrigió todos los capítulos y mejoró enormemente la legibilidad del libro.Podrían mencionarse innumerables personas que han contribuido de innumerables maneras.\nEl último agradecimiento es para todos los desarrolladores de software que hacen posible Geocomputación con R.\nEdzer Pebesma (que creó el paquete sf), Robert Hijmans (que creó raster) y Roger Bivand (que sentó las bases de gran parte del software espacial de R) han hecho posible la computación geográfica de alto rendimiento en R.","code":""},{"path":"intro.html","id":"intro","chapter":"1 Introducción","heading":"1 Introducción","text":"Este libro trata de utilizar el poder de los ordenadores para hacer cosas con los datos geográficos.\nEnseña una serie de habilidades espaciales, entre las que se incluyen: la lectura, escritura y manipulación de datos geográficos; la elaboración de mapas estáticos e interactivos; la aplicación de la geocomputación para resolver problemas del mundo real; y la modelización de fenómenos geográficos.\nAl demostrar cómo se pueden enlazar varias operaciones geográficas, en “trozos de código” reproducibles que intercalan la prosa, el libro también enseña un flujo de trabajo transparente y, por tanto, científico.\nAprender utilizar la gran cantidad de herramientas geoespaciales disponibles en la línea de comandos de R puede ser emocionante, pero crear otras nuevas puede ser realmente liberador.\nEl uso del enfoque basado en la línea de comandos que se enseña lo largo del libro, y las técnicas de programación que se tratan en el capítulo ??, pueden ayudar eliminar las restricciones tu creatividad impuestas por el software.\nPor lo tanto, después de leer el libro y completar los ejercicios, deberías sentirte capacitado con una sólida comprensión de las posibilidades abiertas por las impresionantes capacidades geográficas de R, nuevas habilidades para resolver problemas del mundo real con datos geográficos, y la capacidad de comunicar tu trabajo con mapas y código reproducible.En las últimas décadas, el software libre y de código abierto dedicado al ámbito geoespacial (FOSS4G) ha progresado un ritmo asombroso.\nGracias organizaciones como OSGeo, el análisis de datos geográficos ha dejado de ser algo exclusivo de quienes disponen de caros hardware y software: ahora cualquiera puede descargar y ejecutar bibliotecas espaciales de alto rendimiento.\nLos Sistemas de Información Geográfica (SIG, o GIS en inglés) de código abierto, como QGIS, han hecho accesible el análisis geográfico en todo el mundo. Los programas SIG tienden enfatizar las interfaces gráficas para el usuario (GUIs), con la consecuencia deseada de desalentar la reproducibilidad (aunque muchos pueden utilizarse desde la línea de comandos, como veremos en el capítulo ??).\nR, por el contrario, hace énfasis en la interfaz de la línea de comandos (CLI). Una comparación simplista entre los diferentes enfoques se ilustra en la Tabla 1.1.TABLE 1.1: Diferencias de énfasis entre los paquetes software (Interfaz gráfica del usuario (Graphical User Interface, GUI en inglés) de los Sistemas de Información Geográfica (GIS) y R).Este libro está motivado por la importancia de la reproducibilidad para la investigación científica (véase la nota inferior).\nSu objetivo es hacer más accesibles los flujos de trabajo de los análisis de datos geográficos reproducibles, y demostrar el poder del software geoespacial abierto disponible desde la línea de comandos.\n“Las interfaces para otros software forman parte de R” (Eddelbuettel Balamuta 2018).\nEsto significa que, además de las destacadas capacidades “internas,” R permite el acceso muchas otras bibliotecas de software espacial, explicadas en la sección @ref(Por-qué-usar-R-para-la-geocomputación) y demostradas en el capítulo ??.\nSin embargo, antes de entrar en los detalles del software, vale la pena dar un paso atrás y pensar en lo que entendemos por geocomputación.La reproducibilidad es una de las principales ventajas de las interfaces de línea de comandos, pero ¿qué significa en la práctica?\nLa definimos del siguiente modo:“Un proceso en el que los mismos resultados pueden ser generados por otros utilizando un código públicamente accesible.”","code":""},{"path":"intro.html","id":"qué-es-la-geocomputación","chapter":"1 Introducción","heading":"1.1 ¿Qué es la geocomputación?","text":"‘Geocomputación’ es un término joven, que se remonta la primera conferencia sobre el tema en 1996.1Lo que distingue la geocomputación del término comúnmente utilizado (en aquel momento) “geografía cuantitativa,” según propusieron sus primeros defensores, es su énfasis en las aplicaciones “creativas y experimentales” (P. . Longley et al. 1998) y en el desarrollo de nuevas herramientas y métodos (Openshaw Abrahart 2000):\n“La geocomputación consiste en utilizar los distintos tipos de geodatos y en desarrollar geoherramientas relevantes dentro del contexto general de un enfoque ‘científico’.”\nEste libro pretende ir más allá de la enseñanza de los métodos y el código; al final de él, deberías ser capaz de utilizar tus conocimientos de geocomputación para realizar “un trabajo práctico que sea beneficioso o útil” (Openshaw Abrahart 2000).Sin embargo, nuestro enfoque difiere de los primeros en adoptarlo, como Stan Openshaw, en su énfasis en la reproducibilidad y la colaboración.\nprincipios del siglo XXI, era realista esperar que los lectores pudieran reproducir los ejemplos de código, debido las barreras que impedían el acceso al hardware, el software y los datos necesarios.\nSi avanzamos dos décadas, las cosas han progresado rápidamente.\nCualquiera que tenga acceso un ordenador portátil con aproximadamente 4 GB de RAM puede esperar de forma realista poder instalar y ejecutar software de geocomputación sobre conjuntos de datos de acceso público, que están más disponibles que nunca (como veremos en el capítulo ??).2\ndiferencia de los primeros trabajos en este campo, todo el trabajo presentado en este libro es reproducible utilizando el código y los datos de ejemplo proporcionados junto con el libro, en paquetes de R como spData, cuya instalación se trata en el capítulo 2.La geocomputación está estrechamente relacionada con otros términos como: Ciencia de la Información Geográfica (GIScience); Geomática; Geoinformática; Ciencia de la Información Espacial; Ingeniería de la Geoinformación (P. Longley 2015); y Ciencia de los Datos Geográficos (GDS).\nTodos los términos comparten el énfasis en un enfoque “científico” (que implica que es reproducible y falsable) influenciado por los SIG, aunque sus orígenes y principales campos de aplicación difieren.\nLa GDS, por ejemplo, enfatiza las habilidades de la “ciencia de datos” y los grandes conjuntos de datos, mientras que la Geoinformática tiende centrarse en las estructuras de datos.\nPero los solapamientos entre los términos son mayores que las diferencias entre ellos y utilizamos la geocomputación como un sinónimo aproximado que los engloba todos:\ntodos tratan de utilizar los datos geográficos para el trabajo científico aplicado.\nSin embargo, diferencia de los primeros usuarios del término, pretendemos dar entender que existe un campo académico cohesionado llamado “Geocomputación” (o “GeoComputación,” como lo llamaba Stan Openshaw).\nEn cambio, definimos el término de la siguiente manera: trabajar con datos geográficos de forma computacional, centrándose en el código, la reproducibilidad y la modularidad.La geocomputación es un término reciente pero está influenciado por ideas antiguas.\nPuede considerarse parte de la Geografía, la cual tiene más de 2000 años de historia (Talbert 2014); y una extensión de los Sistemas de Información Geográfica (SIG) (Neteler Mitasova 2008), los cuales surgieron en la década de 1960 (Coppock Rhind 1991).Sin embargo, la geografía ha desempeñado un papel importante la hora de explicar e influir la relación de la humanidad con el mundo natural mucho antes de la invención del ordenador.\nLos viajes de Alexander von Humboldt Sudamérica principios del siglo XIX ilustran este papel:\nlas observaciones resultantes solo sentaron las bases de las tradiciones de la geografía física y vegetal, sino que también allanaron el camino hacia las políticas de protección del mundo natural (Wulf 2015).\nEste libro pretende contribuir la “Tradición Geográfica” (Livingstone 1992) aprovechando la potencia de los ordenadores modernos y el software de código abierto.Los vínculos del libro con disciplinas más antiguas se reflejaron en los títulos sugeridos para el libro: Geografía con R y R para SIG.\nCada uno tiene sus ventajas.\nEl primero transmite el mensaje de que comprende mucho más que datos espaciales:\nlos datos de atributos espaciales se entremezclan inevitablemente con los datos geométricos, y la Geografía trata de algo más que de dónde está algo en el mapa.\nEl segundo comunica que este un libro sobre el uso de R como un SIG, para realizar operaciones espaciales sobre datos geográficos (R. Bivand, Pebesma, Gómez-Rubio 2013).\nSin embargo, el término SIG transmite algunas connotaciones (véase la Tabla 1.1) que simplemente comunican una de las mayores fortalezas de R:\nsu capacidad basada en la consola para cambiar sin problemas entre las tareas de procesamiento, modelado y visualización de datos geográficos y geográficos.\nPor el contrario, el término geocomputación implica una programación reproducible y creativa.\nPor supuesto, los algoritmos (geocomputacionales) son herramientas poderosas que pueden llegar ser altamente complejas.\nSin embargo, todos los algoritmos se componen de partes más pequeñas.\nAl enseñarte sus fundamentos y su estructura subyacente, pretendemos capacitarte para crear tus propias soluciones innovadoras los problemas de datos geográficos.","code":""},{"path":"intro.html","id":"por-qué-usar-r-para-la-geocomputación","chapter":"1 Introducción","heading":"1.2 ¿Por qué usar R para la geocomputación?","text":"Los primeros geógrafos utilizaron diversas herramientas, como barómetros, brújulas y sextantes, para avanzar en el conocimiento del mundo (Wulf 2015). Solo con la invención del cronómetro marino en 1761 fue posible calcular la longitud en el mar, lo que permitió los barcos tomar rutas más directas.Hoy en día es difícil imaginar tal falta de datos geográficos.\nTodos los teléfonos inteligentes tienen un receptor de posicionamiento global (GPS) y una multitud de sensores en dispositivos que van desde satélites y vehículos semiautónomos hasta científicos ciudadanos que miden incesantemente cada parte del mundo.\nEl ritmo de producción de datos es abrumador.\nUn vehículo autónomo, por ejemplo, puede generar 100 GB de datos al día (Economist 2016).\nLos datos de teledetección de los satélites se han vuelto demasiado grandes para analizar los datos correspondientes con un solo ordenador, lo que ha dado lugar iniciativas como OpenEO.Esta “revolución de los geodatos” impulsa la demanda de equipos informáticos de alto rendimiento y de software eficientes y escalables para manejar y extraer la señal del ruido, con el fin de comprender y quizás cambiar el mundo.\nLas bases de datos espaciales permiten almacenar y generar subconjuntos manejables de los vastos almacenes de datos geográficos, haciendo que las interfaces para obtener conocimientos de ellos sean herramientas vitales para el futuro.\nR es una de esas herramientas, con capacidades avanzadas de análisis, modelización y visualización.\nEn este contexto, el libro se centra en el lenguaje en sí (véase Wickham 2014).\nEn su lugar, utilizamos R como una “herramienta para trabajar” para entender el mundo, de forma similar al uso que Humboldt hizo de las herramientas para obtener una comprensión profunda de la naturaleza en toda su complejidad e interconexiones (véase Wulf 2015).\nAunque la programación puede parecer una actividad reduccionista, el objetivo es enseñar geocomputación con R solo por diversión, sino para entender el mundo.R es un lenguaje y entorno de código abierto y multiplataforma para la computación estadística y los gráficos (r-project.org/).\nCon una amplia gama de paquetes, R también permite la estadística geoespacial avanzada, la modelización y la visualización.\n\nLos nuevos entornos de desarrollo integrados (IDE), como RStudio, han hecho que R sea más fácil de usar para muchos, facilitando la elaboración de mapas con un panel dedicado la visualización interactiva.En su esencia, R es un lenguaje de programación funcional orientado objetos (Wickham 2014), y fue diseñado específicamente como una interfaz interactiva para otro software (Chambers 2016).\nEste último también incluye muchos “puentes” hacia el hallazgo de un tesoro del software SIG, “geolibrerías” y funciones (véase el capítulo ??).\nPor tanto, es ideal para crear rápidamente “geoherramientas,” sin necesidad de dominar lenguajes de nivel inferior (en comparación con R) como C, FORTRAN o Java (véase la sección @ref(software-para-geocomputación)).\n\nEsto puede ser como liberarse del metafórico “techo de cristal” impuesto por los sistemas de información geográfica basados en GUI o patentados (véase la Tabla 1.1 para una definición de GUI).\nAdemás, R facilita el acceso otros lenguajes:\nlos paquetes Rcpp y reticulate permiten acceder código de C++ y Python, por ejemplo.\nEsto significa que R puede utilizarse como “puente” hacia una amplia gama de programas geoespaciales (véase la sección @ref(software-para-geocomputación)).Otro ejemplo que muestra la flexibilidad y la evolución de las capacidades geográficas de R es la elaboración de mapas interactivos.\nComo veremos en el Capítulo ??, la afirmación de que R tiene “facilidades interactivas [para elaborar gráficos] limitadas” (R. Bivand, Pebesma, Gómez-Rubio 2013) ya es cierta.\nAsí lo demuestra el siguiente fragmento de código, que crea la Figura 1.1 (las funciones que generan el gráfico se tratan en la Sección ??).\nFIGURE 1.1: Los marcadores azules indican la procedencia de los autores. El mapa base es una imagen en mosaico de la Tierra de noche proporcionada por la NASA. Interactúa con la versión en línea en geocompr.robinlovelace.net, por ejemplo, ampliando la imagen y haciendo clic en las ventanas emergentes.\nHace unos años habría sido difícil elaborar la Figura 1.1 con R, más aún en forma de mapa interactivo.\nEsto ilustra la flexibilidad de R y cómo, gracias desarrollos como knitr y leaflet, puede utilizarse como interfaz con otro software, un tema que se repetirá lo largo de este libro.\nEl uso del código de R, por tanto, permite enseñar geocomputación con referencia ejemplos reproducibles como el proporcionado en la Figura 1.1 en lugar de conceptos abstractos.","code":"\nlibrary(leaflet)\npopup = c(\"Robin\", \"Jakub\", \"Jannes\", \"Mireia\")\nleaflet() %>%\n  addProviderTiles(\"NASAGIBS.ViirsEarthAtNight2012\") %>%\n  addMarkers(c(-3, 23, 11, 2), c(52, 53, 49, 42), popup = popup)"},{"path":"intro.html","id":"software-para-geocomputación","chapter":"1 Introducción","heading":"1.3 Software para geocomputación","text":"R es un poderoso lenguaje para la geocomputación, pero hay muchas otras opciones para el análisis de datos geográficos que ofrecen miles de funciones geográficas.\nEl conocimiento de otros lenguajes para la geocomputación ayudará decidir cuándo una herramienta diferente puede ser más apropiada para una tarea específica, y situar R en el amplio ecosistema geoespacial.\nEsta sección presenta brevemente los lenguajes C++, Java y Python para la geocomputación, como preparación para el capítulo ??.Una importante característica de R (y de Python) es que es un lenguaje interpretado.\nEsto es ventajoso porque permite la programación interactiva en un bucle de lectura-evaluación-impresión (REPL):\nel código introducido en la consola se ejecuta inmediatamente y el resultado se imprime, en lugar de esperar la etapa intermedia de compilación. Por otra parte, los lenguajes compilados, como C++ y Java, tienden ejecutarse más rápidamente (una vez que han sido compilados).C++ proporciona la base de muchos paquetes SIG, como QGIS, GRASS y SAGA, por lo que es un punto de partida apropiado.\nEl C++ bien escrito es muy rápido, lo que lo convierte en una buena opción para aplicaciones de rendimiento crítico, como el procesamiento de grandes conjuntos de datos geográficos, pero es más difícil de aprender que Python o R.\nEl C++ se ha vuelto más accesible con el paquete Rcpp, el cual proporciona una buena ” vía de entrada ” la programación en C para los usuarios de R.\nEl dominio de estos lenguajes de bajo nivel abre la posibilidad de crear nuevos “geoalgoritmos” de alto rendimiento y de comprender mejor el funcionamiento del software SIG (véase el capítulo ??).Java es otro lenguaje importante y versátil para la geocomputación.\nLos paquetes de SIG gvSig, OpenJump y uDig están escritos en Java.\nHay muchas bibliotecas de SIG escritas en Java, como GeoTools y JTS, la Topología Suite de Java (GEOS es un puerto C++ de JTS).\nAdemás, muchas aplicaciones de servidores de mapas utilizan Java, como Geoserver/Geonode, deegree y 52°North WPS.La sintaxis orientada objetos de Java es similar la de C++.\nUna de las principales ventajas de Java es que es independiente de las plataformas (lo que es inusual para un lenguaje compilado) y es altamente escalable, lo cual lo convierte en un lenguaje adecuado para IDEs como RStudio, con el cual se ha escrito este libro.\nJava tiene menos herramientas para el modelado estadístico y la visualización que Python o R, aunque puede utilizarse para la ciencia de datos (Brzustowicz 2017).Python es un lenguaje importante para la geocomputación, especialmente porque muchos SIG de escritorio, como GRASS, SAGA y QGIS, proporcionan una API de Python (véase el capítulo ??).\nAl igual que R, es una herramienta popular para la ciencia de los datos.\nAmbos lenguajes están orientados objetos y tienen muchas áreas de solapamiento, lo cual ha llevado iniciativas como el paquete reticulate, que facilita el acceso Python desde R, y la iniciativa de Ursa Labs para apoyar las bibliotecas portátiles en beneficio de todo el ecosistema de ciencia de datos de código abierto.En la práctica, tanto R como Python tienen sus puntos fuertes y, hasta cierto punto, cuál de ellos se utiliza es menos importante que el ámbito de aplicación y la comunicación de los resultados.\nEl aprendizaje de cualquiera de los dos permite empezar aprender el otro.\nSin embargo, R tiene grandes ventajas sobre Python para la geocomputación.\nEntre ellas se encuentra el hecho de que soporta mucho mejor los modelos de datos geográficos vectoriales y rasterizados en el propio lenguaje (véase el capítulo 2) y las correspondientes posibilidades de visualización (véanse los capítulos 2 y ??).\nIgualmente importante es el hecho de que R tiene un soporte incomparable para la estadística, incluida la estadística espacial, con cientos de paquetes (diferencia de Python) que soportan miles de métodos estadísticos.La mayor ventaja de Python es que es un lenguaje de programación de propósito general.\nSe utiliza en muchos ámbitos, como el software de escritorio, los juegos de ordenador, los sitios web y la ‘ciencia de los datos’.\nPython es menudo el único lenguaje compartido entre diferentes comunidades (de geocomputación) y puede considerarse como el “pegamento” que mantiene unidos muchos programas de SIG.\nSe puede acceder muchos geoalgoritmos, incluidos los de QGIS y ArcMap, desde la línea de comandos de Python, lo que lo convierte en un lenguaje idóneo para iniciarse en los SIG de línea de comandos.3Sin embargo, para la estadística espacial y el modelado predictivo, R es considerablemente mejor.\nEsto significa que haya que elegir entre R o Python: Python soporta la mayoría de las técnicas estadísticas comunes (aunque R tiende soportar antes los nuevos desarrollos en estadística espacial) y muchos conceptos aprendidos en Python pueden aplicarse al mundo de R.\nAl igual que R, Python también soporta el análisis y la manipulación de datos geográficos con paquetes como osgeo, Shapely, NumPy y PyGeoProcessing (Garrard 2016).","code":""},{"path":"intro.html","id":"el-ecosistema-espacial-de-r","chapter":"1 Introducción","heading":"1.4 El ecosistema espacial de R","text":"Hay muchas maneras de manejar datos geográficos en R, con docenas de paquetes en el área.4\nEn este libro nos esforzamos por enseñar el estado del arte en el campo, al tiempo que nos aseguramos de que los métodos estén preparados para el futuro.\nAl igual que muchas áreas de desarrollo de software, el ecosistema espacial de R está evolucionando rápidamente (Figura 1.2).\nPuesto que R es de código abierto, estos desarrollos pueden construirse fácilmente partir de trabajos anteriores, “subiendo hombros de gigantes,” como dijo Isaac Newton en 1675.\nEste enfoque es ventajoso porque fomenta la colaboración y evita “reinventar la rueda.”\nEl paquete sf (tratado en el capítulo 2), por ejemplo, se basa en su predecesor sp.El aumento del tiempo de desarrollo (y del interés) en ‘R-spatial’ se ha producido tras la concesión de una subvención por parte del R Consortium para el desarrollo del soporte para Funciones Simples, un estándar y modelo de código abierto para almacenar y acceder geometrías vectoriales.\nEsto dio lugar al paquete sf (tratado en la sección 2.2.1).\nMúltiples sitios reflejan el inmenso interés por sf.\nEsto es especialmente cierto en el caso de los archivos de R-sig-Geo Archives, una lista de correos electrónicos en abierto que contiene mucha sabiduría de R-spatial acumulada lo largo de los años.\nFIGURE 1.2: La popularidad de los paquetes espaciales en R. El eje Y muestra el número medio de descargas por día, dentro de una ventana móvil de 30 días, de paquetes espaciales destacados.\nCabe destacar que los cambios en la comunidad de R en general, como por ejemplo el paquete de procesamiento de datos dplyr (publicado en 2014), han influido en los cambios del ecosistema espacial de R.\nJunto con otros paquetes que tienen un estilo compartido y un énfasis en los “datos ordenados” (“tidy data”) (incluyendo, por ejemplo, ggplot2), dplyr se colocó en el “metapaquete” tidyverse finales de 2016.El enfoque de tidyverse, centrado en los datos de forma larga y en las funciones rápidas de nombre intuitivo, se ha hecho inmensamente popular.\nEsto ha dado lugar una demanda de “datos geográficos ordenados” que ha sido satisfecha en parte por sf y otros enfoques como tabularaster.\nUna característica evidente del tidyverse es la tendencia que los paquetes trabajen en armonía.\nexiste un ‘geoverso’ equivalente, pero hay intentos de armonización entre los paquetes alojados en la organización r-spatial y el número creciente de paquetes que utilizan sf (Tabla 1.2).TABLE 1.2: Los 5 paquetes más descargados que dependen de sf, en términos de número medio de descargas por día durante el mes anterior. partir del 2021-08-22 hay 383 paquetes que importan sf.","code":""},{"path":"intro.html","id":"la-historia-de-r-spatial","chapter":"1 Introducción","heading":"1.5 La historia de R-spatial","text":"El uso de paquetes espaciales recientes como sf tiene muchas ventajas, pero también es importante ser consciente de la historia de las capacidades espaciales de R: muchas funciones, casos de uso y material didáctico están contenidos en paquetes más antiguos.\nEstos pueden seguir siendo útiles hoy en día, siempre que se sepa dónde buscar.\n\nLas capacidades espaciales de R se originaron en los primeros paquetes espaciales del lenguaje S (R. Bivand Gebhardt 2000).\n\nEn la década de 1990 se desarrollaron numerosos scripts en S y un puñado de paquetes para la estadística espacial.\nLos paquetes de R surgieron partir de ellos y en el año 2000 había paquetes de R para varios métodos espaciales “análisis de patrones puntuales, geoestadística, análisis exploratorio de datos espaciales y econometría espacial,” según un artículo presentado en GeoComputation 2000 (R. Bivand Neteler 2000).\nAlgunos de ellos, especialmente spatial, sgeostat y splancs, siguen estando disponibles en CRAN (B. S. Rowlingson Diggle 1993; B. Rowlingson Diggle 2017; Venables Ripley 2002; Majure Gebhardt 2016).Un artículo posterior en R News (el predecesor de R Journal) contenía una visión general del software estadístico espacial en R en ese momento, gran parte del cual se basaba en código anterior escrito para S/S-PLUS (Ripley 2001).\nEsta visión general describía paquetes para el suavizado y la interpolación espacial, incluyendo akima y geoR (Akima Gebhardt 2016; Jr Diggle 2016), y el análisis de patrones de puntos, incluyendo splancs (B. Rowlingson Diggle 2017) y spatstat (Baddeley, Rubak, Turner 2015).La siguiente publicación de R News (Volumen 1/3) volvió poner los paquetes espaciales en el punto de mira, con una introducción más detallada splancs y un comentario sobre las perspectivas futuras de la estadística espacial (R. Bivand 2001).\nAdemás, la publicación introdujo dos paquetes para probar la autocorrelación espacial que finalmente se convirtieron en parte de spdep (R. Bivand 2017).\nEn particular, el comentario menciona la necesidad de estandarizar las interfaces espaciales, los mecanismos eficientes para el intercambio de datos con SIG y el manejo de metadatos espaciales como los sistemas de referencia de coordenadas (CRS).maptools [escrito por Nicholas Lewin-Koh; R. Bivand Lewin-Koh (2017)] es otro paquete importante de esta época.\nInicialmente, maptools solo contenía una envoltura alrededor de shapelib y permitía la lectura de ESRI Shapefiles en listas anidadas de geometría.\nLa clase S3 correspondiente y hoy en día obsoleta llamada “Map” almacenaba esta lista junto un dataframe de atributos.\nEl trabajo sobre la representación de la clase “Map” fue, sin embargo, importante, ya que alimentó directamente sp antes de su publicación en CRAN.En 2003, Roger Bivand publicó una revisión extendida de los paquetes espaciales.\nPropuso un sistema de clases para soportar los “objetos de datos ofrecidos por GDAL”, incluyendo los tipos ‘fundamentales’ punto, línea, polígono y raster.\nAdemás, sugería que las interfaces con bibliotecas externas debían ser la base de los paquetes modulares de R (R. Bivand 2003).\nEn gran medida, estas ideas se materializaron en los paquetes rgdal y sp.\nEstos proporcionaron una base para el análisis de datos espaciales con R, tal como se describe en Análisis de datos espaciales aplicados con R (Applied Spatial Data Analysis R en inglés) (ASDAR) (R. Bivand, Pebesma, Gómez-Rubio 2013), publicado por primera vez en 2008.\nDiez años más tarde, las capacidades espaciales de R han evolucionado sustancialmente, pero siguen basándose en las ideas expuestas por Bivand (2003):\nlas interfaces para GDAL y PROJ, por ejemplo, siguen potenciando las capacidades de /O de datos geográficos de alto rendimiento y de transformación de CRS (véanse los capítulos ?? y ??, respectivamente).rgdal, publicado en 2003, proporcionó vínculos GDAL para R que mejoraron en gran medida su capacidad para importar datos de formatos de datos geográficos que antes estaban disponibles.\nLa versión inicial sólo admitía controladores raster, pero las mejoras posteriores proporcionaron soporte para sistemas de referencia de coordenadas (través de la librería PROJ), reproyecciones e importación de formatos de archivos vectoriales (véase el capítulo ?? para más información sobre los formatos de archivo).\nMuchas de estas capacidades adicionales fueron desarrolladas por Barry Rowlingson y publicadas en el código base de rgdal en 2006 (véase B. Rowlingson et al. 2003 y R-help(véase Rowlingson et al. 2003 y la lista de correos electrónicos de R-help para el contexto).sp, publicado en 2005, superó la incapacidad de R para distinguir entre los objetos espaciales y los espaciales (E. J. Pebesma Bivand 2005).\nsp surgió de un taller celebrado en Viena en 2003 y estuvo alojado en sourceforge antes de migrar R-Forge.\n\n\nAntes de 2005, las coordenadas geográficas se trataban generalmente como cualquier otro número.\nsp cambió esto con sus clases y métodos genéricos que soportan puntos, líneas, polígonos y cuadrículas, y datos de atributos.sp almacena información como el cuadro delimitador, el sistema de referencia de coordenadas y los atributos en ranuras de objetos espaciales que utilizan el sistema de clases S4, lo que permite que las operaciones de datos funcionen con datos geográficos (véase la sección @ref(por-qué-simple-features)).\nAdemás, sp proporciona métodos genéricos como summary() y plot() para datos geográficos.\nEn la década siguiente, las clases sp se popularizaron rápidamente para los datos geográficos en R y el número de paquetes que dependían de él se incrementó de unos 20 en 2008 más de 100 en 2013 (R. Bivand, Pebesma, Gómez-Rubio 2013).En 2018, casi 500 paquetes dependen de sp, lo que lo convierte en una parte importante del ecosistema de R.\nEntre los paquetes R más destacados que utilizan sp se encuentran: gstat, para geoestadística espacial y espacio-temporal; geosphere, para trigonometría esférica; y adehabitat, utilizado para el análisis de la selección de hábitat por parte de los animales (E. Pebesma Graeler 2018; Calenge 2006; Hijmans 2016).Mientras que rgdal y sp resolvían muchos problemas espaciales, R seguía careciendo de la capacidad de realizar operaciones geométricas (véase el capítulo ??).\nColin Rundel abordó este problema desarrollando rgeos, una interfaz de R para la librería de geometría en código abierto (GEOS) durante un proyecto de Google Summer Code en 2010 (R. Bivand Rundel 2018).\nrgeos permitió GEOS manipular objetos sp, con funciones como gIntersection().Otra limitación de sp — su limitado apoyo los datos raster — fue superada por raster, publicado por primera vez en 2010 (Hijmans 2017).\nSu sistema de clases y sus funciones soportan una serie de operaciones de rasterización, como se indica en la sección 2.3.\nUna característica clave de raster es su capacidad para trabajar con conjuntos de datos que son demasiado grandes para caber en la memoria RAM (la interfaz de R con PostGIS admite operaciones fuera del disco sobre datos geográficos vectoriales).\nraster también admite el álgebra de mapas (véase la sección ??).Paralelamente estos desarrollos de sistemas de clases y métodos, llegó el apoyo R como interfaz para el software SIG dedicado.\nGRASS (R. S. Bivand 2000) y los paquetes posteriores spgrass6 y rgrass7 (para GRASS GIS 6 y 7, respectivamente) fueron ejemplos destacados en esta dirección (R. Bivand 2016a, 2016b).\nOtros ejemplos de puentes entre R y SIG son RSAGA (Brenning, Bangs, Becker 2018, publicado por primera vez en 2008), RPyGeo (Brenning 2012, publicado por primera vez en 2008) y RQGIS (Muenchow, Schratz, Brenning 2017, publicado por primera vez en 2016) (véase el capítulo ??).La visualización fue un foco de atención al principio, ya que la mayor parte del desarrollo de R-spatial se centró en el análisis y las operaciones geográficas.\nsp proporcionó métodos para la elaboración de mapas utilizando el sistema de graficación de base y de lattice, pero la demanda estaba creciendo para las capacidades de elaboración de mapas avanzados, especialmente después del lanzamiento de ggplot2 en 2007.\nggmap amplió las capacidades espaciales de ggplot2 (Kahle Wickham 2013), facilitando el acceso los segmentos del “basemap” desde servicios en línea como Google Maps.\nAunque ggmap facilitaba la elaboración de mapas con ggplot2, su utilidad estaba limitada por la necesidad de fortificar los objetos espaciales, lo que significa convertirlos en largos dataframes.\nAunque esto funciona bien para los puntos, es computacionalmente ineficiente para las líneas y los polígonos, ya que cada coordenada (vértice) se convierte en una fila, lo que da lugar enormes dataframes para representar geometrías complejas.\nAunque la visualización geográfica tendía centrarse en los datos vectoriales, la visualización rasterizada está soportada en raster y recibió un impulso con el lanzamiento de rasterVis, el cual se describe en un libro sobre el tema de la visualización de datos espaciales y temporales (Lamigueiro 2018).\npartir de 2018, la creación de mapas en R es un tema candente con paquetes dedicados como tmap, leaflet y mapview, todos ellos compatibles con el sistema de clases proporcionado por sf, en el cual se centra el siguiente capítulo (véase el capítulo ?? para obtener más información sobre la visualización).","code":""},{"path":"intro.html","id":"ejercicios","chapter":"1 Introducción","heading":"1.6 Ejercicios","text":"","code":""},{"path":"spatial-class.html","id":"spatial-class","chapter":"2 Datos geográficos en R","heading":"2 Datos geográficos en R","text":"","code":""},{"path":"spatial-class.html","id":"prerrequisitos","chapter":"2 Datos geográficos en R","heading":"Prerrequisitos","text":"Este es el primer capítulo práctico del libro y, por lo tanto, conlleva algunos requisitos de software.\nSuponemos que ya tienes instalada una versión actualizada de R y que te sientes cómodo utilizando el software con una interfaz de línea de comandos como el entorno de desarrollo integrado (IDE) RStudio.\nSi eres nuevo en R, te recomendamos leer el capítulo 2 del libro en línea Efficient R Programming de Gillespie Lovelace (2016) y aprender los fundamentos del lenguaje con recursos como R Data Science de Grolemund Wickham (2016).\nOrganiza tu trabajo (por ejemplo, con proyectos de RStudio) y asigna los scripts nombres sensatos como 02-chapter.R para documentar el código que escribes medida que aprendes.\nLos paquetes utilizados en este capítulo pueden instalarse con los siguientes comandos:5Si estás trabajando con Mac o Linux, es posible que el comando anterior para instalar sf funcione la primera vez.\nEstos sistemas operativos () tienen “requisitos del sistema” que se describen en el README del paquete.\nSe pueden encontrar varias instrucciones específicas para cada en línea, como el artículo Instalación de R 4.0 en Ubuntu 20.04 (Installation R 4.0 Ubuntu 20.04 en inglés) en el blog rtask.thinkr.fr.Todos los paquetes necesarios para reproducir el contenido del libro se pueden instalar con el siguiente comando:\nremotes::install_github(\"geocompr/geocompkg\").\nLos paquetes necesarios se pueden “cargar” (técnicamente se adjuntan) con la función library() de la siguiente manera:La salida de library(sf) informa de las versiones de las bibliotecas geográficas clave (key geographic libraries), como GEOS, la cual ya está utilizando el paquete, como se indica en la Sección 2.2.1.Los demás paquetes instalados contienen datos que se utilizarán en el libro:","code":"\ninstall.packages(\"sf\")\ninstall.packages(\"terra\")\ninstall.packages(\"spData\")\ninstall.packages(\"spDataLarge\", repos = \"https://nowosad.r-universe.dev\")\nlibrary(sf)          # clases y funciones para datos vectoriales\n#> Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1; sf_use_s2() is TRUE\nlibrary(terra)      # clases y funciones para datos rasterizados\nlibrary(spData)        # cargar datos geográficos\nlibrary(spDataLarge)   # cargar datos geográficos de mayor tamaño"},{"path":"spatial-class.html","id":"intro-spatial-class","chapter":"2 Datos geográficos en R","heading":"2.1 Introducción","text":"En este capítulo se explicarán brevemente los modelos de datos geográficos fundamentales: vectorial y rasterizado.\nIntroduciremos la teoría detrás de cada modelo de datos y las disciplinas en las que predominan, antes de demostrar su implementación en R.El modelo de datos vectoriales representa el mundo mediante puntos, líneas y polígonos.\nEstos tienen bordes discretos y bien definidos, lo que significa que los conjuntos de datos vectoriales suelen tener un alto nivel de precisión (pero necesariamente exactitud, como veremos en el apartado 2.5).\nEl modelo de datos ráster divide la superficie en celdas de tamaño constante.\nLos conjuntos de datos ráster son la base de las imágenes de fondo utilizadas en la cartografía web y han sido una fuente vital de datos geográficos desde los orígenes de la fotografía aérea y los dispositivos de teledetección por satélite.\nLos rásteres agregan características espacialmente específicas una resolución determinada, lo que significa que son consistentes en el espacio y escalables (existen muchos conjuntos de datos ráster nivel mundial).¿Cuál utilizar?\nLa respuesta depende probablemente de su ámbito de aplicación:Los datos vectoriales tienden dominar las ciencias sociales porque los asentamientos humanos tienden tener fronteras discretasLos datos rasterizados predominan en las ciencias medioambientales debido la dependencia de los datos de teledetecciónEn algunos campos hay mucho solapamiento y los conjuntos de datos ráster y vectoriales pueden utilizarse conjuntamente:\nlos ecologistas y los demógrafos, por ejemplo, suelen utilizar tanto datos vectoriales como rasterizados.\nAdemás, es posible la conversión entre ambas formas (véase el capítulo ??).\nIndependientemente de si tu trabajo implica un mayor uso de los conjuntos de datos vectoriales o rasterizados, merece la pena comprender el modelo de datos subyacente antes de utilizarlos, como se explica en los capítulos siguientes.\nEste libro utiliza los paquetes sf y raster para trabajar con datos vectoriales y conjuntos de datos raster, respectivamente.","code":""},{"path":"spatial-class.html","id":"datos-vectoriales","chapter":"2 Datos geográficos en R","heading":"2.2 Datos vectoriales","text":"El modelo de datos vectoriales geográficos se basa en puntos situados dentro de un sistema de referencia de coordenadas (SRC, CRS en inglés).\nLos puntos pueden representar características autónomas (por ejemplo, la ubicación de una parada de autobús) o pueden estar vinculados entre sí para formar geometrías más complejas, como líneas y polígonos.\nLa mayoría de las geometrías de puntos contienen sólo dos dimensiones (los SRC tridimensionales contienen un valor \\(z\\) adicional, que suele representar la altura sobre el nivel del mar).En este sistema, Londres, por ejemplo, puede representarse con las coordenadas c(-0.1, 51.5).\nEsto significa que su ubicación es -0,1 grados al este y 51,5 grados al norte del origen.\nEn este caso, el origen se encuentra 0 grados de longitud (el Primer Meridiano o Meridiano de Greenwich) y 0 grados de latitud (Ecuador) en un SRC geográfico (‘lon/lat’) (Figura 2.1, panel izquierdo).\nEl mismo punto también podría aproximarse en un SRC proyectado con valores ‘Este/Norte’ de c(530000, 180000) en la British National Grid, lo que significa que Londres se encuentra 530 km al Este y 180 km al Norte del \\(origen\\) del SRC.\nEsto puede comprobarse visualmente: algo más de 5 ‘casillas’ -áreas cuadradas delimitadas por las líneas grises de la cuadrícula de 100 km de ancho- separan el punto que representa Londres del origen (Figura 2.1, panel derecho).La ubicación del origen de National Grid, en el mar más allá del Suroeste de la península, garantiza que la mayoría de las ubicaciones en el Reino Unido tengan valores positivos de Orientación y Longitud.6\nHay más aspectos sobre los SRC, como se describe en las secciones 2.4 y ??, pero, para los propósitos de esta sección, es suficiente saber que las coordenadas consisten en dos números que representan la distancia desde un origen, generalmente en \\(x\\) y luego \\(y\\) para las dimensiones.\nFIGURE 2.1: Ilustración de datos vectoriales (puntos) en los que la ubicación de Londres (la X roja) se representa con referencia un origen (el círculo azul). El gráfico de la izquierda representa un SRC geográfico con un origen 0° tanto para la longitud como para la latitud. El gráfico de la derecha representa un SRC proyectado con el origen situado en el mar al Suroeste peninsular.\nsf es un paquete que proporciona un sistema de clases para datos vectoriales geográficos.\nsf sólo sustituye sp, sino que también proporciona una interfaz de línea de comandos consistente para GEOS y GDAL, sustituyendo rgeos y rgdal (descritos en la Sección ??).\nEsta sección presenta las clases sf como preparación para los capítulos siguientes (los capítulos ?? y ?? cubren la interfaz de GEOS y GDAL, respectivamente).","code":""},{"path":"spatial-class.html","id":"intro-sf","chapter":"2 Datos geográficos en R","heading":"2.2.1 Introducción a Simple Features","text":"Simple Features (en ocasiones también llamado Simple feature access (SFA)) es un estándar abierto desarrollado y respaldado por el Open Geospatial Consortium (OGC), una organización sin ánimo de lucro cuyas actividades volveremos tratar en un capítulo posterior (en la sección ??).\n\nSimple Features es un modelo de datos jerárquico que representa una amplia gama de tipos de geometría.\nDe los 17 tipos de geometría que soporta la especificación, solo 7 se utilizan en la gran mayoría de las investigaciones geográficas (véase la figura 2.2);\nestos tipos de geometría básicos son totalmente compatibles con el paquete de R sf (E. Pebesma 2018).7\nFIGURE 2.2: Tipos de Simple Features compatibles con sf.\nsf puede representar todos los tipos de geometría vectorial comunes (las clases de datos rasterizados son soportadas por sf): puntos, líneas, polígonos y sus respectivas versiones ‘multi’ (que agrupan elementos del mismo tipo en una sola función).\n\n\nsf también soporta colecciones geométricas, las cuales pueden contener múltiples tipos de geometrías en un solo objeto.\nsf proporciona la misma funcionalidad (y más) que previamente se ofrecía en tres paquetes: sp para las clases de datos (E. Pebesma Bivand 2018), rgdal para la lectura/escritura de datos través de una interfaz para GDAL y PROJ (R. Bivand, Keitt, Rowlingson 2018) y rgeos para las operaciones espaciales través de una interfaz para GEOS (R. Bivand Rundel 2018).\nPara reiterar el mensaje del capítulo 1, los paquetes geográficos de R tienen una larga historia de interfaces con librerías de bajo nivel, y sf mantiene esta tradición con una interfaz unificada con versiones recientes de la librería GEOS para operaciones geométricas, la librería GDAL para leer y escribir archivos de datos geográficos, y la librería PROJ para representar y transformar sistemas de referencia de coordenadas proyectadas.\nEste es un logro notable que reduce el espacio necesario para ‘cambiar de contexto’ entre diferentes paquetes y permite el acceso librerías geográficas de alto rendimiento.\nLa documentación sobre sf puede encontrarse en su sitio web y en 6 ‘viñetas,’ que pueden cargarse de la siguiente manera:Como se explica en la primera viñeta, los objetos ‘Simple Feature’ en R se almacenan en un marco de datos, con los datos geográficos ocupando una columna especial, normalmente llamada ‘geom’ o ‘geometry.’\nUtilizaremos el conjunto de datos world proporcionado por el paquete spData, cargado al principio de este capítulo (véase nowosad.github.io/spData para ver una lista de conjuntos de datos cargados por el paquete).\nworld es un objeto espacial que contiene columnas espaciales y atributos, cuyos nombres son devueltos por la función names() (la última columna contiene la información geográfica):El contenido de la columna geom proporciona los objetos sf sus poderes espaciales: world$geom es una ‘columna lista’ que contiene todas las coordenadas de los polígonos de cada uno de los países.\n\nEl paquete sf proporciona un método plot() para visualizar los datos geográficos:\nel siguiente comando crea la Figura 2.3.\nFIGURE 2.3: Un gráfico espacial del mundo utilizando el paquete sf, con un panel por cada atributo del conjunto de datos.\nObserva que en lugar de crear un único mapa, como harían la mayoría de los programas SIG, el comando plot() ha creado múltiples mapas, uno para cada variable en los conjuntos de datos de world.\nEste procedimiento puede ser útil para explorar la distribución espacial de diferentes variables y se trata más adelante, en la sección 2.2.3.Poder tratar los objetos espaciales como marcos de datos ordinarios pero con poderes espaciales tiene muchas ventajas, especialmente si ya estás acostumbrado trabajar con marcos de datos.\nLa función summary(), por ejemplo, proporciona una útil visión general de las variables dentro del objeto world.Aunque sólo hemos seleccionado una variable para el comando summary, éste también emite un informe sobre la geometría.\nEsto demuestra el comportamiento “pegajoso” de las columnas con geometrías de los objetos sf, lo que significa que los datos geométricos se mantienen menos que el usuario las elimine deliberadamente, como veremos en la sección @ref(Manipulación-de-atributos-vectoriales).\nEl resultado proporciona un rápido resumen de los datos espaciales y espaciales contenidos en world: la media de la esperanza de vida es de 71 años (oscilando entre menos de 51 y más de 83 años, con una mediana de 73 años) en todos los países.Merece la pena profundizar en el comportamiento y el contenido básicos de este objeto Simple feature, que puede considerarse útilmente como un ‘marco de datos espaciales’ (‘Spatial data frame’ en inglés).Los objetos sf son fáciles de subdividir.\nEl código siguiente muestra sus dos primeras filas y tres columnas.\nEl resultado muestra dos diferencias importantes en comparación con un data.frame normal: la inclusión de datos geográficos adicionales (tipo de geometría, dimensión, bbox e información SRC - epsg (SRID), proj4string), y la presencia de una columna de geometría, aquí denominada geom:Todo esto puede parecer bastante complejo, especialmente para un sistema de clases que se supone que es sencillo.\nSin embargo, hay buenas razones para organizar las cosas de esta manera y utilizar sf.Antes de describir cada tipo de geometría que permite el paquete sf, vale la pena dar un paso atrás para entender los bloques de construcción de los objetos sf.\nLa sección 2.2.8 muestra cómo los objetos Simple features son marcos de datos, con columnas especiales de geometría.\nEstas columnas espaciales suelen llamarse geom o geometry: world$geom se refiere al elemento espacial del objeto world descrito previamente.\nEstas columnas de geometría son ‘columnas lista’ de la clase sfc (véase el apartado 2.2.7).\nsu vez, los objetos sfc (Simple Feature geometry list-Column) se componen de uno o varios objetos de la clase sfg (Simple Feature Geometries): geometrías simples que se describen en la sección 2.2.6.\n\nPara entender cómo funcionan los componentes espaciales de simple features, es vital entender las geometrías simples (sfg).\nPor este motivo, en el apartado 2.2.5 se tratan todos los tipos de sfg actualmente admitidos, antes de pasar describir cómo pueden representarse en R partir de objetos sfg, los cuales constituyen las bases de los objetos sfc y, eventualmente, la totalidad de los objetos sf.","code":"\nvignette(package = \"sf\") # ver qué viñetas están disponibles\nvignette(\"sf1\")          # introducción al paquete\nnames(world)\n#>  [1] \"iso_a2\"    \"name_long\" \"continent\" \"region_un\" \"subregion\" \"type\"     \n#>  [7] \"area_km2\"  \"pop\"       \"lifeExp\"   \"gdpPercap\" \"geom\"\nplot(world)\nsummary(world[\"lifeExp\"])\n#>     lifeExp                geom    \n#>  Min.   :50.6   MULTIPOLYGON :177  \n#>  1st Qu.:65.0   epsg:4326    :  0  \n#>  Median :72.9   +proj=long...:  0  \n#>  Mean   :70.9                      \n#>  3rd Qu.:76.8                      \n#>  Max.   :83.6                      \n#>  NA's   :10\nworld_mini = world[1:2, 1:3]\nworld_mini\n#> Simple feature collection with 2 features and 3 fields\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -180 ymin: -18.3 xmax: 180 ymax: -0.95\n#> Geodetic CRS:  WGS 84\n#> # A tibble: 2 × 4\n#>   iso_a2 name_long continent                                                geom\n#>   <chr>  <chr>     <chr>                                      <MULTIPOLYGON [°]>\n#> 1 FJ     Fiji      Oceania   (((-180 -16.6, -180 -16.5, -180 -16, -180 -16.1, -…\n#> 2 TZ     Tanzania  Africa    (((33.9 -0.95, 31.9 -1.03, 30.8 -1.01, 30.4 -1.13,…"},{"path":"spatial-class.html","id":"por-qué-simple-features","chapter":"2 Datos geográficos en R","heading":"2.2.2 ¿Por qué Simple Features?","text":"Simple features es un modelo de datos ampliamente aceptado que subyace en las estructuras de datos de muchas aplicaciones SIG, incluyendo QGIS y PostGIS.\nUna de las principales ventajas es que el uso del modelo de datos garantiza la transferencia de tu trabajo otras configuraciones, por ejemplo, importar desde y exportar hacia otras bases de datos espaciales.\nUna pregunta más específica desde la perspectiva de R es “¿por qué utilizar el paquete sf cuando sp ya está probado y comprobado?” Hay muchas razones (relacionadas con las ventajas del modelo Simple features):Lectura y escritura rápida de datosMejora del rendimiento de los gráficosLos objetos sf pueden ser tratados como marcos de datos en la mayoría de las operacionesLas funciones sf pueden combinarse mediante el operador %>% y funcionan bien con la colección tidyverse de paquetes RLos nombres de las funciones sf son relativamente coherentes e intuitivos (todos comienzan por st_)Debido estas ventajas, algunos paquetes espaciales (como tmap, mapview y tidycensus) han añadido compatibilidades con sf.\nSin embargo, la mayoría de los paquetes tardarán muchos años en hacer la transición y algunos nunca la harán.\nAfortunadamente, éstos aún pueden seguir utilizándose en un flujo de trabajo basado en objetos sf, convirtiéndolos la clase Spatial utilizada en sp:Los objetos espaciales pueden volver convertirse en sf de la misma manera o con st_as_sf():","code":"\nlibrary(sp)\nworld_sp = as(world, Class = \"Spatial\")\n# sp functions ...\nworld_sf = st_as_sf(world_sp)"},{"path":"spatial-class.html","id":"basic-map","chapter":"2 Datos geográficos en R","heading":"2.2.3 Elaboración de un mapa básico","text":"Los mapas básicos pueden crearse en sf con plot().\nPor defecto, esto crea un gráfico compuesto de varios paneles (como spplot() de sp), un sub-gráfico para cada variable del objeto, como se ilustra en el panel de la izquierda en la Figura 2.4.\nSe produce una leyenda o “clave” con una paleta de colores continua si el objeto que se va trazar tiene una sola variable (véase el panel de la derecha).\nLos colores también pueden establecerse con col =, aunque esto creará una paleta continua ni una leyenda.\n\nFIGURE 2.4: Gráficos con sf, con múltiples variables (izquierda) y con una única variable (derecha).\nLos gráficos se añaden como capas las imágenes existentes estableciendo add = TRUE.8\nPara demostrar esto, y para proporcionar una muestra del contenido cubierto en los capítulos 3 y ?? sobre las operaciones de atributos y datos espaciales, el siguiente fragmento de código combina países de Asia:Ahora podemos representar el continente asiático sobre un mapa del mundo.\nTen en cuenta que el primer gráfico sólo debe tener una variable para que add = TRUE funcione.\nSi el primer gráfico tiene una leyenda, debe usarse reset = FALSE (el resultado se muestra):Añadir capas de esta manera puede servir para verificar la correspondencia geográfica entre capas: la función plot() es rápida de ejecutar y requiere pocas líneas de código, pero crea mapas interactivos con una amplia gama de opciones.\nPara la creación de mapas más avanzados, recomendamos utilizar paquetes de visualización dedicados ello, como tmap (véase el capítulo ??).","code":"\n\nplot(world[3:6])\nplot(world[\"pop\"])\nworld_asia = world[world$continent == \"Asia\", ]\nasia = st_union(world_asia)\nplot(world[\"pop\"], reset = FALSE)\nplot(asia, add = TRUE, col = \"red\")"},{"path":"spatial-class.html","id":"base-args","chapter":"2 Datos geográficos en R","heading":"2.2.4 Argumentos básicos de plot()","text":"Hay varias formas de modificar los mapas con el método plot() de sf.\nDado que sf amplía los métodos de representación gráfica básicos de R, los argumentos de plot() como main = (que especifica el título del mapa) funcionan con los objetos sf (véase ?graphics::plot y ?par).9\n\nLa figura 2.5 ilustra esta flexibilidad superponiendo círculos, cuyos diámetros (fijados con cex =) representan las poblaciones de los países, en un mapa del mundo.\nSe puede crear una versión proyectada de esta figura con los siguientes comandos (véanse los ejercicios al final de este capítulo y el script 02-contplot.R para reproducir la Figura 2.5):\nFIGURE 2.5: Continentes por países (representados por colores) y poblaciones de 2015 (representadas por círculos, con área proporcional su población).\nEl código anterior utiliza la función st_centroid() para convertir un tipo de geometría (polígonos) en otra (puntos) (véase el capítulo ??), cuya estética se modifica mediante el argumento cex.\nEl método de graficación de sf también tiene argumentos específicos para los datos geográficos. expandBB, por ejemplo, puede usarse para representar un objeto sf en su contexto:\ntoma un vector numérico de longitud cuatro que expande el contorno del gráfico relativo cero en el siguiente orden: abajo, izquierda, arriba, derecha.\nEsto se utiliza para dibujar India en el contexto de sus gigantescos vecinos asiáticos, con énfasis en China al este, en el siguiente fragmento de código, que genera la Figura 2.6 (véanse los ejercicios más adelante sobre la adición de texto los gráficos):\nFIGURE 2.6: India en su contexto, mostrando el resultado del argumento expandBB.\nNótese el uso de [0] para mantener sólo la columna de geometría y lwd para enfatizar India.\nVéase la sección ?? para otras técnicas de visualización para representar distintos tipos de geometrías, el tema de la siguiente sección.","code":"\nplot(world[\"continent\"], reset = FALSE)\ncex = sqrt(world$pop) / 10000\nworld_cents = st_centroid(world, of_largest = TRUE)\nplot(st_geometry(world_cents), add = TRUE, cex = cex)\nindia = world[world$name_long == \"India\", ]\nplot(st_geometry(india), expandBB = c(0, 0.2, 0.1, 1), col = \"gray\", lwd = 3)\nplot(world_asia[0], add = TRUE)"},{"path":"spatial-class.html","id":"geometry","chapter":"2 Datos geográficos en R","heading":"2.2.5 Tipos de geometrías","text":"Las geometrías son los componentes básicos de Simple features.\nSimple features en R pueden adoptar uno de los 17 tipos de geometría compatibles con el paquete sf.\n\n\nEn este capítulo nos centraremos en los siete tipos más utilizados: PUNTO, LÍNEA, POLÍGONO, MULTIPUNTO, MULTILÍNEA, MULTIPOLÍGONO y COLECCIÓN GEOMÉTRICA.\nEncontrarás la lista completa de tipos disponibles en el manual de PostGIS.Por lo general, la codificación estándar para Simple features es la binaria conocida (well-known binary en inglés (WKB)) o el texto conocido (well-known text en inglés (WKT)).\n\n\n\nLas representaciones de WKB suelen ser cadenas hexadecimales fácilmente legibles para los ordenadores.\nPor ello, los SIG y las bases de datos espaciales utilizan WKB para transferir y almacenar objetos geométricos.\nWKT, por otra parte, es una descripción de texto legible para el ser humano de Simple features.\nAmbos formatos son intercambiables, y si debemos presentar uno, naturalmente elegiremos la representación WKT.Las bases de cada tipo de geometría son los puntos.\nUn punto es simplemente una coordenada en el espacio 2D, 3D o 4D (véase vignette(\"sf1\") para más información) así como (véase el panel izquierdo de la figura 2.7):\nPOINT (5 2)\nUna cadena de líneas es una secuencia de puntos con una línea recta que los une, por ejemplo (véase el panel central de la figura 2.7):LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)Un polígono es una secuencia de puntos que forman un anillo cerrado y sin intersecciones.\nCerrado significa que el primer y el último punto de un polígono tienen las mismas coordenadas (véase el panel derecho de la figura 2.7).[\nPor definición, un polígono tiene un límite exterior (anillo exterior) y puede tener cero o más límites interiores (anillos interiores), también conocidos como agujeros.\nUn polígono con agujeros serían, por ejemplo, POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4))]\nPolígono cerrado: POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))\nFIGURE 2.7: Ilustración de geometrías de puntos, líneas y polígonos.\nHasta ahora hemos creado geometrías con una sola entidad geométrica por objeto.\nSin embargo, sf también permite la existencia de múltiples geometrías dentro de un único elemento (de ahí el término “colección de geometrías”) utilizando la versión “multi” de cada tipo de geometría:\nMultipunto: MULTIPOINT (5 2, 1 3, 3 4, 3 2)Multilínea: MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))Multipolígono: MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5), (0 2, 1 2, 1 3, 0 3, 0 2)))\nFIGURE 2.8: Illustration multi* geometries.\nPor último, una colección de geometrías puede contener cualquier combinación de geometrías, incluidos (multi)puntos y cadenas de líneas (véase la figura 2.9):\nColección de geometrías: GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2), LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))\nFIGURE 2.9: Ilustración de una colección de geometrías.\n","code":""},{"path":"spatial-class.html","id":"sfg","chapter":"2 Datos geográficos en R","heading":"2.2.6 Geometrías de Simple features (sfg)","text":"La clase sfg (Simple feature geometry en inglés) representa los diferentes tipos de geometrías de Simple features en R: punto, línea, polígono (y sus equivalentes ‘multi,’ como multipuntos) o colección de geometrías.\nPor lo general, te ahorras la tediosa tarea de crear geometrías por tu cuenta, ya que puedes simplemente importar un archivo espacial ya existente.\nSin embargo, existe un conjunto de funciones para crear objetos sfg desde cero si es necesario.\nLos nombres de estas funciones son sencillos y coherentes, ya que todas comienzan con el prefijo st_ y terminan con el nombre del tipo de geometría en minúsculas:Punto: st_point()Línea: st_linestring()Polígono: st_polygon()Multipunto: st_multipoint()Multilínea: st_multilinestring()Multipolígono: st_multipolygon()Colección geométrica: st_geometrycollection()Los objetos sfg pueden crearse partir de tres tipos de datos básicos de R:Un vector numérico: un solo puntoUna matriz: un conjunto de puntos, donde cada fila representa un punto, un multipunto o una líneaUna lista: una colección de objetos como matrices, multilíneas o colecciones de geometríasLa función st_point() crea puntos únicos partir de vectores numéricos:Los resultados muestran que los tipos de punto XY (coordenadas 2D), XYZ (coordenadas 3D) y XYZM (3D con una variable adicional, normalmente la precisión de la medición) se crean partir de vectores de longitud 2, 3 y 4, respectivamente.\nEl tipo XYM debe especificarse mediante el argumento dim (que es la abreviatura de dimensión).Por el contrario, utiliza matrices en el caso de los objetos multipunto (st_multipoint()) y en líneas (st_linestring()):Por último, utiliza listas para la creación de multilíneas, (multi)polígonos y colecciones de geometrías:","code":"\nst_point(c(5, 2))                 # XY point\n#> POINT (5 2)\nst_point(c(5, 2, 3))              # XYZ point\n#> POINT Z (5 2 3)\nst_point(c(5, 2, 1), dim = \"XYM\") # XYM point\n#> POINT M (5 2 1)\nst_point(c(5, 2, 3, 1))           # XYZM point\n#> POINT ZM (5 2 3 1)\n# la función rbind simplifica la creación de matrices\n## MULTIPUNTO\nmultipoint_matrix = rbind(c(5, 2), c(1, 3), c(3, 4), c(3, 2))\nst_multipoint(multipoint_matrix)\n#> MULTIPOINT ((5 2), (1 3), (3 4), (3 2))\n## LÍNEA\nlinestring_matrix = rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2))\nst_linestring(linestring_matrix)\n#> LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)\n## POLÍGONO\npolygon_list = list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))\nst_polygon(polygon_list)\n#> POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))\n## POLÍGONO no cerrado\npolygon_border = rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))\npolygon_hole = rbind(c(2, 4), c(3, 4), c(3, 3), c(2, 3), c(2, 4))\npolygon_with_hole_list = list(polygon_border, polygon_hole)\nst_polygon(polygon_with_hole_list)\n#> POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4))\n## MULTILÍNEA\nmultilinestring_list = list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), \n                            rbind(c(1, 2), c(2, 4)))\nst_multilinestring((multilinestring_list))\n#> MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))\n## MULTIPOLÍGONO\nmultipolygon_list = list(list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))),\n                         list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2))))\nst_multipolygon(multipolygon_list)\n#> MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5)), ((0 2, 1 2, 1 3, 0 3, 0 2)))\n## COLECCIÓN GEOMÉTRICA\ngemetrycollection_list = list(st_multipoint(multipoint_matrix),\n                              st_linestring(linestring_matrix))\nst_geometrycollection(gemetrycollection_list)\n#> GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2),\n#>   LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))"},{"path":"spatial-class.html","id":"sfc","chapter":"2 Datos geográficos en R","heading":"2.2.7 Columnas de simple features (sfc)","text":"Un objeto sfg contiene una sola geometría de Simple feature.\nUna columna de simple feature (Simple feature column en inglés (sfc)) es una lista de objetos sfg, que además puede contener información sobre el sistema de referencia de coordenadas en uso.\nPor ejemplo, para combinar dos objetos simple feature en un objeto con dos elementos, podemos utilizar la función st_sfc().\n\nEsto es importante puesto que sfc representa la columna de geometría en los marcos de datos sf:En la mayoría de los casos, un objeto sfc contiene objetos del mismo tipo de geometría.\nPor lo tanto, cuando convirtamos objetos sfg de tipo polígono en una columna de sfg, acabaríamos también con un objeto sfc de tipo polígono, lo cual puede verificarse con st_geometry_type().\nIgualmente, una columna de geometría de multilíneas resultaría en un objeto sfc de tipo multilíneas:También es posible crear un objeto sfc partir de objetos sfg con diferentes tipos de geometrías:Como se ha mencionado anteriormente, los objetos sfc pueden almacenar adicionalmente información sobre los sistemas de referencia de coordenadas (SRC).\nPara especificar un determinado SRC, podemos utilizar los atributos epsg (SRID) o proj4string de un objeto sfc.\nEl valor por defecto de epsg (SRID) y proj4string es NA (disponible o Available en inglés), como se puede comprobar con st_crs():Todas las geometrías de un objeto sfc deben tener el mismo SRC.\nPodemos añadir el sistema de referencia de coordenadas como argumento crs de st_sfc().\nEste argumento acepta un número entero con el código epsg como 4326, el cual añade automáticamente el ‘proj4string’ (véase la sección 2.4):También acepta un proj4string sin procesar (el resultado se muestra):","code":"\n# PUNTO sfc \npoint1 = st_point(c(5, 2))\npoint2 = st_point(c(1, 3))\npoints_sfc = st_sfc(point1, point2)\npoints_sfc\n#> Geometry set for 2 features \n#> Geometry type: POINT\n#> Dimension:     XY\n#> Bounding box:  xmin: 1 ymin: 2 xmax: 5 ymax: 3\n#> CRS:           NA\n#> POINT (5 2)\n#> POINT (1 3)\n# POLÍGONO sfc \npolygon_list1 = list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))\npolygon1 = st_polygon(polygon_list1)\npolygon_list2 = list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2)))\npolygon2 = st_polygon(polygon_list2)\npolygon_sfc = st_sfc(polygon1, polygon2)\nst_geometry_type(polygon_sfc)\n#> [1] POLYGON POLYGON\n#> 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n# MULTILÍNEA sfc \nmultilinestring_list1 = list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), \n                            rbind(c(1, 2), c(2, 4)))\nmultilinestring1 = st_multilinestring((multilinestring_list1))\nmultilinestring_list2 = list(rbind(c(2, 9), c(7, 9), c(5, 6), c(4, 7), c(2, 7)), \n                            rbind(c(1, 7), c(3, 8)))\nmultilinestring2 = st_multilinestring((multilinestring_list2))\nmultilinestring_sfc = st_sfc(multilinestring1, multilinestring2)\nst_geometry_type(multilinestring_sfc)\n#> [1] MULTILINESTRING MULTILINESTRING\n#> 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n# GEOMETRÍA sfc \npoint_multilinestring_sfc = st_sfc(point1, multilinestring1)\nst_geometry_type(point_multilinestring_sfc)\n#> [1] POINT           MULTILINESTRING\n#> 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\nst_crs(points_sfc)\n#> Coordinate Reference System: NA\n# definición EPSG \npoints_sfc_wgs = st_sfc(point1, point2, crs = 4326)\nst_crs(points_sfc_wgs)\n#> Coordinate Reference System:\n#>   User input: EPSG:4326 \n#>   wkt:\n#> GEOGCRS[\"WGS 84\",\n#>     DATUM[\"World Geodetic System 1984\",\n#>         ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n#>             LENGTHUNIT[\"metre\",1]]],\n#>     PRIMEM[\"Greenwich\",0,\n#>         ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>     CS[ellipsoidal,2],\n#>         AXIS[\"geodetic latitude (Lat)\",north,\n#>             ORDER[1],\n#>             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>         AXIS[\"geodetic longitude (Lon)\",east,\n#>             ORDER[2],\n#>             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>     USAGE[\n#>         SCOPE[\"unknown\"],\n#>         AREA[\"World\"],\n#>         BBOX[-90,-180,90,180]],\n#>     ID[\"EPSG\",4326]]\n# definición PROJ4STRING \nst_sfc(point1, point2, crs = \"+proj=longlat +datum=WGS84 +no_defs\")"},{"path":"spatial-class.html","id":"sf","chapter":"2 Datos geográficos en R","heading":"2.2.8 La clase sf","text":"Los apartados 2.2.5 2.2.7 tratan de objetos puramente geométricos, ‘sf geometry’ y ‘sf column’ respectivamente.\nEstos son bloques de construcción geográficos de datos vectoriales geográficos representados como simple features.\nEl último bloque de construcción son los atributos geográficos, los cuales representan el nombre de la función u otros atributos como los valores medidos, los grupos y otras cosas.\nPara ilustrar los atributos, representaremos una temperatura de 25°C en Londres el 21 de junio de 2017.\nEste ejemplo contiene una geometría (las coordenadas), y tres atributos con tres clases diferentes (nombre del lugar, temperatura y fecha).10\nLos objetos de clase sf representan esos datos combinando los atributos (data.frame) con la columna de geometrías simple (sfc).\nÉstos son creados con st_sf() como se ilustra continuación, lo cual crea el ejemplo de Londres descrito anteriormente:¿Qué ha pasado? En primer lugar, las coordenadas se utilizaron para crear la geometría simple feature (sfg).\nEn segundo lugar, la geometría se convirtió en una columna de geometrías simple feature (sfc), con un SRC.\nEn tercer lugar, los atributos se almacenaron en un data.frame, que se combinó con el objeto sfc con st_sf().\nEsto da como resultado un objeto sf, como se demuestra continuación (se omiten algunos resultados):El resultado muestra que los objetos sf tienen en realidad dos clases, sf y data.frame.\nsf son simplemente marcos de datos (tablas cuadradas), pero con atributos espaciales almacenados en una columna con forma de lista, normalmente llamada geometría, como se describe en el apartado 2.2.1.\nEsta dualidad es fundamental para el concepto de simple features:\nla mayoría de las veces, un sf puede tratarse y comportarse como un data.frame.\nSimple features son, en esencia, marcos de datos con una extensión espacial.","code":"\nlnd_point = st_point(c(0.1, 51.5))                 # objeto sfg \nlnd_geom = st_sfc(lnd_point, crs = 4326)           # objeto sfc \nlnd_attrib = data.frame(                           # objeto data.frame \n  name = \"London\",\n  temperature = 25,\n  date = as.Date(\"2017-06-21\")\n  )\nlnd_sf = st_sf(lnd_attrib, geometry = lnd_geom)    # objeto sf \nlnd_sf\n#> Simple feature collection with 1 features and 3 fields\n#> ...\n#>     name temperature       date         geometry\n#> 1 London          25 2017-06-21 POINT (0.1 51.5)\nclass(lnd_sf)\n#> [1] \"sf\"         \"data.frame\""},{"path":"spatial-class.html","id":"datos-rasterizados","chapter":"2 Datos geográficos en R","heading":"2.3 Datos rasterizados","text":"El modelo de datos espaciales rasterizados representa el mundo con la cuadrícula continua de celdas (menudo también llamadas píxeles; 2.10:).\nEste modelo de datos suele referirse las llamadas cuadrículas regulares, en las que cada celda tiene el mismo tamaño constante, y en este libro nos centraremos únicamente en las cuadrículas regulares.\nSin embargo, existen otros tipos de cuadrículas, como las cuadrículas rotadas, cizalladas, rectilíneas y curvilíneas (véase el capítulo 1 de E. Pebesma Bivand (2022) o el capítulo 2 de Tennekes Nowosad (2022))).El modelo de datos ráster suele consistir en una cabecera ráster\ny una matriz (con filas y columnas) que representa celdas igualmente espaciadas (menudo también llamadas píxeles; Figura 2.10:).11\nLa cabecera ráster define el sistema de referencia de coordenadas, la extensión y el origen.\n\n\nEl origen (o punto de partida) suele ser la coordenada de la esquina inferior izquierda de la matriz (el paquete terra, sin embargo, utiliza la esquina superior izquierda, por defecto (Figura 2.10:B)).\nLa cabecera define la extensión mediante el número de columnas, el número de filas y la resolución del tamaño de las celdas.\nPor lo tanto, partiendo del origen, podemos acceder fácilmente cada celda y modificarla utilizando su ID (Figura 2.10:B) o especificando explícitamente las filas y las columnas.\nEsta representación matricial evita almacenar explícitamente las coordenadas de los cuatro puntos de las esquinas (de hecho, sólo almacena una coordenada, el origen) de cada celda, como ocurriría con los polígonos vectoriales rectangulares.\nEsto y el álgebra de mapas (apartado (map-algebra)) hacen que el procesamiento de rásters sea mucho más eficiente y rápido que el de datos vectoriales.\nSin embargo, diferencia de los datos vectoriales, la celda de una capa ráster sólo puede contener un único valor. El valor puede ser numérico o categórico (Figura 2.10:C).\nFIGURE 2.10: Tipos de datos ráster: () IDs de celdas, (B) valores de celdas, (C) un mapa raster coloreado.\nLos mapas ráster suelen representar fenómenos continuos como la elevación, la temperatura, la densidad de población o los datos espectrales (Figura 2.11).\nPor supuesto, también podemos representar características discretas, como las clases de suelo o de cobertura del suelo, con la ayuda de un modelo de datos raster (Figura 2.11).\nEn consecuencia, los límites discretos de estas características se difuminan y, dependiendo de la tarea espacial, podría ser más adecuada una representación vectorial.\nFIGURE 2.11: Ejemplos de rásters continuos y categóricos.\n","code":""},{"path":"spatial-class.html","id":"paquetes-de-r-para-el-manejo-de-datos-rasterizados","chapter":"2 Datos geográficos en R","heading":"2.3.1 Paquetes de R para el manejo de datos rasterizados","text":"","code":""},{"path":"spatial-class.html","id":"introducción-a-terra","chapter":"2 Datos geográficos en R","heading":"2.3.2 Introducción a terra","text":"El paquete terra soporta objetos raster en R.\nProporciona un amplio conjunto de funciones para crear, leer, exportar, manipular y procesar conjuntos de datos raster.\nAparte de la manipulación general de datos ráster, terra proporciona muchas funciones de bajo nivel que pueden constituir la base para desarrollar una funcionalidad ráster más avanzada.\n\nterra también permite trabajar con grandes conjuntos de datos ráster que son demasiado grandes para caber en una memoria principal.\nEn este caso, terra ofrece la posibilidad de dividir el raster en fragmentos más pequeños, y los procesa iterativamente en lugar de cargar todo el archivo raster en la RAM.Para ilustrar los conceptos de terra, utilizaremos los conjuntos de datos de spDataLarge.\nSe trata de unos cuantos objetos ráster y un objeto vectorial que cubren una zona del Parque Nacional de Zion (Utah, EE.UU.).\nPor ejemplo, srtm.tif es un modelo digital de elevación de esta zona (para más detalles, véase su documentación con ?srtm).\nEn primer lugar, vamos crear un objeto SpatRaster llamado my_rast:Al escribir el nombre del raster en la consola, el resultado será la cabecera del raster (dimensiones, resolución, extensión, SRC) y alguna información adicional (clase, fuente de datos, resumen de los valores del ráster):Las funciones dedicadas informan de cada componente: dim(my_rast) retorna el número de filas, columnas y capas; ncell() el número de celdas (píxeles); res() la resolución espacial; ext() su extensión espacial; y crs() su sistema de referencia de coordenadas (la reproyección raster se trata en la Sección ??).\ninMemory() informa de si los datos raster están almacenados en memoria o en disco.help(\"terra-package\") retorna una lista completa de todas las funciones disponibles de terra","code":"\nraster_filepath = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nmy_rast = rast(raster_filepath)\nmy_rast\n#> class       : SpatRaster \n#> dimensions  : 457, 465, 1  (nrow, ncol, nlyr)\n#> resolution  : 0.000833, 0.000833  (x, y)\n#> extent      : -113, -113, 37.1, 37.5  (xmin, xmax, ymin, ymax)\n#> coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#> source      : srtm.tif \n#> name        : srtm \n#> min value   : 1024 \n#> max value   : 2892"},{"path":"spatial-class.html","id":"basic-map-raster","chapter":"2 Datos geográficos en R","heading":"2.3.3 Elaboración de mapas básicos","text":"Al igual que el paquete sf, terra también proporciona métodos plot() para sus propias clases.\n\nFIGURE 2.12: Gráfico raster básico.\nExisten otros enfoques para representar datos ráster en R que quedan fuera del alcance de esta sección, por ejemplo:paquetes como tmap para crear mapas estáticos e interactivos de objetos raster y vectoriales (véase el capítulo ??)funciones, por ejemplo levelplot() del paquete rasterVis, para crear facetas, una técnica común para visualizar el cambio en el tiempo","code":"\nplot(my_rast)"},{"path":"spatial-class.html","id":"raster-classes","chapter":"2 Datos geográficos en R","heading":"2.3.4 Clases ráster","text":"La clase SpatRaster representa un objeto raster en terra.\nLa forma más fácil de crear un objeto raster en R es leer un archivo raster desde el disco o desde un servidor (Sección ??).\nEl paquete terra soporta numerosos controles con la ayuda de la librería GDAL.\nLos rásters de los archivos suelen ser leídos en su totalidad en la memoria RAM, excepción de su cabecera y un puntero al propio archivo.Los rásters también pueden crearse desde cero utilizando la misma función rast().\nEsto se ilustra en el siguiente fragmento de código, que da como resultado un nuevo objeto SpatRaster.\nEl raster resultante consta de 36 celdas (6 columnas y 6 filas especificadas por nrows y ncols) centradas alrededor del Primer Meridiano y el Ecuador (ver parámetros xmin, xmax, ymin y ymax).\nEl SRC por defecto de los objetos ráster es WGS84, pero puede cambiarse con el argumento crs.\nEsto significa que la unidad de la resolución está en grados, que fijamos en 0,5 (resolución).\nLos valores (vals) se asignan cada celda: 1 la celda 1, 2 la celda 2, y así sucesivamente.\nRecuerda: rast() rellena las celdas por filas (diferencia de matrix()) empezando por la esquina superior izquierda, lo que significa que la fila superior contiene los valores del 1 al 6, la segunda del 7 al 12, etc.Para otras formas de crear objetos ráster, véase ?rast.La clase SpatRaster también maneja múltiples capas, que suelen corresponder un único archivo de satélite multiespectral o una serie temporal de rásters.nlyr() recupera el número de capas almacenadas en un objeto ‘SpatRaster’:","code":"\nsingle_raster_file = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nsingle_rast = rast(raster_filepath)\nnew_raster = rast(nrows = 6, ncols = 6, resolution = 0.5, \n                  xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n                  vals = 1:36)\nmulti_raster_file = system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmulti_rast = rast(multi_raster_file)\nmulti_rast\n#> class       : SpatRaster \n#> dimensions  : 1428, 1128, 4  (nrow, ncol, nlyr)\n#> resolution  : 30, 30  (x, y)\n#> extent      : 301905, 335745, 4111245, 4154085  (xmin, xmax, ymin, ymax)\n#> coord. ref. : WGS 84 / UTM zone 12N (EPSG:32612) \n#> source      : landsat.tif \n#> names       : landsat_1, landsat_2, landsat_3, landsat_4 \n#> min values  :      7550,      6404,      5678,      5252 \n#> max values  :     19071,     22051,     25780,     31961\nnlyr(multi_rast)\n#> [1] 4"},{"path":"spatial-class.html","id":"crs-intro","chapter":"2 Datos geográficos en R","heading":"2.4 Sistemas de referencia de coordenadas","text":"Los tipos de datos espaciales vectoriales y ráster comparten conceptos intrínsecos los datos espaciales.\nQuizás el más fundamental sea el Sistema de Referencia de Coordenadas (SRC), que define cómo se relacionan los elementos espaciales de los datos con la superficie de la Tierra (u otros cuerpos).\nLos SRC son geográficos o proyectados, tal y como se ha introducido al principio de este capítulo (véase la figura 2.1).\nEn esta sección se explicará cada tipo, sentando las bases para la Sección ?? sobre transformaciones de SRC.","code":""},{"path":"spatial-class.html","id":"sistemas-de-coordenadas-geográficas","chapter":"2 Datos geográficos en R","heading":"2.4.1 Sistemas de coordenadas geográficas","text":"\nLos sistemas de coordenadas geográficas identifican cualquier ubicación en la superficie de la Tierra mediante dos valores: la longitud y la latitud (véase el panel izquierdo de la figura 2.13 y 2.14).\nLa longitud es la ubicación en la dirección Este-Oeste en distancia angular desde el plano del Primer Meridiano (también conocido como Meridiano de Greenwich).\nLa latitud es la distancia angular al Norte o al Sur del plano ecuatorial.\nPor tanto, las distancias en los SRC geográficos se miden en metros.\nEsto tiene importantes consecuencias, como se demuestra en el capítulo ??.La superficie de la Tierra en los sistemas de coordenadas geográficas se representa mediante una superficie esférica o elipsoidal.\nLos modelos esféricos suponen que la Tierra es una esfera perfecta de un radio determinado; tienen la ventaja de la simplicidad pero, al mismo tiempo, son inexactos: ¡la Tierra es una esfera!\nLos modelos elipsoidales se definen mediante dos parámetros: el radio ecuatorial y el radio polar.\nÉstos son adecuados porque la Tierra está comprimida: el radio ecuatorial es unos 11,5 km más largo que el radio polar (Maling 1992).12Los elipsoides forman parte de un componente más amplio de los SRC: el datum.\nÉste contiene información sobre el elipsoide que debe utilizarse y la relación precisa entre las coordenadas cartesianas y la ubicación en la superficie de la Tierra.\n\nHay dos tipos de datum: geocéntrico y local.\nEn un dato geocéntrico, como el WGS84, el centro es el centro de gravedad de la Tierra y la precisión de las proyecciones está optimizada para una ubicación específica.\nEn un dato local, como el NAD83, la superficie elipsoidal se desplaza para alinearse con la superficie de un lugar concreto.\n\n","code":""},{"path":"spatial-class.html","id":"sistemas-de-referencia-de-coordenadas-proyectadas","chapter":"2 Datos geográficos en R","heading":"2.4.2 Sistemas de referencia de coordenadas proyectadas","text":"\nLos SRC proyectados se basan en coordenadas cartesianas sobre una superficie implícitamente plana (panel derecho de las Figuras 2.13 y 2.14).\nTienen un origen, unos ejes x e y y una unidad de medida lineal como los metros.\nTodos los SRC proyectados se basan en un SRC geográfico, descrito en la sección anterior, y se apoyan en proyecciones cartográficas para convertir la superficie tridimensional de la Tierra en valores de Este y Norte (x e y) en un SRC proyectado.Esta transición puede realizarse sin añadir algunas deformaciones.\nPor tanto, algunas propiedades de la superficie terrestre se distorsionan en este proceso, como el área, la dirección, la distancia y la forma.\nUn sistema de coordenadas proyectado puede conservar sólo una o dos de esas propiedades.\nLas proyecciones suelen denominarse en función de la propiedad que preservan: las de áreas iguales preservan el área, la azimutal preserva la dirección, la equidistante preserva la distancia y la conformal preserva la forma local.Existen tres grupos principales de tipos de proyección: cónica, cilíndrica y planar (azimutal).\nEn una proyección cónica, la superficie de la Tierra se proyecta en un cono lo largo de una única línea de tangencia o de dos líneas de tangencia.\nLas distorsiones se minimizan lo largo de las líneas de tangencia y aumentan con la distancia desde esas líneas en esta proyección.\nPor lo tanto, es la más adecuada para los mapas de zonas de latitud media.\nUna proyección cilíndrica representa la superficie en un cilindro.\nEsta proyección también puede crearse tocando la superficie de la Tierra lo largo de una sola línea de tangencia o de dos líneas de tangencia.\nLas proyecciones cilíndricas son las que más se utilizan para cartografiar el mundo en su totalidad.\nUna proyección plana proyecta los datos sobre una superficie plana que toca el globo en un punto o lo largo de una línea de tangencia.\nSe suele utilizar para cartografiar regiones polares.\nsf_proj_info(type = \"proj\") ofrece una lista de las proyecciones disponibles que admite la librería PROJ.\nFIGURE 2.13: Ejemplos de sistemas de coordenadas geográficas (WGS 84; izquierda) y proyectadas (NAD83 / zona UTM 12N; derecha) para datos vectoriales.\n\nFIGURE 2.14: Ejemplos de sistemas de coordenadas geográficas (WGS 84; izquierda) y proyectadas (NAD83 / zona UTM 12N; derecha) para datos rasterizados.\n","code":""},{"path":"spatial-class.html","id":"crs-in-r","chapter":"2 Datos geográficos en R","heading":"2.4.3 SRC en R","text":"\n\n\nDos formas recomendables de describir los SRC en R son () los identificadores de sistemas de referencia espacial (Spatial Reference System Identifiers en inglés (SRID)) o (b) las definiciones de texto conocidas (WKT2).\nAmbos enfoques tienen ventajas y desventajas.Un código epsg suele ser más corto y, por tanto, más fácil de recordar.\nEl código también se refiere un solo sistema de referencia de coordenadas bien definido.Los paquetes espaciales de R admiten una amplia gama de SRC y utilizan la biblioteca PROJ, establecida desde hace tiempo.\n\n\n\n\nEn sf el SRC de un objeto puede ser recuperado usando st_crs().\nPara ello, necesitamos leer un conjunto de datos vectoriales:Nuestro nuevo objeto, new_vector, es un polígono que representa los límites del Parque Nacional de Zion (?zion).En los casos en que falta un sistema de referencia de coordenadas (SRC) o se establece un SRC incorrecto, se puede utilizar la función st_set_crs():El mensaje de advertencia nos informa de que la función st_set_crs() transforma los datos de un SRC otro.La función crs() se puede utilizar para acceder la información del SRC desde un objeto SpatRaster:La misma función, crs(), se utiliza para establecer un SRC para los objetos raster.Es importante destacar que las funciones st_crs() y crs() alteran los valores de las coordenadas ni las geometrías.\nSu función es sólo la de establecer los metadatos sobre el objeto SRC.\nAmpliaremos los SRC y explicaremos cómo proyectar de un SRC otro en el capítulo ??.","code":"\nvector_filepath = system.file(\"vector/zion.gpkg\", package = \"spDataLarge\")\nnew_vector = st_read(vector_filepath)\nst_crs(new_vector) # get CRS\n#> Coordinate Reference System:\n#>   User input: UTM Zone 12, Northern Hemisphere \n#>   wkt:\n#> BOUNDCRS[\n#>     SOURCECRS[\n#>         PROJCRS[\"UTM Zone 12, Northern Hemisphere\",\n#>             BASEGEOGCRS[\"GRS 1980(IUGG, 1980)\",\n#>                 DATUM[\"unknown\",\n#>                     ELLIPSOID[\"GRS80\",6378137,298.257222101,\n#>                         LENGTHUNIT[\"metre\",1,\n#>                             ID[\"EPSG\",9001]]]],\n#>                 PRIMEM[\"Greenwich\",0,\n#>                     ANGLEUNIT[\"degree\",0.0174532925199433]]],\n#>             CONVERSION[\"UTM zone 12N\",\n#>                 METHOD[\"Transverse Mercator\",\n#>                     ID[\"EPSG\",9807]],\n#>                 PARAMETER[\"Latitude of natural origin\",0,\n#>                     ANGLEUNIT[\"degree\",0.0174532925199433],\n#>                     ID[\"EPSG\",8801]],\n#>                 PARAMETER[\"Longitude of natural origin\",-111,\n#>                     ANGLEUNIT[\"degree\",0.0174532925199433],\n#>                     ID[\"EPSG\",8802]],\n#>                 PARAMETER[\"Scale factor at natural origin\",0.9996,\n#>                     SCALEUNIT[\"unity\",1],\n#>                     ID[\"EPSG\",8805]],\n#>                 PARAMETER[\"False easting\",500000,\n#>                     LENGTHUNIT[\"Meter\",1],\n#>                     ID[\"EPSG\",8806]],\n#>                 PARAMETER[\"False northing\",0,\n#>                     LENGTHUNIT[\"Meter\",1],\n#>                     ID[\"EPSG\",8807]],\n#>                 ID[\"EPSG\",16012]],\n#>             CS[Cartesian,2],\n#>                 AXIS[\"(E)\",east,\n#>                     ORDER[1],\n#>                     LENGTHUNIT[\"Meter\",1]],\n#>                 AXIS[\"(N)\",north,\n#>                     ORDER[2],\n#>                     LENGTHUNIT[\"Meter\",1]]]],\n#>     TARGETCRS[\n#>         GEOGCRS[\"WGS 84\",\n#>             DATUM[\"World Geodetic System 1984\",\n#>                 ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n#>                     LENGTHUNIT[\"metre\",1]]],\n#>             PRIMEM[\"Greenwich\",0,\n#>                 ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>             CS[ellipsoidal,2],\n#>                 AXIS[\"latitude\",north,\n#>                     ORDER[1],\n#>                     ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>                 AXIS[\"longitude\",east,\n#>                     ORDER[2],\n#>                     ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>             ID[\"EPSG\",4326]]],\n#>     ABRIDGEDTRANSFORMATION[\"Transformation from GRS 1980(IUGG, 1980) to WGS84\",\n#>         METHOD[\"Position Vector transformation (geog2D domain)\",\n#>             ID[\"EPSG\",9606]],\n#>         PARAMETER[\"X-axis translation\",0,\n#>             ID[\"EPSG\",8605]],\n#>         PARAMETER[\"Y-axis translation\",0,\n#>             ID[\"EPSG\",8606]],\n#>         PARAMETER[\"Z-axis translation\",0,\n#>             ID[\"EPSG\",8607]],\n#>         PARAMETER[\"X-axis rotation\",0,\n#>             ID[\"EPSG\",8608]],\n#>         PARAMETER[\"Y-axis rotation\",0,\n#>             ID[\"EPSG\",8609]],\n#>         PARAMETER[\"Z-axis rotation\",0,\n#>             ID[\"EPSG\",8610]],\n#>         PARAMETER[\"Scale difference\",1,\n#>             ID[\"EPSG\",8611]]]]\nnew_vector = st_set_crs(new_vector, \"EPSG:26912\") # set CRS\n#> Warning: st_crs<- : replacing crs does not reproject data; use st_transform for\n#> that\ncrs(my_rast) # get CRS\n#> [1] \"GEOGCRS[\\\"WGS 84\\\",\\n    DATUM[\\\"World Geodetic System 1984\\\",\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"geodetic latitude (Lat)\\\",north,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        AXIS[\\\"geodetic longitude (Lon)\\\",east,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    ID[\\\"EPSG\\\",4326]]\"\nmy_rast2 = my_rast\ncrs(my_rast2) = \"EPSG:26912\" # set CRS"},{"path":"spatial-class.html","id":"paquete-units","chapter":"2 Datos geográficos en R","heading":"2.5 Paquete Units","text":"Una característica importante de los SRC es que contienen información sobre las unidades espaciales.\nEstá claro que es vital saber si las medidas de una casa están en pies o en metros, y lo mismo ocurre con los mapas.\nEs una buena práctica cartográfica añadir una barra de escala o algún otro indicador de distancia en los mapas para demostrar la relación entre las distancias en la página o la pantalla y las distancias sobre el terreno.\nDel mismo modo, es importante especificar formalmente las unidades en las que se miden los datos geométricos o las celdas para proporcionar un contexto, y garantizar que los cálculos posteriores se realicen en contexto.Una característica novedosa de los datos geométricos en los objetos sf es que tienen soporte nativo para las unidades.\nEsto significa que la distancia, el área y otros cálculos geométricos en sf devuelven valores que vienen con un atributo de unidades, definido por el paquete Units (E. Pebesma, Mailund, Hiebert 2016).\nEsto es ventajoso, ya que evita la confusión causada por las diferentes unidades (la mayoría de los SRC utilizan metros, algunos utilizan pies) y proporciona información sobre la dimensionalidad.\nEsto se demuestra en el siguiente fragmento de código, que calcula la superficie de Luxemburgo:\n\nEl resultado está en unidades de metros cuadrados (m2), lo que demuestra que el resultado representa un espacio bidimensional.\nEsta información, almacenada como un atributo (que los lectores interesados pueden descubrir con attributes(st_area(luxembourg))), puede aportar cálculos posteriores que utilicen unidades, como la densidad de población (que se mide en personas por unidad de superficie, normalmente por km2).\nInformar de las unidades evita confusiones.\nPor ejemplo, en el caso de Luxemburgo, si se especificaran las unidades, se podría suponer erróneamente que se trata de hectáreas.\nPara traducir la enorme cifra un tamaño más digerible, resulta tentador dividir los resultados por un millón (el número de metros cuadrados en un kilómetro cuadrado):Sin embargo, el resultado se vuelve dar incorrectamente como metros cuadrados.\nLa solución es establecer las unidades correctas con el paquete Units:Las unidades tienen la misma importancia en el caso de los datos ráster.\nSin embargo, hasta ahora sf es el único paquete espacial que soporta unidades, lo que significa que las personas que trabajan con datos ráster deben abordar los cambios en las unidades de análisis (por ejemplo, la conversión de la anchura de los píxeles de unidades imperiales decimales) con cuidado.\nEl objeto my_rast (véase más arriba) utiliza una proyección WGS84 con grados decimales como unidades.\nEn consecuencia, su resolución también se da en grados decimales, pero hay que conocerla, ya que la función res() simplemente devuelve un vector numérico.Si utilizáramos la proyección UTM, las unidades cambiarían.De nuevo, el comando res() devuelve un vector numérico sin ninguna unidad, lo que nos obliga saber que la unidad de la proyección UTM es el metro.","code":"\nluxembourg = world[world$name_long == \"Luxembourg\", ]\nst_area(luxembourg) # requiere del paquete s2 en versiones recientes de sf\n#> 2.41e+09 [m^2]\nst_area(luxembourg) / 1000000\n#> 2409 [m^2]\nunits::set_units(st_area(luxembourg), km^2)\n#> 2409 [km^2]\nres(my_rast)\n#> [1] 0.000833 0.000833\nrepr = project(my_rast, \"EPSG:26912\")\nres(repr)"},{"path":"spatial-class.html","id":"ex2","chapter":"2 Datos geográficos en R","heading":"2.6 Ejercicios","text":"","code":""},{"path":"attr.html","id":"attr","chapter":"3 Operaciones de datos de atributos","heading":"3 Operaciones de datos de atributos","text":"","code":""},{"path":"attr.html","id":"prerrequisitos-1","chapter":"3 Operaciones de datos de atributos","heading":"Prerrequisitos","text":"Este capítulo requiere que se instalen y adjunten los siguientes paquetes:También depende de spData, que carga los conjuntos de datos utilizados en los ejemplos de código de este capítulo:","code":"\nlibrary(sf)      # paquete de datos vectoriales introducido en el capítulo 2\nlibrary(terra)   # paquete de datos raster introducido en el capítulo 2\nlibrary(dplyr)   # paquete tidyverse para la manipulación de marcos de datos\nlibrary(spData)  # paquete de datos espaciales introducido en el capítulo 2"},{"path":"attr.html","id":"introducción","chapter":"3 Operaciones de datos de atributos","heading":"3.1 Introducción","text":"Los datos de atributos son la información espacial asociada los datos geográficos (geométricos).\nUn ejemplo sencillo es el de una parada de autobús: su posición suele estar representada por coordenadas de latitud y longitud (datos geométricos), además de su nombre.\nLa parada Elephant & Castle / New Kent Road de Londres, por ejemplo, tiene unas coordenadas de -0,098 grados de longitud y 51,495 grados de latitud que pueden representarse como POINT (-0,098 51,495) en la representación sfc descrita en el capítulo 2.\nLos atributos, como el nombre atributo de la función POINT (por utilizar la terminología de Simple Features) son el tema de este capítulo.Otro ejemplo es el valor de elevación (atributo) de una celda específica de la cuadrícula en los datos raster.\ndiferencia del modelo de datos vectoriales, el modelo de datos raster almacena la coordenada de la celda de la cuadrícula de forma indirecta, lo cual significa que la distinción entre atributo e información espacial es menos clara.\nPara ilustrar este punto, piensa en un píxel en la 3ª fila y la 4ª columna de una matriz raster.Su ubicación espacial está definida por su índice en la matriz: se mueve desde el origen cuatro celdas en la dirección x (normalmente este y derecha en los mapas) y tres celdas en la dirección y (normalmente sur y abajo).\nLa resolución del raster define la distancia para cada paso en x e y que se especifica en un cabezal.\nLa cabecera es un componente vital de los conjuntos de datos raster que especifica cómo se relacionan los píxeles con las coordenadas geográficas (véase también el capítulo ??).Esto muestra cómo manipular objetos geográficos basados en atributos como los nombres de las paradas de autobús en un conjunto de datos vectoriales y las elevaciones de los píxeles en un conjunto de datos rasterizados.\nEn el caso de los datos vectoriales, esto implica técnicas como crear subconjuntos y o agregaciones (véanse las secciones @ref(subconjunto de atributos vectoriales) y @ref(agregación de atributos vectoriales)).Las secciones ?? y 3.2.5 demuestran cómo unir datos en objetos de características simples utilizando un ID compartido y cómo crear nuevas variables, respectivamente.\nCada una de estas operaciones tiene un equivalente espacial:\nel operador [ en R básico, por ejemplo, funciona igualmente para subconjuntar objetos basados en su atributo y objetos espaciales; también se pueden unir atributos en dos conjuntos de datos geográficos utilizando uniones espaciales.\nEsto es una buena noticia: las habilidades desarrolladas en este capítulo son transferibles.\nEl capítulo ?? extiende los métodos presentados aquí al mundo espacial.Después de una inmersión profunda en varios tipos de operaciones de atributos vectoriales en la siguiente sección, las operaciones de datos de atributos raster se cubren en la Sección (manipulando-objetos-raster), que demuestra cómo crear capas raster que contienen atributos continuos y categóricos y cómo extraer valores de celdas de una o más capas (subconjunto raster).\nLa sección ?? proporciona una visión general de las operaciones ráster “globales” que pueden utilizarse para resumir conjuntos de datos raster completos.","code":""},{"path":"attr.html","id":"manipulación-de-atributos-vectoriales","chapter":"3 Operaciones de datos de atributos","heading":"3.2 Manipulación de atributos vectoriales","text":"Los conjuntos de datos vectoriales geográficos están bien soportados en R gracias la clase sf, que extiende la clase data.frame de R.\nAl igual que los marcos de datos, los objetos sf tienen una columna por variable de atributo (como ‘nombre’) y una fila por observación o característica (por ejemplo, por estación de autobuses).\nLos objetos sf se diferencian de los marcos de datos básicos porque tienen una columna de geometría de la clase sfc que puede contener una serie de entidades geográficas (uno o ‘múltiples’ puntos, líneas y polígonos) por fila.\nEsto se describió en el capítulo 2, donde se demostró cómo los métodos genéricos como plot() y summary() funcionan con los objetos sf.\nsf también proporciona genéricos que permiten que los objetos sf se comporten como marcos de datos normales, como se muestra al imprimir los métodos de la clase:Muchos de ellos (aggregate(), cbind(), merge(), rbind() y [) sirven para manejar marcos de datos.\nPor ejemplo, rbind() une dos marcos de datos, uno “sobre” el otro.\n$<- crea nuevas columnas.\nUna característica clave de los objetos sf es que almacenan datos espaciales y espaciales de la misma manera, como columnas en un data.frame.La columna de geometría de los objetos sf suele llamarse geometría o geom, pero puede utilizarse cualquier nombre.\nEl siguiente comando, por ejemplo, crea una columna de geometría llamada g:st_sf(data.frame(n = world$name_long), g = world$geom)Los objetos sf también pueden extender las clases tidyverse para marcos de datos, tibble y tbl.\n.\nPor lo tanto, sf permite dar rienda suelta toda la potencia de las capacidades de análisis de datos de R en los datos geográficos, tanto si se utiliza la base de R como las funciones de tidyverse para el análisis de datos.\n\n(Ver Rdatatable/data.table#2273 para ver la compatibilidad entre los objetos sf y el paquete data.table).\nAntes de utilizar estas capacidades, merece la pena repasar cómo descubrir las propiedades básicas de los objetos de datos vectoriales.\nEmpecemos por utilizar las funciones básicas de R para conocer el conjunto de datos world del paquete spData:world contiene diez columnas geográficas (y una columna que contiene una lista de geometrías) con casi 200 filas que representan los países del mundo.\nLa función st_drop_geometry() mantiene sólo los datos de los atributos de un objeto sf, es decir, elimina su geometría:La eliminación de la columna de geometría antes de trabajar con los datos de atributos puede ser útil; los procesos de manipulación de datos pueden ejecutarse más rápido cuando trabajan sólo con los datos de atributos y las columnas de geometría siempre son necesarias.\nEn la mayoría de los casos, sin embargo, tiene sentido mantener la columna de geometría, lo que explica que la columna sea “pegajosa” (permanece después de la mayoría de las operaciones de atributos menos que se elimine específicamente).\nLas operaciones de datos espaciales sobre objetos sf sólo cambian la geometría de un objeto cuando es apropiado (por ejemplo, disolviendo los bordes entre polígonos adyacentes tras una agregación).\nConvertirse en un experto en la manipulación de datos de atributos geográficos significa convertirse en un experto en la manipulación de marcos de datos.Para muchas aplicaciones, el paquete tidyverse  dplyr ofrece un enfoque eficaz para trabajar con marcos de datos.\nLa compatibilidad con Tidyverse es una ventaja de sf frente su predecesor sp, pero hay que evitar algunos inconvenientes (véase la viñeta complementaria tidyverse-pitfalls en geocompr.github.io para más detalles).","code":"\nmethods(class = \"sf\") # métodos para objetos sf, se muestran los 12 primeros\n#>  [1] aggregate             cbind                 coerce               \n#>  [4] initialize            merge                 plot                 \n#>  [7] print                 rbind                 [                    \n#> [10] [[<-                  $<-                   show                 \nclass(world) # es un objeto sf y un marco de datos (ordenado)\n#> [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\ndim(world)   # es un objeto bidimensional, con 177 filas y 11 columnas\n#> [1] 177  11\nworld_df = st_drop_geometry(world)\nclass(world_df)\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\nncol(world_df)\n#> [1] 10"},{"path":"attr.html","id":"subconjuntos-de-atributos-vectoriales","chapter":"3 Operaciones de datos de atributos","heading":"3.2.1 Subconjuntos de atributos vectoriales","text":"Los métodos de subconjunto de R base incluyen el operador [ y la función subset().\nLas funciones clave para manejar y crear subconjuntos de dplyr son filter() y slice() para crear subconjuntos de filas, y select() para crear subconjuntos de columnas.\nAmbos planteamientos conservan los componentes espaciales de los datos de atributos en los objetos sf, mientras que si se utiliza el operador $ o la función dplyr pull() para devolver una única columna de atributos como vector se perderán los datos de atributos, tal y como veremos.\n\nEsta sección se centra en el subconjunto de marcos de datos sf; para más detalles sobre el subconjunto de vectores y marcos de datos geográficos recomendamos leer la sección 2.7 de Introduction R (rcoreteam_introduction_2021?) y el Capítulo 4 de Advanced R Programming (wickham_advanced_2019?), respectivamente.El operador [ puede dividir tanto filas como columnas.\nLos índices colocados dentro de los corchetes situados directamente después del nombre de un objeto de marco de datos especifican los elementos que se quieren conservar.\nEl comando object[, j] significa ’devolver las filas representadas por y las columnas representadas por j, donde y j suelen contener enteros o TRUE y FALSE (los índices también pueden ser caracteres, indicando los nombres de las filas o las columnas).\nobject[5, 1:3], por ejemplo, significa devolver datos que contengan la 5ª fila y las columnas 1 3: el resultado debería ser un marco de datos con sólo 1 fila y 3 columnas, y una cuarta columna de geometría si es un objeto sf.\nSi se deja o j vacía se devuelven todas las filas o columnas, por lo que world[1:5, ] devuelve las cinco primeras filas y las 11 columnas que componen el marco de datos.\nLos ejemplos que hay continuación demuestran la creación de subconjunto con R base.\nAdivina el número de filas y columnas de los marcos de datos sf devueltos por cada comando y comprueba los resultados en tu propio ordenador (consulta el final del capítulo para ver más ejercicios):Una demostración de la utilidad de utilizar vectores lógicos para el subconjunto se muestra en el fragmento de código siguiente.\nEsto crea un nuevo objeto, small_countries, que contiene las naciones cuya superficie es inferior 10.000 km2:El objeto i_small (abreviatura de “índice” que representa los países pequeños) es un vector lógico que se puede utilizar para agrupar los siete países más pequeños del mundo por su superficie.\nUn comando más conciso, que omita el objeto intermediario (i_small), genera el mismo resultado:La función base de R subset() proporciona otra forma de conseguir el mismo resultado:Las funciones de R base son maduras, estables y ampliamente utilizadas, lo que las convierte en una opción sólida, especialmente en contextos en los que la reproducibilidad y la fiabilidad son fundamentales.\nLas funciones de dplyr permiten flujos de trabajo “ordenados” que algunas personas (incluidos los autores de este libro) encuentran intuitivos y productivos para el análisis interactivo de datos, especialmente cuando se combinan con editores de código como RStudio que permiten autocompletar los nombres de las columnas.\ncontinuación se muestran las funciones clave para el subconjunto de marcos de datos (incluidos los marcos de datos sf) con las funciones dplyr.\n\n\n\nselect() selecciona las columnas por nombre o posición.\nPor ejemplo, podrías seleccionar sólo dos columnas, name_long y pop, con el siguiente comando:Nota: al igual que con el comando equivalente en R base (world[, c(\"name_long\", \"pop\")]), la columna geom permanece.\nselect() también permite seleccionar un rango de columnas con la ayuda del operador ::Puedes eliminar columnas específicas con el operador -:Crear subconjuntos y renombrar columnas al mismo tiempo con la sintaxis nuevo_nombre = antiguo_nombre:Cabe destacar que el comando anterior es más conciso que el equivalente en R base, el cual requiere dos líneas de código:select() también funciona con “funciones de ayuda” para operaciones más avanzadas, como contains(), starts_with() y num_range() (véase la página de ayuda con ?select para más detalles).La mayoría de los verbos de dplyr devuelven un marco de datos, pero se puede extraer una sola columna como vector con pull().\n\n\n\nPuede obtener el mismo resultado en R base con los operadores de subconjunto de listas $ y [[, los tres comandos siguientes devuelven el mismo vector numérico:slice() es el equivalente de fila de select().\nEl siguiente fragmento de código, por ejemplo, selecciona las filas 1 6:filter() es el equivalente de dplyr la función subset() de R base.\nMantiene sólo las filas que coinciden según los criterios dados, por ejemplo, sólo los países con un área por debajo de un determinado umbral, o con un promedio alto de esperanza de vida, como se muestra en los siguientes ejemplos:El conjunto estándar de operadores de comparación se puede utilizar en la función filter(), como se ilustra en la Tabla 3.1:TABLE 3.1: Operadores de comparación que retornan Booleanos (TRUE/FALSE).","code":"\nworld[1:6, ]    # Subconjunto de las filas 1 a 6 \nworld[, 1:3]    # Subconjunto de las columnas 1 a 3\nworld[1:6, 1:3] # Subconjunto de las filas 1 a 6 y las columnas 1 a 3\nworld[, c(\"name_long\", \"pop\")] # Columnas por nombre\nworld[, c(T, T, F, F, F, F, F, T, T, F, F)] # Selección de columnas por índices lógicos\nworld[, 888] # Índice representando una columna no existenete\ni_small = world$area_km2 < 10000\nsummary(i_small) # un vector lógico\n#>    Mode   FALSE    TRUE \n#> logical     170       7\nsmall_countries = world[i_small, ]\nsmall_countries = world[world$area_km2 < 10000, ]\nsmall_countries = subset(world, area_km2 < 10000)\nworld1 = dplyr::select(world, name_long, pop)\nnames(world1)\n#> [1] \"name_long\" \"pop\"       \"geom\"\n# Selecciona todas las columnas entre name_long y pop (incluidas)\nworld2 = dplyr::select(world, name_long:pop)\n# Muestra todas las columnas excepto subregion y area_km2 \nworld3 = dplyr::select(world, -subregion, -area_km2)\nworld4 = dplyr::select(world, name_long, population = pop)\nworld5 = world[, c(\"name_long\", \"pop\")] # subagrupar las columnas por nombre\nnames(world5)[names(world5) == \"pop\"] = \"population\" # renombrar la columna manualmente\npull(world, pop)\nworld$pop\nworld[[\"pop\"]]\nslice(world, 1:6)\nworld7 = filter(world ,area_km2 < 10000) # países con un área menor a 10.000km2\nworld7 = filter(world, lifeExp > 82)      # con una esperanza de vida superior a 82 años"},{"path":"attr.html","id":"encadenamiento-de-comandos-con-el-operador-pipe","chapter":"3 Operaciones de datos de atributos","heading":"3.2.2 Encadenamiento de comandos con el operador pipe","text":"Una de las claves para el flujo de trabajo con las funciones de dplyr es el operador ‘pipe’ %>% (y desde R 4.1.0 el pipe nativo |>), el cual toma su nombre del pipe de Unix | (Grolemund Wickham 2016).\nLos pipes permiten un código expresivo: el resultado de una función anterior se convierte en el primer argumento de la siguiente función, lo que permite encadenar.\nEsto se ilustra continuación, en el que sólo se filtran los países de Asia del conjunto de datos world, continuación se seleccionan dos columnas para crear un subconjunto (name_long y continent) y las cinco primeras filas (resultado mostrado).El fragmento anterior muestra cómo el operador pipe permite escribir los comandos en un orden claro:\nlos anteriores van de arriba abajo (línea por línea) y de izquierda derecha.\nLa alternativa %>% son las llamadas funciones ‘anidadas,’ que son más difíciles de leer:","code":"\nworld7 = world %>%\n  filter(continent == \"Asia\") %>%\n  dplyr::select(name_long, continent) %>%\n  slice(1:5)\nworld8 = slice(\n  dplyr::select(\n    filter(world, continent == \"Asia\"),\n    name_long, continent),\n  1:5)"},{"path":"attr.html","id":"agregación-de-atributos-vectoriales","chapter":"3 Operaciones de datos de atributos","heading":"3.2.3 Agregación de atributos vectoriales","text":"\nLa agregación implica resumir los datos con una o más “variables de agrupación,” normalmente partir de columnas del marco de datos que se va agregar (la agregación geográfica se trata en el siguiente capítulo).\nUn ejemplo de agregación de atributos es el cálculo del número de personas por continente partir de los datos nivel de país (una fila por país).\nEl conjunto de datos world contiene los ingredientes necesarios: las columnas pop y continent, la población y la variable de agrupación, respectivamente.\nEl objetivo es encontrar la suma sum() de las poblaciones de los países para cada continente, lo que resulta en un marco de datos más pequeño (la agregación es una forma de reducción de datos y puede ser un paso inicial útil cuando se trabaja con grandes conjuntos de datos).\nEsto se puede hacer con la función básica de R agregate() de la siguiente manera:El resultado es un marco de datos espacial con seis filas, una por continente, y dos columnas que informan del nombre y la población de cada continente (véase la tabla 3.2 con los resultados de los 3 continentes más poblados).aggregate() es una función genérica lo que significa que se comporta de forma diferente en función de lo que se le añada.\nsf proporciona el método aggregate.sf() que se activa automáticamente cuando x es un objeto sf al que se le proporciona un argumento :El resultado es un objeto espacial world_agg2 que contiene 8 características que representan los continentes del mundo (y el océano abierto).\ngroup_by() %>% summarize() es el equivalente en dplyr de la función aggregate(), con el nombre de la variable proporcionado en la función group_by() especificando la variable de agrupación y la información sobre lo que se va resumir al pasarle la función summarize(), como se muestra continuación:El enfoque puede parecer más complejo, pero tiene ventajas: flexibilidad, legibilidad y control sobre los nuevos nombres de las columnas.\nEsta flexibilidad se ilustra en el siguiente comando, que calcula sólo la población, sino también la superficie y el número de países de cada continente:En el fragmento de código anterior pop, area (sqkm) y n son nombres de columnas en el resultado, y sum() y n() eran las funciones de agregación.\nEstas funciones de agregación devuelven objetos sf con filas que representan los continentes y geometrías que contienen múltiples polígonos que representan cada masa de tierra e islas asociadas (esto funciona gracias la operación geométrica “unión,” como se explica en la sección ??).Combinemos lo que hemos aprendido hasta ahora sobre las funciones de dplyr, encadenando varios comandos para resumir datos de atributos sobre todos los países por continente.\nEl siguiente comando calcula la densidad de población (con mutate()), ordena los continentes por el número de países que contienen (con dplyr::arrange()), y mantiene sólo los 3 continentes más poblados (con top_n()), cuyo resultado se presenta en la Tabla 3.2):TABLE 3.2: Los 3 continentes más poblados ordenados por densidad de población (personas por km2).","code":"\nworld_agg1 = aggregate(pop ~ continent, FUN = sum, data = world, na.rm = TRUE)\nclass(world_agg1)\n#> [1] \"data.frame\"\nworld_agg2 = aggregate(world[\"pop\"], list(world$continent), FUN = sum, na.rm = TRUE)\nclass(world_agg2)\n#> [1] \"sf\"         \"data.frame\"\nnrow(world_agg2)\n#> [1] 8\nworld_agg3 = world %>%\n  group_by(continent) %>%\n  summarize(pop = sum(pop, na.rm = TRUE))\nworld_agg4  = world %>% \n  group_by(continent) %>%\n  summarize(pop = sum(pop, na.rm = TRUE), `area (sqkm)` = sum(area_km2), n = n())\nworld_agg5 = world %>% \n  st_drop_geometry() %>%                      # aisla la geometría para ganar velocidad\n  dplyr::select(pop, continent, area_km2) %>% # crea un subconjunto con las columnas de interés\n  group_by(continent) %>%                     # agrupa por continente y resume los datos\n  summarize(Pop = sum(pop, na.rm = TRUE), Area = sum(area_km2), N = n()) %>%\n  mutate(Density = round(Pop / Area)) %>%     # calcula la densidad de población\n  top_n(n = 3, wt = Pop) %>%                  # muestra sólo las 3 primeras filas\n  arrange(desc(N))                            # ordenar los 3 continentes en orden descendiente"},{"path":"attr.html","id":"unión-de-atributos-vectoriales","chapter":"3 Operaciones de datos de atributos","heading":"3.2.4 Unión de atributos vectoriales","text":"Combinar datos de diferentes fuentes es una tarea frecuente en la preparación de datos.\nLas uniones hacen esto combinando tablas basadas en una variable “clave” compartida.\ndplyr tiene múltiples funciones de unión incluyendo left_join() y inner_join() — véase vignette(\"two-table\") para una lista completa.\nEstos nombres de funciones siguen las convenciones utilizadas en el lenguaje de las bases de datos SQL (Grolemund Wickham 2016, chap. 13); utilizándolos para unir conjuntos de datos espaciales objetos sf.\nEl objetivo de esta sección es aprender realizar este tipo de unión.\nLas funciones de unión de dplyr funcionan igual en los marcos de datos y en los objetos sf, la única diferencia importante es la columna de la lista geometría.\nEl resultado de las uniones de datos puede ser tanto un objeto sf como un objeto data.frame.\nEl tipo más común de unión de atributos en datos espaciales toma un objeto sf como primer argumento y le añade columnas de un data.frame especificado como segundo argumento.\n\nPara demostrar las uniones, combinaremos los datos sobre la producción de café con el conjunto de datos world.\nLos datos sobre el café se encuentran en un marco de datos llamado coffee_data del paquete spData (véase ?coffee_data para más detalles).\ncoffee_data tiene 3 columnas:\nname_long nombra las principales naciones productoras de café; y coffee_production_2016 y coffee_production_2017 contienen valores estimados de la producción de café en unidades de sacos de 60 kg para cada año.\nUn “left join,” que conserva el primer conjunto de datos, combina “world” con “coffee_data”:Dado que los conjuntos de datos de entrada comparten una “variable clave” (name_long), la unión ha funcionado sin utilizar el argumento (véase ?left_join para más detalles).\nEl resultado es un objeto sf idéntico al objeto original world pero con dos nuevas variables sobre la producción de café.\nEsto puede ser representado como un mapa, tal y como se ilustra en la Figura 3.1, generated plot() function :\nFIGURE 3.1: Producción mundial de café (en miles de sacos de 60 kg) por país, 2017. Fuente: Organización Internacional del Café.\nPara que la unión funcione, se debe proporcionar una “variable clave” en ambos conjuntos de datos.\nPor defecto dplyr utiliza todas las variables con nombres coincidentes.\nEn este caso, ambos objetos world_coffee y world contenían una variable llamada name_long, lo que explica el mensaje Joining, = \"name_long\".\nEn la mayoría de los casos en que los nombres de las variables son iguales. En esos casos tienes dos opciones:Cambiar el nombre de la variable clave en uno de los objetos para que coincidan.Utilizar el argumento para especificar las variables de unión.Este último enfoque se demuestra continuación en una versión renombrada de coffee_data:Obsérvese que se mantiene el nombre del objeto original, lo que significa que world_coffee y el nuevo objeto world_coffee2 son idénticos.\nOtra característica del resultado es que tiene el mismo número de filas que el conjunto de datos original.\nAunque sólo hay 47 filas de datos en coffee_data, los 177 registros de países se mantienen intactos en world_coffee y world_coffee2:\nLas filas del conjunto de datos original que coinciden se les asignan valores “NA” para las nuevas variables de producción de café.\n¿Y si sólo queremos conservar los países que coinciden con la variable clave?\nEn ese caso se puede utilizar inner join():Fíjate en que el resultado de inner_join() sólo tiene 45 filas frente las 47 de coffee_data.\n¿Qué ha ocurrido con las filas restantes?\nPodemos identificar las filas que coinciden utilizando la función setdiff() de la siguiente manera:El resultado muestra que Others representa una fila que está presente en el conjunto de datos world y en el caso de la “República Democrática del Congo” el nombre\nha sido abreviado, lo que hace que la unión lo tenga en cuenta.\nEl siguiente comando utiliza una función de concordancia de palabras (regex) del paquete stringr para confirmar qué debería ser Congo, Dem. Rep. :Para solucionar este problema, crearemos una nueva versión de coffee_data y actualizaremos el nombre.\nSi se une el marco de datos actualizado con inner_join(), se obtiene un resultado con las 46 naciones productoras de café:También es posible unir en la dirección contraria: empezar con un conjunto de datos espaciales y añadir variables de un objeto Simple Features (sf).\nEsto se demuestra continuación, se comienza con el objeto coffee_data y se le añaden variables del conjunto de datos original world.\ndiferencia de las uniones anteriores, el resultado es otro objeto Simple Feature, sino un marco de datos en forma de tibble de tidyverse:\nEl resultado de una unión tiende coincidir con su primer argumento:Esta sección cubre la mayoría de los casos de uso de join.\nPara más información, recomendamos Grolemund Wickham (2016), la ‘viñeta’ de join en el paquete geocompkg que acompaña este libro, y la documentación del paquete data.table.13\nOtro tipo de unión es la unión espacial, que se trata en el siguiente capítulo (Sección ??).","code":"\nworld_coffee = left_join(world, coffee_data)\n#> Joining, by = \"name_long\"\nclass(world_coffee)\n#> [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\nnames(world_coffee)\n#>  [1] \"iso_a2\"                 \"name_long\"              \"continent\"             \n#>  [4] \"region_un\"              \"subregion\"              \"type\"                  \n#>  [7] \"area_km2\"               \"pop\"                    \"lifeExp\"               \n#> [10] \"gdpPercap\"              \"geom\"                   \"coffee_production_2016\"\n#> [13] \"coffee_production_2017\"\nplot(world_coffee[\"coffee_production_2017\"])\ncoffee_renamed = rename(coffee_data, nm = name_long)\nworld_coffee2 = left_join(world, coffee_renamed, by = c(name_long = \"nm\"))\nworld_coffee_inner = inner_join(world, coffee_data)\n#> Joining, by = \"name_long\"\nnrow(world_coffee_inner)\n#> [1] 45\nsetdiff(coffee_data$name_long, world$name_long)\n#> [1] \"Congo, Dem. Rep. of\" \"Others\"\n(drc = stringr::str_subset(world$name_long, \"Dem*.+Congo\"))\n#> [1] \"Democratic Republic of the Congo\"\ncoffee_data$name_long[grepl(\"Congo,\", coffee_data$name_long)] = drc\nworld_coffee_match = inner_join(world, coffee_data)\n#> Joining, by = \"name_long\"\nnrow(world_coffee_match)\n#> [1] 46\ncoffee_world = left_join(coffee_data, world)\n#> Joining, by = \"name_long\"\nclass(coffee_world)\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\""},{"path":"attr.html","id":"vec-attr-creation","chapter":"3 Operaciones de datos de atributos","heading":"3.2.5 Creando atributos y eliminando información espacial","text":"menudo, queremos crear una nueva columna basada en columnas ya existentes.\nPor ejemplo, queremos calcular la densidad de población de cada país.\nPara ello necesitamos dividir una columna de población, aquí pop, por una columna de área, aquí area_km2.\nUsando R base, podemos escribir:Alternativamente, podemos utilizar una de las funciones de dplyr - mutate() o transmute().\nLa función mutate() añade nuevas columnas en la penúltima posición del objeto sf (la última se reserva para la geometría):La diferencia entre mutate() y transmute() es que esta última elimina todas las demás columnas existentes (excepto la columna de geometría fijada):La función unite() del paquete tidyr (que proporciona muchas funciones útiles para remodelar conjuntos de datos, como pivot_longer()) pega las columnas existentes.\nPor ejemplo, queremos combinar las columnas continent y region_un en una nueva columna llamada con_reg.\nAdemás, podemos definir un separador (aquí: dos puntos :) que define cómo se deben unir los valores de las columnas de entrada, y si se deben eliminar las columnas originales (aquí: TRUE):La función separate() hace lo contrario de unite(): divide una columna en varias columnas utilizando una expresión regular o posiciones de caracteres.\nEsta función también proviene del paquete tidyr.La función de dplyr rename() y la función base de R setNames() son útiles para renombrar columnas.\nLa primera sustituye un nombre antiguo por uno nuevo.\nEl siguiente comando, por ejemplo, renombra la larga columna nombre_long simplemente name:setNames() cambia todos los nombres de las columnas la vez, y requiere un vector de caracteres con un nombre que coincida con cada columna.\nEsto se ilustra continuación, lo cual produce el mismo objeto world, pero con nombres mucho más cortos:Es importante señalar que las operaciones de datos de atributos conservan la geometría de simple features.\nComo se ha mencionado al principio del capítulo, puede ser útil eliminar la geometría.\nPara ello, hay que eliminarla explícitamente.\nPor lo tanto, un enfoque como select(world, -geom) tendrá éxito y en su lugar debe utilizar st_drop_geometry().14","code":"\nworld_new = world # no sobreescribe nuestros datos originales\nworld_new$pop_dens = world_new$pop / world_new$area_km2\nworld %>% \n  mutate(pop_dens = pop / area_km2)\nworld %>% \n  transmute(pop_dens = pop / area_km2)\nworld_unite = world %>%\n  unite(\"con_reg\", continent:region_un, sep = \":\", remove = TRUE)\nworld_separate = world_unite %>% \n  separate(con_reg, c(\"continent\", \"region_un\"), sep = \":\")\nworld %>% \n  rename(name = name_long)\nnew_names = c(\"i\", \"n\", \"c\", \"r\", \"s\", \"t\", \"a\", \"p\", \"l\", \"gP\", \"geom\")\nworld %>% \n  setNames(new_names)\nworld_data = world %>% st_drop_geometry()\nclass(world_data)\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\""},{"path":"attr.html","id":"manipulando-objetos-raster","chapter":"3 Operaciones de datos de atributos","heading":"3.3 Manipulando objetos raster","text":"diferencia del modelo de datos vectoriales subyacente simple features (que representa puntos, líneas y polígonos como entidades discretas en el espacio), los datos rasterizados representan superficies continuas.\nEsta sección muestra cómo funcionan los objetos raster, creándolos desde cero, basándose en la sección ??.\nDebido su estructura única, el subconjunto y otras operaciones con conjuntos de datos raster funcionan de manera diferente, como se demuestra en la sección ??.\nEl siguiente código recrea el conjunto de datos raster utilizados en la sección 2.3.4, cuyo resultado se ilustra en la figura 3.2.\nEsto demuestra cómo funciona la función rast() para crear un raster de ejemplo llamado elev (que representa elevaciones).El resultado es un objeto raster con 6 filas y 6 columnas (especificadas por los argumentos nrow y ncol), y una extensión espacial mínima y máxima en dirección x e y (xmin, xmax, ymin, ymax).\nEl argumento vals establece los valores que contiene cada celda: datos numéricos que van de 1 36 en este caso.\nLos objetos raster también pueden contener valores categóricos de clase lógica o variables factoriales en R.\nEl siguiente código crea un raster que representa el tamaño de los granos de café (Figura 3.2):El objeto raster almacena la correspondiente tabla de búsqueda o “Raster Attribute Table” (RAT) como una lista de marcos de datos, los cuales pueden ser visualizados con cats(grain) ( véase ?cats() para más información).\nCada elemento de esta lista es una capa del raster.\nTambién es posible utilizar la función levels() para recuperar y añadir nuevos niveles de factores o sustituir los existentes:\nFIGURE 3.2: Conjuntos de datos rasterizados con valores numéricos (izquierda) y categóricos (derecha).\n","code":"\nelev = rast(nrows = 6, ncols = 6, resolution = 0.5, \n            xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n            vals = 1:36)\ngrain_order = c(\"clay\", \"silt\", \"sand\")\ngrain_char = sample(grain_order, 36, replace = TRUE)\ngrain_fact = factor(grain_char, levels = grain_order)\ngrain = rast(nrows = 6, ncols = 6, resolution = 0.5, \n             xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n             vals = grain_fact)\nlevels(grain)[[1]] = c(levels(grain)[[1]], wetness = c(\"wet\", \"moist\", \"dry\"))\nlevels(grain)\n#> [[1]]\n#> [1] \"clay\"  \"silt\"  \"sand\"  \"wet\"   \"moist\" \"dry\""},{"path":"attr.html","id":"subconjuntos-de-rásteres","chapter":"3 Operaciones de datos de atributos","heading":"3.3.1 Subconjuntos de rásteres","text":"Los subconjuntos de rásteres se realizan con el operador base de R [, que acepta varios tipos de entradas:\nIndexación de filas y columnasIDs de celdasCoordenadas (Véase la sección ??)Otros objetos espaciales (Véase la sección ??)Aquí sólo mostramos las dos primeras opciones, ya que pueden considerarse operaciones espaciales.\nSi necesitamos un objeto espacial para crear otro subconjunto o la salida es un objeto espacial, nos referimos esto como subconjunto espacial.\nPor lo tanto, las dos últimas opciones se mostrarán en el próximo capítulo (véase la sección ??).Las dos primeras opciones de subconjunto se demuestran en los comandos siguientes —\nambos devuelven el valor del píxel superior izquierdo en el objeto raster elev (los resultados se muestran):El subconjunto de los objetos raster de varias capas devolverá el valor de la(s) celda(s) de cada capa.\nPor ejemplo, c(elev, grain)[1] devuelve un marco de datos con una fila y dos columnas — una para cada capa.\nPara extraer todos los valores o filas completas, también puedes utilizar values().\nLos valores de las celdas pueden modificarse sobrescribiendo los valores existentes junto con una operación de subconjunto.\nEl siguiente fragmento de código, por ejemplo, establece la celda superior izquierda de elev 0 (los resultados se muestran):Dejar los corchetes vacíos es una versión abreviada de values() para recuperar todos los valores de un raster.\nTambién se pueden modificar múltiples celdas de esta manera:Reemplazar los valores de rásteres multicapa puede hacerse con una matriz, con tantas columnas como capas queramos y filas como celdas reemplazables (resultados mostrados):","code":"\n# fila 1, columna 1\nelev[1, 1]\n# ID de la celda 1\nelev[1]\nelev[1, 1] = 0\nelev[]\nelev[1, c(1, 2)] = 0\ntwo_layers = c(grain, elev) \ntwo_layers[1] = cbind(c(0), c(4))\ntwo_layers[]"},{"path":"attr.html","id":"sintetizando-objetos-rasterizados","chapter":"3 Operaciones de datos de atributos","heading":"3.3.2 Sintetizando objetos rasterizados","text":"terra contiene funciones para extraer estadísticas descriptivas para rásteres enteros.\nLa impresión de un objeto raster en la consola al escribir su nombre devuelve sus valores mínimos y máximos.\nsummary() proporciona estadísticas descriptivas comunes. – mínimo, máximo, cuartiles y número de NAs para los rásteres continuos y un número de celdas de cada clase para los rásteres categóricos.\nOtras operaciones de síntesis, como la desviación estándar (véase más adelante) o estadísticas de síntesis personalizadas, pueden calcularse con global().\nAdemás, la función freq() permite obtener la tabla de frecuencias de los valores categóricos.Las estadísticas de los valores raster pueden visualizarse de distintas maneras.\nFunciones específicas como boxplot(), density(), hist() y pairs() funcionan también con objetos raster, como se demuestra en el histograma creado con el comando siguiente (mostrado):En caso de que la función de visualización deseada funcione con objetos raster, se pueden extraer los datos raster para representarlos con la ayuda de values() (Sección ??).\nLas estadísticas raster descriptivas pertenecen las llamadas operaciones raster globales.\nEstas y otras operaciones típicas del procesamiento raster forman parte del esquema del álgebra de mapas, que se tratan en el siguiente capítulo (Sección ??).\nAlgunos nombres de funciones chocan entre paquetes (por ejemplo, una función con el nombre extract() existe en ambos paquetes terra y tidyr). Además de cargar los paquetes haciendo referencia las funciones de forma verbosa (por ejemplo, tidyr::extract()), otra forma de evitar los choques de nombres de funciones es descargando el paquete que genere este choque de nombres con detach(). El siguiente comando, por ejemplo, descarga el paquete terra (esto también puede hacerse en la pestaña paquete (Package) que reside por defecto en el panel inferior derecho de RStudio): detach(“paquete:terra,” unload = TRUE, force = TRUE). El argumento force asegura que el paquete se desprenderá incluso si otros paquetes dependen de él. Esto, sin embargo, puede conducir una usabilidad restringida de los paquetes que dependen del paquete desprendido, y por lo tanto se recomienda.\n","code":"\nglobal(elev, sd)\nhist(elev)"},{"path":"attr.html","id":"ejercicios-1","chapter":"3 Operaciones de datos de atributos","heading":"3.4 Ejercicios","text":"Para estos ejercicios utilizaremos los conjuntos de datos us_states y us_states_df del paquete spData.\nAntes de realizar estos ejercicios, deberás haber añadido este paquete y los otros utilizados en el capítulo de operaciones con atributos (sf, dplyr, terra) con comandos como library(spData).us_states es un objeto espacial (de clase sf), que contiene la geometría y algunos atributos (incluyendo el nombre, la región, el área y la población) de los estados contiguos de Estados Unidos.\nEl objeto us_states_df es un marco de datos (de la clase data.frame) que contiene el nombre y variables adicionales (incluyendo la renta media y el nivel de pobreza, para los años 2010 y 2015) de los estados de EE.UU., incluyendo Alaska, Hawaii y Puerto Rico.\nLos datos proceden de la Oficina del Censo de los Estados Unidos, y están documentados en “us_states” y “us_states_df.”E1. Crea un nuevo objeto llamado us_states_name que contenga sólo la columna NAME del objeto us_states utilizando la sintaxis de R base ([) o tidyverse (select()).\n¿Cuál es la clase del nuevo objeto y qué lo hace geográfico?E2. Selecciona las columnas del objeto us_states que contienen datos de población.\nObtén el mismo resultado utilizando un comando diferente (bonus: intenta encontrar tres formas de obtener el mismo resultado).\nSugerencia: intenta utilizar funciones de ayuda, como contains o starts_with de dplyr (ver ?contains).E3. Encuentra todos los estados con las siguientes características (bonus: encuéntralos y grafícalos):Pertenecen la región del Medio Oeste.Pertenecen la región Oeste, tienen una superficie inferior 250.000 km2y en 2015 una población superior 5.000.000 de habitantes (pista: puede que tengas que utilizar la función units::set_units() o .numeric()).Pertenecen la región Sur, tienen una superficie superior 150.000 km2 o una población total en 2015 superior 7.000.000 de residentes.E4. ¿Cuál fue la población total en 2015 en el conjunto de datos us_states?\n¿Cuál fue la población total mínima y máxima en 2015?E5. ¿Cuántos estados hay en cada región?E6. ¿Cuál fue la población total mínima y máxima en 2015 en cada región?\n¿Cuál fue la población total en 2015 en cada región?E7. Añade las variables de us_states_df us_states, y crea un nuevo objeto llamado us_states_stats.\n¿Qué función utilizado y por qué?\n¿Qué variable es la clave en ambos conjuntos de datos?\n¿Cuál es la clase del nuevo objeto?E8. us_states_df tiene dos filas más que us_states.\n¿Cómo puedes encontrarlas? (pista: intenta utilizar la función dplyr::anti_join())E9. ¿Cuál era la densidad de población en 2015 en cada estado?\n¿Cuál era la densidad de población en cada estado en 2010?E10. ¿Cuánto ha cambiado la densidad de población entre 2010 y 2015 en cada estado?\nCalcula el cambio en porcentajes y crea un mapa que lo muestre.E11. Cambia los nombres de las columnas en us_states minúsculas. (Sugerencia: las funciones - tolower() y colnames() pueden ayudar).E12. Usando us_states y us_states_df crea un nuevo objeto llamado us_states_sel.\nEl nuevo objeto debe tener sólo dos variables - median_income_15 y geometry.\nCambia el nombre de la columna median_income_15 por Income.E13. Calcula la variación del número de residentes que viven por debajo del nivel de pobreza entre 2010 y 2015 para cada estado. (Sugerencia: Consulta ?us_states_df para ver la documentación sobre las columnas relacionadas con el nivel de pobreza).\nBonus: Calcula el cambio en el porcentaje de residentes que viven por debajo del nivel de pobreza en cada estado.E14. ¿Cuál fue el número mínimo, medio y máximo de personas que viven por debajo del umbral de la pobreza en 2015 en cada región?\nBonus: ¿Cuál es la región con el mayor aumento de personas que viven por debajo del umbral de la pobreza?E15. Crea un raster desde cero con nueve filas y columnas y una resolución de 0,5 grados decimales (WGS84).\nRellénalo con números aleatorios.\nExtrae los valores de las cuatro celdas de las esquinas.E16. ¿Cuál es la clase más común de nuestro ejemplo de raster grain? (pista: modal())E17. Traza el histograma y el boxplot del raster data(dem, package = \"spDataLarge\").","code":""}]
