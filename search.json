[{"path":"index.html","id":"welcome","chapter":"Welcome","heading":"Welcome","text":"online home Geocomputación con R, book geographic data analysis, visualization modeling.Note: first edition book published CRC Press R Series.\ncan buy book CRC Press, Amazon.Inspired bookdown Free Open Source Software Geospatial (FOSS4G) movement, book open source.\nensures contents reproducible publicly accessible people worldwide.online version book hosted geocompr.robinlovelace.net kept --date GitHub Actions, provides information ‘build status’ follows:version book built GH Actions 2021-09-20.","code":""},{"path":"index.html","id":"how-to-contribute","chapter":"Welcome","heading":"How to contribute?","text":"bookdown makes editing book easy editing wiki, provided GitHub account (sign-github.com).\nlogged-GitHub, click ‘Edit page’ icon right panel book website.\ntake editable version source R Markdown file generated page ’re .raise issue book’s content (e.g. code running) make feature request, check-issue tracker.Maintainers contributors must follow repository’s CODE CONDUCT.","code":""},{"path":"index.html","id":"reproducibility","chapter":"Welcome","heading":"Reproducibility","text":"reproduce code book, need recent version R --date packages.\ncan installed following command (requires remotes):build book locally, clone download geocompr repo, load R root directory (e.g., opening geocompr.Rproj RStudio) run following lines:","code":"\nremotes::install_github(\"geocompr/geocompkg\")\nbookdown::render_book(\"index.Rmd\") # to build the book\nbrowseURL(\"_book/index.html\") # to view it"},{"path":"index.html","id":"supporting-the-project","chapter":"Welcome","heading":"Supporting the project","text":"find book useful, please support :Telling people personCommunicating book digital media, e.g., via #geocompr hashtag Twitter (see Guestbook geocompr.github.io) letting us know courses using bookCiting linking-‘Starring’ geocompr GitHub repositoryReviewing , e.g., Amazon GoodreadsAsking questions making suggestion content via GitHub Twitter.Buying copyFurther details can found github.com/Robinlovelace/geocompr.work licensed Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.","code":""},{"path":"foreword.html","id":"foreword","chapter":"Foreword","heading":"Foreword","text":"‘spatial’ R always broad, seeking provide integrate tools geography, geoinformatics, geocomputation spatial statistics anyone interested joining : joining asking interesting questions, contributing fruitful research questions, writing improving code.\n, ‘spatial’ R always included open source code, open data reproducibility.‘spatial’ R also sought open interaction many branches applied spatial data analysis, also implement new advances data representation methods analysis expose cross-disciplinary scrutiny.\nbook demonstrates, often alternative workflows similar data similar results, may learn comparisons others create understand workflows.\nincludes learning similar communities around Open Source GIS complementary languages Python, Java .R’s wide range spatial capabilities never evolved without people willing share creating adapting.\nmight include teaching materials, software, research practices (reproducible research, open data), combinations .\nR users also benefitted greatly ‘upstream’ open source geo libraries GDAL, GEOS PROJ.book clear example , curious willing join , can find things need match aptitudes.\nadvances data representation workflow alternatives, ever increasing numbers new users often without applied quantitative command-line exposure, book kind really needed.\nDespite effort involved, authors supported pressing forward publication., fresh book ready go; authors tried many tutorials workshops, readers instructors able benefit knowing contents continue tried people like .\nEngage authors wider R-spatial community, see value choice building workflows important, enjoy applying learn things care .Roger BivandBergen, September 2018","code":""},{"path":"preface.html","id":"preface","chapter":"Preface","heading":"Preface","text":"","code":""},{"path":"preface.html","id":"who-this-book-is-for","chapter":"Preface","heading":"Who this book is for","text":"book people want analyze, visualize model geographic data open source software.\nbased R, statistical programming language powerful data processing, visualization geospatial capabilities.\nbook covers wide range topics interest wide range people many different backgrounds, especially:People learned spatial analysis skills using desktop Geographic Information System (GIS), QGIS, ArcGIS, GRASS SAGA, want access powerful (geo)statistical visualization programming language benefits command-line approach (Sherman 2008):\n\nadvent ‘modern’ GIS software, people want point click way life. ’s good, tremendous amount flexibility power waiting command line.\nPeople learned spatial analysis skills using desktop Geographic Information System (GIS), QGIS, ArcGIS, GRASS SAGA, want access powerful (geo)statistical visualization programming language benefits command-line approach (Sherman 2008):advent ‘modern’ GIS software, people want point click way life. ’s good, tremendous amount flexibility power waiting command line.Graduate students researchers fields specializing geographic data including Geography, Remote Sensing, Planning, GIS Geographic Data ScienceGraduate students researchers fields specializing geographic data including Geography, Remote Sensing, Planning, GIS Geographic Data ScienceAcademics post-graduate students working geographic data — fields Geology, Regional Science, Biology Ecology, Agricultural Sciences, Archaeology, Epidemiology, Transport Modeling, broadly defined Data Science — require power flexibility R researchAcademics post-graduate students working geographic data — fields Geology, Regional Science, Biology Ecology, Agricultural Sciences, Archaeology, Epidemiology, Transport Modeling, broadly defined Data Science — require power flexibility R researchApplied researchers analysts public, private third-sector organizations need reproducibility, speed flexibility command-line language R applications dealing spatial data diverse Urban Transport Planning, Logistics, Geo-marketing (store location analysis) Emergency PlanningApplied researchers analysts public, private third-sector organizations need reproducibility, speed flexibility command-line language R applications dealing spatial data diverse Urban Transport Planning, Logistics, Geo-marketing (store location analysis) Emergency PlanningThe book designed intermediate--advanced R users interested geocomputation R beginners prior experience geographic data.\nnew R geographic data, discouraged: provide links materials describe nature spatial data beginner’s perspective Chapter 2 links provided .","code":""},{"path":"preface.html","id":"how-to-read-this-book","chapter":"Preface","heading":"How to read this book","text":"book divided three parts:Part : Foundations, aimed getting --speed geographic data R.Part II: Extensions, covers advanced techniques.Part III: Applications, real-world problems.chapters get progressively harder recommend reading book order.\nmajor barrier geographical analysis R steep learning curve.\nchapters Part aim address providing reproducible code simple datasets ease process getting started.important aspect book teaching/learning perspective exercises end chapter.\nCompleting develop skills equip confidence needed tackle range geospatial problems.\nSolutions exercises, number extended examples, provided book’s supporting website, geocompr.github.io.Impatient readers welcome dive straight practical examples, starting Chapter 2.\nHowever, recommend reading wider context Geocomputación con R Chapter 1 first.\nnew R, also recommend learning language attempting run code chunks provided chapter (unless ’re reading book understanding concepts).\nFortunately R beginners R supportive community developed wealth resources can help.\nparticularly recommend three tutorials: R Data Science (Grolemund Wickham 2016) Efficient R Programming (Gillespie Lovelace 2016), especially Chapter 2 (installing setting-R/RStudio) Chapter 10 (learning learn), introduction R (Venables, Smith, Team 2017).","code":""},{"path":"preface.html","id":"why-r","chapter":"Preface","heading":"Why R?","text":"Although R steep learning curve, command-line approach advocated book can quickly pay .\n’ll learn subsequent chapters, R effective tool tackling wide range geographic data challenges.\nexpect , practice, R become program choice geospatial toolbox many applications.\nTyping executing commands command-line , many cases, faster pointing--clicking around graphical user interface (GUI) desktop GIS.\napplications Spatial Statistics modeling R may realistic way get work done.outlined Section ??, many reasons using R geocomputation:\nR well-suited interactive use required many geographic data analysis workflows compared languages.\nR excels rapidly growing fields Data Science (includes data carpentry, statistical learning techniques data visualization) Big Data (via efficient interfaces databases distributed computing systems).\nFurthermore R enables reproducible workflow: sharing scripts underlying analysis allow others build-work.\nensure reproducibility book made source code available github.com/Robinlovelace/geocompr.\nfind script files code/ folder generate figures:\ncode generating figure provided main text book, name script file generated provided caption (see example caption Figure ??).languages Python, Java C++ can used geocomputation excellent resources learning geocomputation without R, discussed Section ??.\nNone provide unique combination package ecosystem, statistical capabilities, visualization options, powerful IDEs offered R community.\nFurthermore, teaching use one language (R) depth, book equip concepts confidence needed geocomputation languages.","code":""},{"path":"preface.html","id":"real-world-impact","chapter":"Preface","heading":"Real-world impact","text":"Geocomputación con R equip knowledge skills tackle wide range issues, including scientific, societal environmental implications, manifested geographic data.\ndescribed Section ??, geocomputation using computers process geographic data:\nalso real-world impact.\ninterested wider context motivations behind book, read ; covered Chapter 1.","code":""},{"path":"preface.html","id":"acknowledgements","chapter":"Preface","heading":"Acknowledgements","text":"Many thanks everyone contributed directly indirectly via code hosting collaboration site GitHub, including following people contributed direct via pull requests: prosoitos, florisvdh, katygregg, rsbivand, KiranmayiV, zmbc, erstearns, MikeJohnPage, eyesofbambi, nickbearman, tyluRp, marcosci, giocomai, KHwong12, LaurieLBaker, MarHer90, mdsumner, pat-s, gisma, ateucher, annakrystalli, DarrellCarvalho, kant, gavinsimpson, Henrik-P, Himanshuteli, yutannihilation, jbixon13, yvkschaefer, katiejolly, layik, mpaulacaldas, mtennekes, mvl22, ganes1410, richfitz, wdearden, yihui, chihinl, cshancock, gregor-d, jasongrahn, p-kono, pokyah, schuetzingit, sdesabbata, tim-salabim, tszberkowitz.\nSpecial thanks Marco Sciaini, created front cover image, also published code generated (see code/frontcover.R book’s GitHub repo).\nDozens people contributed online, raising commenting issues, providing feedback via social media.\n#geocompr hashtag live !like thank John Kimmel CRC Press, worked us two years take ideas early book plan production via four rounds peer review.\nreviewers deserve special mention : detailed feedback expertise substantially improved book’s structure content.thank Patrick Schratz Alexander Brenning University Jena fruitful discussions input Chapters ?? ??.\nthank Emmanuel Blondel Food Agriculture Organization United Nations expert input section web services;\nMichael Sumner critical input many areas book, especially discussion algorithms Chapter 10;\nTim Appelhans David Cooley key contributions visualization chapter (Chapter 8);\nKaty Gregg, proofread every chapter greatly improved readability book.Countless others mentioned contributed myriad ways.\nfinal thank software developers make Geocomputación con R possible.\nEdzer Pebesma (created sf package), Robert Hijmans (created raster) Roger Bivand (laid foundations much R-spatial software) made high performance geographic computing possible R.","code":""},{"path":"intro.html","id":"intro","chapter":"1 Introducción","heading":"1 Introducción","text":"Este libro trata de utilizar el poder de los ordenadores para hacer cosas con los datos geográficos.\nEnseña una serie de habilidades espaciales, entre las que se incluyen: la lectura, escritura y manipulación de datos geográficos; la elaboración de mapas estáticos e interactivos; la aplicación de la geocomputación para resolver problemas del mundo real; y la modelización de fenómenos geográficos.\nAl demostrar cómo se pueden enlazar varias operaciones geográficas, en “trozos de código” reproducibles que intercalan la prosa, el libro también enseña un flujo de trabajo transparente y, por tanto, científico.\nAprender utilizar la gran cantidad de herramientas geoespaciales disponibles en la línea de comandos de R puede ser emocionante, pero crear otras nuevas puede ser realmente liberador.\nEl uso del enfoque basado en la línea de comandos que se enseña lo largo del libro, y las técnicas de programación que se tratan en el capítulo ??, pueden ayudar eliminar las restricciones tu creatividad impuestas por el software.\nPor lo tanto, después de leer el libro y completar los ejercicios, deberías sentirte capacitado con una sólida comprensión de las posibilidades abiertas por las impresionantes capacidades geográficas de R, nuevas habilidades para resolver problemas del mundo real con datos geográficos, y la capacidad de comunicar tu trabajo con mapas y código reproducible.En las últimas décadas, el software libre y de código abierto dedicado al ámbito geoespacial (FOSS4G) ha progresado un ritmo asombroso.\nGracias organizaciones como OSGeo, el análisis de datos geográficos ha dejado de ser algo exclusivo de quienes disponen de caros hardware y software: ahora cualquiera puede descargar y ejecutar bibliotecas espaciales de alto rendimiento.\nLos Sistemas de Información Geográfica (SIG, o GIS en inglés) de código abierto, como QGIS, han hecho accesible el análisis geográfico en todo el mundo. Los programas SIG tienden enfatizar las interfaces gráficas para el usuario (GUIs), con la consecuencia deseada de desalentar la reproducibilidad (aunque muchos pueden utilizarse desde la línea de comandos, como veremos en el capítulo ??).\nR, por el contrario, hace énfasis en la interfaz de la línea de comandos (CLI). Una comparación simplista entre los diferentes enfoques se ilustra en la Tabla 1.1.TABLE 1.1: Diferencias de énfasis entre los paquetes software (Interfaz gráfica del usuario (Graphical User Interface, GUI en inglés) de los Sistemas de Información Geográfica (GIS) y R).Este libro está motivado por la importancia de la reproducibilidad para la investigación científica (véase la nota inferior).\nSu objetivo es hacer más accesibles los flujos de trabajo de los análisis de datos geográficos reproducibles, y demostrar el poder del software geoespacial abierto disponible desde la línea de comandos.\n“Las interfaces para otros software forman parte de R” (Eddelbuettel Balamuta 2018).\nEsto significa que, además de las destacadas capacidades “internas”, R permite el acceso muchas otras bibliotecas de software espacial, explicadas en la sección ?? y demostradas en el capítulo ??.\nSin embargo, antes de entrar en los detalles del software, vale la pena dar un paso atrás y pensar en lo que entendemos por geocomputación.La reproducibilidad es una de las principales ventajas de las interfaces de línea de comandos, pero ¿qué significa en la práctica?\nLa definimos del siguiente modo:“Un proceso en el que los mismos resultados pueden ser generados por otros utilizando un código públicamente accesible”.","code":""},{"path":"intro.html","id":"qué-es-la-geocomputación","chapter":"1 Introducción","heading":"1.1 ¿Qué es la geocomputación?","text":"‘Geocomputación’ es un término joven, que se remonta la primera conferencia sobre el tema en 1996.1Lo que distingue la geocomputación del término comúnmente utilizado (en aquel momento) “geografía cuantitativa”, según propusieron sus primeros defensores, es su énfasis en las aplicaciones “creativas y experimentales” (Longley et al. 1998) y en el desarrollo de nuevas herramientas y métodos (Openshaw Abrahart 2000):\n“La geocomputación consiste en utilizar los distintos tipos de geodatos y en desarrollar geoherramientas relevantes dentro del contexto general de un enfoque ‘científico’”.\nEste libro pretende ir más allá de la enseñanza de los métodos y el código; al final de él, deberías ser capaz de utilizar tus conocimientos de geocomputación para realizar “un trabajo práctico que sea beneficioso o útil” (Openshaw Abrahart 2000).Sin embargo, nuestro enfoque difiere de los primeros en adoptarlo, como Stan Openshaw, en su énfasis en la reproducibilidad y la colaboración.\nprincipios del siglo XXI, era realista esperar que los lectores pudieran reproducir los ejemplos de código, debido las barreras que impedían el acceso al hardware, el software y los datos necesarios.\nSi avanzamos dos décadas, las cosas han progresado rápidamente.\nCualquiera que tenga acceso un ordenador portátil con aproximadamente 4 GB de RAM puede esperar de forma realista poder instalar y ejecutar software de geocomputación sobre conjuntos de datos de acceso público, que están más disponibles que nunca (como veremos en el capítulo ??).2\ndiferencia de los primeros trabajos en este campo, todo el trabajo presentado en este libro es reproducible utilizando el código y los datos de ejemplo proporcionados junto con el libro, en paquetes de R como spData, cuya instalación se trata en el capítulo 2.La geocomputación está estrechamente relacionada con otros términos como: Ciencia de la Información Geográfica (GIScience); Geomática; Geoinformática; Ciencia de la Información Espacial; Ingeniería de la Geoinformación (Longley 2015); y Ciencia de los Datos Geográficos (GDS).\nTodos los términos comparten el énfasis en un enfoque “científico” (que implica que es reproducible y falsable) influenciado por los SIG, aunque sus orígenes y principales campos de aplicación difieren.\nLa GDS, por ejemplo, enfatiza las habilidades de la “ciencia de datos” y los grandes conjuntos de datos, mientras que la Geoinformática tiende centrarse en las estructuras de datos.\nPero los solapamientos entre los términos son mayores que las diferencias entre ellos y utilizamos la geocomputación como un sinónimo aproximado que los engloba todos:\ntodos tratan de utilizar los datos geográficos para el trabajo científico aplicado.\nSin embargo, diferencia de los primeros usuarios del término, pretendemos dar entender que existe un campo académico cohesionado llamado “Geocomputación” (o “GeoComputación”, como lo llamaba Stan Openshaw).\nEn cambio, definimos el término de la siguiente manera: trabajar con datos geográficos de forma computacional, centrándose en el código, la reproducibilidad y la modularidad.La geocomputación es un término reciente pero está influenciado por ideas antiguas.\nPuede considerarse parte de la Geografía, la cual tiene más de 2000 años de historia (Talbert 2014); y una extensión de los Sistemas de Información Geográfica (SIG) (Neteler Mitasova 2008), los cuales surgieron en la década de 1960 (Coppock Rhind 1991).Sin embargo, la geografía ha desempeñado un papel importante la hora de explicar e influir la relación de la humanidad con el mundo natural mucho antes de la invención del ordenador.\nLos viajes de Alexander von Humboldt Sudamérica principios del siglo XIX ilustran este papel:\nlas observaciones resultantes solo sentaron las bases de las tradiciones de la geografía física y vegetal, sino que también allanaron el camino hacia las políticas de protección del mundo natural (Wulf 2015).\nEste libro pretende contribuir la “Tradición Geográfica” (Livingstone 1992) aprovechando la potencia de los ordenadores modernos y el software de código abierto.Los vínculos del libro con disciplinas más antiguas se reflejaron en los títulos sugeridos para el libro: Geografía con R y R para SIG.\nCada uno tiene sus ventajas.\nEl primero transmite el mensaje de que comprende mucho más que datos espaciales:\nlos datos de atributos espaciales se entremezclan inevitablemente con los datos geométricos, y la Geografía trata de algo más que de dónde está algo en el mapa.\nEl segundo comunica que este un libro sobre el uso de R como un SIG, para realizar operaciones espaciales sobre datos geográficos (Bivand, Pebesma, Gómez-Rubio 2013).\nSin embargo, el término SIG transmite algunas connotaciones (véase la Tabla 1.1) que simplemente comunican una de las mayores fortalezas de R:\nsu capacidad basada en la consola para cambiar sin problemas entre las tareas de procesamiento, modelado y visualización de datos geográficos y geográficos.\nPor el contrario, el término geocomputación implica una programación reproducible y creativa.\nPor supuesto, los algoritmos (geocomputacionales) son herramientas poderosas que pueden llegar ser altamente complejas.\nSin embargo, todos los algoritmos se componen de partes más pequeñas.\nAl enseñarte sus fundamentos y su estructura subyacente, pretendemos capacitarte para crear tus propias soluciones innovadoras los problemas de datos geográficos.","code":""},{"path":"intro.html","id":"por-qué-usar-r-para-la-geocomputación","chapter":"1 Introducción","heading":"1.2 ¿Por qué usar R para la geocomputación?","text":"Los primeros geógrafos utilizaron diversas herramientas, como barómetros, brújulas y sextantes, para avanzar en el conocimiento del mundo (Wulf 2015). Solo con la invención del cronómetro marino en 1761 fue posible calcular la longitud en el mar, lo que permitió los barcos tomar rutas más directas.Hoy en día es difícil imaginar tal falta de datos geográficos.\nTodos los teléfonos inteligentes tienen un receptor de posicionamiento global (GPS) y una multitud de sensores en dispositivos que van desde satélites y vehículos semiautónomos hasta científicos ciudadanos que miden incesantemente cada parte del mundo.\nEl ritmo de producción de datos es abrumador.\nUn vehículo autónomo, por ejemplo, puede generar 100 GB de datos al día (Economist 2016).\nLos datos de teledetección de los satélites se han vuelto demasiado grandes para analizar los datos correspondientes con un solo ordenador, lo que ha dado lugar iniciativas como OpenEO.Esta “revolución de los geodatos” impulsa la demanda de equipos informáticos de alto rendimiento y de software eficientes y escalables para manejar y extraer la señal del ruido, con el fin de comprender y quizás cambiar el mundo.\nLas bases de datos espaciales permiten almacenar y generar subconjuntos manejables de los vastos almacenes de datos geográficos, haciendo que las interfaces para obtener conocimientos de ellos sean herramientas vitales para el futuro.\nR es una de esas herramientas, con capacidades avanzadas de análisis, modelización y visualización.\nEn este contexto, el libro se centra en el lenguaje en sí (véase Wickham 2014).\nEn su lugar, utilizamos R como una “herramienta para trabajar” para entender el mundo, de forma similar al uso que Humboldt hizo de las herramientas para obtener una comprensión profunda de la naturaleza en toda su complejidad e interconexiones (véase Wulf 2015).\nAunque la programación puede parecer una actividad reduccionista, el objetivo es enseñar geocomputación con R solo por diversión, sino para entender el mundo.R es un lenguaje y entorno de código abierto y multiplataforma para la computación estadística y los gráficos (r-project.org/).\nCon una amplia gama de paquetes, R también permite la estadística geoespacial avanzada, la modelización y la visualización.\n\nLos nuevos entornos de desarrollo integrados (IDE), como RStudio, han hecho que R sea más fácil de usar para muchos, facilitando la elaboración de mapas con un panel dedicado la visualización interactiva.En su esencia, R es un lenguaje de programación funcional orientado objetos (Wickham 2014), y fue diseñado específicamente como una interfaz interactiva para otro software (Chambers 2016).\nEste último también incluye muchos “puentes” hacia el hallazgo de un tesoro del software SIG, “geolibrerías” y funciones (véase el capítulo ??).\nPor tanto, es ideal para crear rápidamente “geoherramientas”, sin necesidad de dominar lenguajes de nivel inferior (en comparación con R) como C, FORTRAN o Java (véase la sección ??).\n\nEsto puede ser como liberarse del metafórico “techo de cristal” impuesto por los sistemas de información geográfica basados en GUI o patentados (véase la Tabla 1.1 para una definición de GUI).\nAdemás, R facilita el acceso otros lenguajes:\nlos paquetes Rcpp y reticulate permiten acceder código de C++ y Python, por ejemplo.\nEsto significa que R puede utilizarse como “puente” hacia una amplia gama de programas geoespaciales (véase la sección ??).Otro ejemplo que muestra la flexibilidad y la evolución de las capacidades geográficas de R es la elaboración de mapas interactivos.\nComo veremos en el Capítulo ??, la afirmación de que R tiene “facilidades interactivas [para elaborar gráficos] limitadas” (Bivand, Pebesma, Gómez-Rubio 2013) ya es cierta.\nAsí lo demuestra el siguiente fragmento de código, que crea la Figura 1.1 (las funciones que generan el gráfico se tratan en la Sección ??).\nFIGURE 1.1: Los marcadores azules indican la procedencia de los autores. El mapa base es una imagen en mosaico de la Tierra de noche proporcionada por la NASA. Interactúa con la versión en línea en geocompr.robinlovelace.net, por ejemplo, ampliando la imagen y haciendo clic en las ventanas emergentes.\nHace unos años habría sido difícil elaborar la Figura 1.1 con R, más aún en forma de mapa interactivo.\nEsto ilustra la flexibilidad de R y cómo, gracias desarrollos como knitr y leaflet, puede utilizarse como interfaz con otro software, un tema que se repetirá lo largo de este libro.\nEl uso del código de R, por tanto, permite enseñar geocomputación con referencia ejemplos reproducibles como el proporcionado en la Figura 1.1 en lugar de conceptos abstractos.","code":"\nlibrary(leaflet)\npopup = c(\"Robin\", \"Jakub\", \"Jannes\", \"Mireia\")\nleaflet() %>%\n  addProviderTiles(\"NASAGIBS.ViirsEarthAtNight2012\") %>%\n  addMarkers(lng = c(-3, 23, 11, 2),\n             lat = c(52, 53, 49, 42), \n             popup = popup)"},{"path":"intro.html","id":"software-para-geocomputación","chapter":"1 Introducción","heading":"1.3 Software para geocomputación","text":"R es un poderoso lenguaje para la geocomputación, pero hay muchas otras opciones para el análisis de datos geográficos que ofrecen miles de funciones geográficas.\nEl conocimiento de otros lenguajes para la geocomputación ayudará decidir cuándo una herramienta diferente puede ser más apropiada para una tarea específica, y situar R en el amplio ecosistema geoespacial.\nEsta sección presenta brevemente los lenguajes C++, Java y Python para la geocomputación, como preparación para el capítulo ??.Una importante característica de R (y de Python) es que es un lenguaje interpretado.\nEsto es ventajoso porque permite la programación interactiva en un bucle de lectura-evaluación-impresión (REPL):\nel código introducido en la consola se ejecuta inmediatamente y el resultado se imprime, en lugar de esperar la etapa intermedia de compilación. Por otra parte, los lenguajes compilados, como C++ y Java, tienden ejecutarse más rápidamente (una vez que han sido compilados).C++ proporciona la base de muchos paquetes SIG, como QGIS, GRASS y SAGA, por lo que es un punto de partida apropiado.\nEl C++ bien escrito es muy rápido, lo que lo convierte en una buena opción para aplicaciones de rendimiento crítico, como el procesamiento de grandes conjuntos de datos geográficos, pero es más difícil de aprender que Python o R.\nEl C++ se ha vuelto más accesible con el paquete Rcpp, el cual proporciona una buena \" vía de entrada \" la programación en C para los usuarios de R.\nEl dominio de estos lenguajes de bajo nivel abre la posibilidad de crear nuevos “geoalgoritmos” de alto rendimiento y de comprender mejor el funcionamiento del software SIG (véase el capítulo ??).Java es otro lenguaje importante y versátil para la geocomputación.\nLos paquetes de SIG gvSig, OpenJump y uDig están escritos en Java.\nHay muchas bibliotecas de SIG escritas en Java, como GeoTools y JTS, la Topología Suite de Java (GEOS es un puerto C++ de JTS).\nAdemás, muchas aplicaciones de servidores de mapas utilizan Java, como Geoserver/Geonode, deegree y 52°North WPS.La sintaxis orientada objetos de Java es similar la de C++.\nUna de las principales ventajas de Java es que es independiente de las plataformas (lo que es inusual para un lenguaje compilado) y es altamente escalable, lo cual lo convierte en un lenguaje adecuado para IDEs como RStudio, con el cual se ha escrito este libro.\nJava tiene menos herramientas para el modelado estadístico y la visualización que Python o R, aunque puede utilizarse para la ciencia de datos (Brzustowicz 2017).Python es un lenguaje importante para la geocomputación, especialmente porque muchos SIG de escritorio, como GRASS, SAGA y QGIS, proporcionan una API de Python (véase el capítulo ??).\nAl igual que R, es una herramienta popular para la ciencia de los datos.\nAmbos lenguajes están orientados objetos y tienen muchas áreas de solapamiento, lo cual ha llevado iniciativas como el paquete reticulate, que facilita el acceso Python desde R, y la iniciativa de Ursa Labs para apoyar las bibliotecas portátiles en beneficio de todo el ecosistema de ciencia de datos de código abierto.En la práctica, tanto R como Python tienen sus puntos fuertes y, hasta cierto punto, cuál de ellos se utiliza es menos importante que el ámbito de aplicación y la comunicación de los resultados.\nEl aprendizaje de cualquiera de los dos permite empezar aprender el otro.\nSin embargo, R tiene grandes ventajas sobre Python para la geocomputación.\nEntre ellas se encuentra el hecho de que soporta mucho mejor los modelos de datos geográficos vectoriales y rasterizados en el propio lenguaje (véase el capítulo 2) y las correspondientes posibilidades de visualización (véanse los capítulos 2 y ??).\nIgualmente importante es el hecho de que R tiene un soporte incomparable para la estadística, incluida la estadística espacial, con cientos de paquetes (diferencia de Python) que soportan miles de métodos estadísticos.La mayor ventaja de Python es que es un lenguaje de programación de propósito general.\nSe utiliza en muchos ámbitos, como el software de escritorio, los juegos de ordenador, los sitios web y la ‘ciencia de los datos’.\nPython es menudo el único lenguaje compartido entre diferentes comunidades (de geocomputación) y puede considerarse como el “pegamento” que mantiene unidos muchos programas de SIG.\nSe puede acceder muchos geoalgoritmos, incluidos los de QGIS y ArcMap, desde la línea de comandos de Python, lo que lo convierte en un lenguaje idóneo para iniciarse en los SIG de línea de comandos.^[Los módulos de Python que proporcionan acceso los geoalgoritmos incluyen grass.script para GRASS,\nsaga-python para SAGA-GIS,\nprocessing para QGIS y arcpy para ArcGIS.\n]Sin embargo, para la estadística espacial y el modelado predictivo, R es considerablemente mejor.\nEsto significa que haya que elegir entre R o Python: Python soporta la mayoría de las técnicas estadísticas comunes (aunque R tiende soportar antes los nuevos desarrollos en estadística espacial) y muchos conceptos aprendidos en Python pueden aplicarse al mundo de R.\nAl igual que R, Python también soporta el análisis y la manipulación de datos geográficos con paquetes como osgeo, Shapely, NumPy y PyGeoProcessing (Garrard 2016).","code":""},{"path":"intro.html","id":"el-ecosistema-espacial-de-r","chapter":"1 Introducción","heading":"1.4 El ecosistema espacial de R","text":"Hay muchas maneras de manejar datos geográficos en R, con docenas de paquetes en el área.3\nEn este libro nos esforzamos por enseñar el estado del arte en el campo, al tiempo que nos aseguramos de que los métodos estén preparados para el futuro.\nAl igual que muchas áreas de desarrollo de software, el ecosistema espacial de R está evolucionando rápidamente (Figura 1.2).\nPuesto que R es de código abierto, estos desarrollos pueden construirse fácilmente partir de trabajos anteriores, “subiendo hombros de gigantes”, como dijo Isaac Newton en 1675.\nEste enfoque es ventajoso porque fomenta la colaboración y evita “reinventar la rueda”.\nEl paquete sf (tratado en el capítulo 2), por ejemplo, se basa en su predecesor sp.El aumento del tiempo de desarrollo (y del interés) en ‘R-spatial’ se ha producido tras la concesión de una subvención por parte del R Consortium para el desarrollo del soporte para Funciones Simples, un estándar y modelo de código abierto para almacenar y acceder geometrías vectoriales.\nEsto dio lugar al paquete sf (tratado en la sección 2.2.1).\nMúltiples sitios reflejan el inmenso interés por sf.\nEsto es especialmente cierto en el caso de los archivos de R-sig-Geo Archives, una lista de correos electrónicos en abierto que contiene mucha sabiduría de R-spatial acumulada lo largo de los años.\nFIGURE 1.2: La popularidad de los paquetes espaciales en R. El eje Y muestra el número medio de descargas por día, dentro de una ventana móvil de 30 días, de paquetes espaciales destacados.\nCabe destacar que los cambios en la comunidad de R en general, como por ejemplo el paquete de procesamiento de datos dplyr (publicado en 2014), han influido en los cambios del ecosistema espacial de R.\nJunto con otros paquetes que tienen un estilo compartido y un énfasis en los “datos ordenados” (“tidy data”) (incluyendo, por ejemplo, ggplot2), dplyr se colocó en el “metapaquete” tidyverse finales de 2016.El enfoque de tidyverse, centrado en los datos de forma larga y en las funciones rápidas de nombre intuitivo, se ha hecho inmensamente popular.\nEsto ha dado lugar una demanda de “datos geográficos ordenados” que ha sido satisfecha en parte por sf y otros enfoques como tabularaster.\nUna característica evidente del tidyverse es la tendencia que los paquetes trabajen en armonía.\nexiste un ‘geoverso’ equivalente, pero hay intentos de armonización entre los paquetes alojados en la organización r-spatial y el número creciente de paquetes que utilizan sf (Tabla 1.2).TABLE 1.2: Los 5 paquetes más descargados que dependen de sf, en términos de número medio de descargas por día durante el mes anterior. partir del 2021-08-22 hay 383 paquetes que importan sf.","code":""},{"path":"intro.html","id":"la-historia-de-r-spatial","chapter":"1 Introducción","heading":"1.5 La historia de R-spatial","text":"El uso de paquetes espaciales recientes como sf tiene muchas ventajas, pero también es importante ser consciente de la historia de las capacidades espaciales de R: muchas funciones, casos de uso y material didáctico están contenidos en paquetes más antiguos.\nEstos pueden seguir siendo útiles hoy en día, siempre que se sepa dónde buscar.\n\nLas capacidades espaciales de R se originaron en los primeros paquetes espaciales del lenguaje S (Bivand Gebhardt 2000).\n\nEn la década de 1990 se desarrollaron numerosos scripts en S y un puñado de paquetes para la estadística espacial.\nLos paquetes de R surgieron partir de ellos y en el año 2000 había paquetes de R para varios métodos espaciales “análisis de patrones puntuales, geoestadística, análisis exploratorio de datos espaciales y econometría espacial”, según un artículo presentado en GeoComputation 2000 (Bivand Neteler 2000).\nAlgunos de ellos, especialmente spatial, sgeostat y splancs, siguen estando disponibles en CRAN (Rowlingson Diggle 1993, 2017; Venables Ripley 2002; Majure Gebhardt 2016).Un artículo posterior en R News (el predecesor de R Journal) contenía una visión general del software estadístico espacial en R en ese momento, gran parte del cual se basaba en código anterior escrito para S/S-PLUS (Ripley 2001).\nEsta visión general describía paquetes para el suavizado y la interpolación espacial, incluyendo akima y geoR (Akima Gebhardt 2016; Ribeiro Jr Diggle 2016), y el análisis de patrones de puntos, incluyendo splancs (Rowlingson Diggle 2017) y spatstat (Baddeley, Rubak, Turner 2015).La siguiente publicación de R News (Volumen 1/3) volvió poner los paquetes espaciales en el punto de mira, con una introducción más detallada splancs y un comentario sobre las perspectivas futuras de la estadística espacial (Bivand 2001).\nAdemás, la publicación introdujo dos paquetes para probar la autocorrelación espacial que finalmente se convirtieron en parte de spdep (Bivand 2017).\nEn particular, el comentario menciona la necesidad de estandarizar las interfaces espaciales, los mecanismos eficientes para el intercambio de datos con SIG y el manejo de metadatos espaciales como los sistemas de referencia de coordenadas (CRS).maptools (escrito por Nicholas Lewin-Koh; Bivand Lewin-Koh 2017) es otro paquete importante de esta época.\nInicialmente, maptools solo contenía una envoltura alrededor de shapelib y permitía la lectura de ESRI Shapefiles en listas anidadas de geometría.\nLa clase S3 correspondiente y hoy en día obsoleta llamada “Map” almacenaba esta lista junto un dataframe de atributos.\nEl trabajo sobre la representación de la clase “Map” fue, sin embargo, importante, ya que alimentó directamente sp antes de su publicación en CRAN.En 2003, Roger Bivand publicó una revisión extendida de los paquetes espaciales.\nPropuso un sistema de clases para soportar los “objetos de datos ofrecidos por GDAL”, incluyendo los tipos ‘fundamentales’ punto, línea, polígono y raster.\nAdemás, sugería que las interfaces con bibliotecas externas debían ser la base de los paquetes modulares de R (Bivand 2003).\nEn gran medida, estas ideas se materializaron en los paquetes rgdal y sp.\nEstos proporcionaron una base para el análisis de datos espaciales con R, tal como se describe en Análisis de datos espaciales aplicados con R (Applied Spatial Data Analysis R en inglés) (ASDAR) (Bivand, Pebesma, Gómez-Rubio 2013), publicado por primera vez en 2008.\nDiez años más tarde, las capacidades espaciales de R han evolucionado sustancialmente, pero siguen basándose en las ideas expuestas por Bivand (2003):\nlas interfaces para GDAL y PROJ, por ejemplo, siguen potenciando las capacidades de /O de datos geográficos de alto rendimiento y de transformación de CRS (véanse los capítulos ?? y ??, respectivamente).rgdal, publicado en 2003, proporcionó vínculos GDAL para R que mejoraron en gran medida su capacidad para importar datos de formatos de datos geográficos que antes estaban disponibles.\nLa versión inicial sólo admitía controladores raster, pero las mejoras posteriores proporcionaron soporte para sistemas de referencia de coordenadas (través de la librería PROJ), reproyecciones e importación de formatos de archivos vectoriales (véase el capítulo ?? para más información sobre los formatos de archivo).\nMuchas de estas capacidades adicionales fueron desarrolladas por Barry Rowlingson y publicadas en el código base de rgdal en 2006 (véase Rowlingson et al. 2003 y R-help(véase Rowlingson et al. 2003 y la lista de correos electrónicos de R-help para el contexto).sp, publicado en 2005, superó la incapacidad de R para distinguir entre los objetos espaciales y los espaciales (Pebesma Bivand 2005).\nsp surgió de un taller celebrado en Viena en 2003 y estuvo alojado en sourceforge antes de migrar R-Forge.\n\n\nAntes de 2005, las coordenadas geográficas se trataban generalmente como cualquier otro número.\nsp cambió esto con sus clases y métodos genéricos que soportan puntos, líneas, polígonos y cuadrículas, y datos de atributos.sp almacena información como el cuadro delimitador, el sistema de referencia de coordenadas y los atributos en ranuras de objetos espaciales que utilizan el sistema de clases S4, lo que permite que las operaciones de datos funcionen con datos geográficos (véase la sección 2.2.2).\nAdemás, sp proporciona métodos genéricos como summary() y plot() para datos geográficos.\nEn la década siguiente, las clases sp se popularizaron rápidamente para los datos geográficos en R y el número de paquetes que dependían de él se incrementó de unos 20 en 2008 más de 100 en 2013 (Bivand, Pebesma, Gómez-Rubio 2013).En 2018, casi 500 paquetes dependen de sp, lo que lo convierte en una parte importante del ecosistema de R.\nEntre los paquetes R más destacados que utilizan sp se encuentran: gstat, para geoestadística espacial y espacio-temporal; geosphere, para trigonometría esférica; y adehabitat, utilizado para el análisis de la selección de hábitat por parte de los animales (E. Pebesma Graeler 2018; Calenge 2006; Hijmans 2016).Mientras que rgdal y sp resolvían muchos problemas espaciales, R seguía careciendo de la capacidad de realizar operaciones geométricas (véase el capítulo ??).\nColin Rundel abordó este problema desarrollando rgeos, una interfaz de R para la librería de geometría en código abierto (GEOS) durante un proyecto de Google Summer Code en 2010 (Bivand Rundel 2018).\nrgeos permitió GEOS manipular objetos sp, con funciones como gIntersection().Otra limitación de sp — su limitado apoyo los datos raster — fue superada por raster, publicado por primera vez en 2010 (Hijmans 2017).\nSu sistema de clases y sus funciones soportan una serie de operaciones de rasterización, como se indica en la sección 2.3.\nUna característica clave de raster es su capacidad para trabajar con conjuntos de datos que son demasiado grandes para caber en la memoria RAM (la interfaz de R con PostGIS admite operaciones fuera del disco sobre datos geográficos vectoriales).\nraster también admite el álgebra de mapas (véase la sección ??).Paralelamente estos desarrollos de sistemas de clases y métodos, llegó el apoyo R como interfaz para el software SIG dedicado.\nGRASS (R. S. Bivand 2000) y los paquetes posteriores spgrass6 y rgrass7 (para GRASS GIS 6 y 7, respectivamente) fueron ejemplos destacados en esta dirección (Bivand 2016a, 2016b).\nOtros ejemplos de puentes entre R y SIG son RSAGA (Brenning, Bangs, Becker 2018, publicado por primera vez en 2008), RPyGeo (Brenning 2012, publicado por primera vez en 2008) y RQGIS (Muenchow, Schratz, Brenning 2017, publicado por primera vez en 2016) (véase el capítulo ??).La visualización fue un foco de atención al principio, ya que la mayor parte del desarrollo de R-spatial se centró en el análisis y las operaciones geográficas.\nsp proporcionó métodos para la elaboración de mapas utilizando el sistema de graficación de base y de lattice, pero la demanda estaba creciendo para las capacidades de elaboración de mapas avanzados, especialmente después del lanzamiento de ggplot2 en 2007.\nggmap amplió las capacidades espaciales de ggplot2 (Kahle Wickham 2013), facilitando el acceso los segmentos del “basemap” desde servicios en línea como Google Maps.\nAunque ggmap facilitaba la elaboración de mapas con ggplot2, su utilidad estaba limitada por la necesidad de fortificar los objetos espaciales, lo que significa convertirlos en largos dataframes.\nAunque esto funciona bien para los puntos, es computacionalmente ineficiente para las líneas y los polígonos, ya que cada coordenada (vértice) se convierte en una fila, lo que da lugar enormes dataframes para representar geometrías complejas.\nAunque la visualización geográfica tendía centrarse en los datos vectoriales, la visualización rasterizada está soportada en raster y recibió un impulso con el lanzamiento de rasterVis, el cual se describe en un libro sobre el tema de la visualización de datos espaciales y temporales (Lamigueiro 2018).\npartir de 2018, la creación de mapas en R es un tema candente con paquetes dedicados como tmap, leaflet y mapview, todos ellos compatibles con el sistema de clases proporcionado por sf, en el cual se centra el siguiente capítulo (véase el capítulo ?? para obtener más información sobre la visualización).","code":""},{"path":"intro.html","id":"ejercicios","chapter":"1 Introducción","heading":"1.6 Ejercicios","text":"Piensa en los términos “SIG” (Sistemas de Información Geográfica o GIS en inglés), “GDS” y “geocomputación” descritos anteriormente. ¿Cuál de ellos (si es que hay alguno) describe mejor el trabajo que te gustaría realizar utilizando métodos y software de geocomputación y por qué?Piensa en los términos “SIG” (Sistemas de Información Geográfica o GIS en inglés), “GDS” y “geocomputación” descritos anteriormente. ¿Cuál de ellos (si es que hay alguno) describe mejor el trabajo que te gustaría realizar utilizando métodos y software de geocomputación y por qué?Indica tres razones para utilizar un lenguaje de programación como R para la geocomputación en lugar de utilizar un programa SIG establecido como QGIS.Indica tres razones para utilizar un lenguaje de programación como R para la geocomputación en lugar de utilizar un programa SIG establecido como QGIS.Menciona dos ventajas y dos desventajas sobre utilizar paquetes maduros frente los recientes para el análisis de datos geográficos (por ejemplo, sp frente sf).Menciona dos ventajas y dos desventajas sobre utilizar paquetes maduros frente los recientes para el análisis de datos geográficos (por ejemplo, sp frente sf).","code":""},{"path":"spatial-class.html","id":"spatial-class","chapter":"2 Geographic data in R","heading":"2 Geographic data in R","text":"","code":""},{"path":"spatial-class.html","id":"prerequisites","chapter":"2 Geographic data in R","heading":"Prerequisites","text":"first practical chapter book, therefore comes software requirements.\nassume --date version R installed comfortable using software command-line interface integrated development environment (IDE) RStudio.\nnew R, recommend reading Chapter 2 online book Efficient R Programming Gillespie Lovelace (2016) learning basics language reference resources Grolemund Wickham (2016).\nOrganize work (e.g., RStudio projects) give scripts sensible names 02-chapter.R document code write learn.\npackages used chapter can installed following commands:4All packages needed reproduce contents book can installed following command: remotes::install_github(\"geocompr/geocompkg\").\nnecessary packages can ‘loaded’ (technically attached) library() function follows:output library(sf) reports versions key geographic libraries GEOS package using, outlined Section 2.2.1.packages installed contain data used book:","code":"\ninstall.packages(\"sf\")\ninstall.packages(\"terra\")\ninstall.packages(\"spData\")\ninstall.packages(\"spDataLarge\", repos = \"https://nowosad.r-universe.dev\")\nlibrary(sf)          # classes and functions for vector data\n#> Linking to GEOS 3.9.0, GDAL 3.2.1, PROJ 7.2.1\nlibrary(terra)      # classes and functions for raster data\nlibrary(spData)        # load geographic data\nlibrary(spDataLarge)   # load larger geographic data"},{"path":"spatial-class.html","id":"intro-spatial-class","chapter":"2 Geographic data in R","heading":"2.1 Introduction","text":"chapter provide brief explanations fundamental geographic data models: vector raster.\nintroduce theory behind data model disciplines predominate, demonstrating implementation R.vector data model represents world using points, lines polygons.\ndiscrete, well-defined borders, meaning vector datasets usually high level precision (necessarily accuracy see Section 2.5).\nraster data model divides surface cells constant size.\nRaster datasets basis background images used web-mapping vital source geographic data since origins aerial photography satellite-based remote sensing devices.\nRasters aggregate spatially specific features given resolution, meaning consistent space scalable (many worldwide raster datasets available).use?\nanswer likely depends domain application:Vector data tends dominate social sciences human settlements tend discrete bordersRaster dominates many environmental sciences reliance remote sensing dataThere much overlap fields raster vector datasets can used together:\necologists demographers, example, commonly use vector raster data.\nFurthermore, possible convert two forms (see Section ??).\nWhether work involves use vector raster datasets, worth understanding underlying data model using , discussed subsequent chapters.\nbook uses sf raster packages work vector data raster datasets, respectively.","code":""},{"path":"spatial-class.html","id":"vector-data","chapter":"2 Geographic data in R","heading":"2.2 Vector data","text":"geographic vector data model based points located within coordinate reference system (CRS).\nPoints can represent self-standing features (e.g., location bus stop) can linked together form complex geometries lines polygons.\npoint geometries contain two dimensions (3-dimensional CRSs contain additional \\(z\\) value, typically representing height sea level).system London, example, can represented coordinates c(-0.1, 51.5).\nmeans location -0.1 degrees east 51.5 degrees north origin.\norigin case 0 degrees longitude (Prime Meridian) 0 degree latitude (Equator) geographic (‘lon/lat’) CRS (Figure 2.1, left panel).\npoint also approximated projected CRS ‘Easting/Northing’ values c(530000, 180000) British National Grid, meaning London located 530 km East 180 km North \\(origin\\) CRS.\ncan verified visually: slightly 5 ‘boxes’ — square areas bounded gray grid lines 100 km width — separate point representing London origin (Figure 2.1, right panel).location National Grid’s origin, sea beyond South West Peninsular, ensures locations UK positive Easting Northing values.5\nCRSs, described Sections 2.4 ?? , purposes section, sufficient know coordinates consist two numbers representing distance origin, usually \\(x\\) \\(y\\) dimensions.\nFIGURE 2.1: Illustration vector (point) data location London (red X) represented reference origin (blue circle). left plot represents geographic CRS origin 0° longitude latitude. right plot represents projected CRS origin located sea west South West Peninsula.\nsf package providing class system geographic vector data.\nsf supersede sp, also provides consistent command-line interface GEOS GDAL, superseding rgeos rgdal (described Section ??).\nsection introduces sf classes preparation subsequent chapters (Chapters ?? ?? cover GEOS GDAL interface, respectively).","code":""},{"path":"spatial-class.html","id":"intro-sf","chapter":"2 Geographic data in R","heading":"2.2.1 An introduction to simple features","text":"Simple features open standard developed endorsed Open Geospatial Consortium (OGC), --profit organization whose activities revisit later chapter (Section ??).\n\nSimple Features hierarchical data model represents wide range geometry types.\n17 geometry types supported specification, 7 used vast majority geographic research (see Figure 2.2);\ncore geometry types fully supported R package sf (E. Pebesma 2018).6\nFIGURE 2.2: Simple feature types fully supported sf.\nsf can represent common vector geometry types (raster data classes supported sf): points, lines, polygons respective ‘multi’ versions (group together features type single feature).\n\n\nsf also supports geometry collections, can contain multiple geometry types single object.\nsf provides functionality () previously provided three packages — sp data classes (E. Pebesma Bivand 2018), rgdal data read/write via interface GDAL PROJ (Bivand, Keitt, Rowlingson 2018) rgeos spatial operations via interface GEOS (Bivand Rundel 2018).\nre-iterate message Chapter 1, geographic R packages long history interfacing lower level libraries, sf continues tradition unified interface recent versions GEOS library geometry operations, GDAL library reading writing geographic data files, PROJ library representing transforming projected coordinate reference systems.\nnotable achievement reduces headspace needed ‘context switching ’ different packages enables access high-performance geographic libraries.\nDocumenation sf can found website 6 vignettes, can loaded follows:first vignette explains, simple feature objects R stored data frame, geographic data occupying special column, usually named ‘geom’ ‘geometry’.\nuse world dataset provided spData, loaded beginning chapter (see nowosad.github.io/spData list datasets loaded package).\nworld spatial object containing spatial attribute columns, names returned function names() (last column contains geographic information):contents geom column give sf objects spatial powers: world$geom ‘list column’ contains coordinates country polygons.\n\nsf package provides plot() method visualizing geographic data:\nfollowing command creates Figure 2.3.\nFIGURE 2.3: spatial plot world using sf package, facet attribute.\nNote instead creating single map, GIS programs , plot() command created multiple maps, one variable world datasets.\nbehavior can useful exploring spatial distribution different variables discussed Section 2.2.3 .able treat spatial objects regular data frames spatial powers many advantages, especially already used working data frames.\ncommonly used summary() function, example, provides useful overview variables within world object.Although selected one variable summary command, also outputs report geometry.\ndemonstrates ‘sticky’ behavior geometry columns sf objects, meaning geometry kept unless user deliberately removes , ’ll see Section ??.\nresult provides quick summary non-spatial spatial data contained world: mean average life expectancy 71 years (ranging less 51 83 years median 73 years) across countries.worth taking deeper look basic behavior contents simple feature object, can usefully thought ‘spatial data frame’.sf objects easy subset.\ncode shows first two rows three columns.\noutput shows two major differences compared regular data.frame: inclusion additional geographic data (geometry type, dimension, bbox CRS information - epsg (SRID), proj4string), presence geometry column, named geom:may seem rather complex, especially class system supposed simple.\nHowever, good reasons organizing things way using sf.describing geometry type sf package supports, worth taking step back understand building blocks sf objects.\nSection 2.2.8 shows simple features objects data frames, special geometry columns.\nspatial columns often called geom geometry: world$geom refers spatial element world object described .\ngeometry columns ‘list columns’ class sfc (see Section 2.2.7).\nturn, sfc objects composed one objects class sfg: simple feature geometries describe Section 2.2.6.\n\nunderstand spatial components simple features work, vital understand simple feature geometries.\nreason cover currently supported simple features geometry type Section 2.2.5 moving describe can represented R using sfg objects, form basis sfc eventually full sf objects.","code":"\nvignette(package = \"sf\") # see which vignettes are available\nvignette(\"sf1\")          # an introduction to the package\nnames(world)\n#>  [1] \"iso_a2\"    \"name_long\" \"continent\" \"region_un\" \"subregion\" \"type\"     \n#>  [7] \"area_km2\"  \"pop\"       \"lifeExp\"   \"gdpPercap\" \"geom\"\nplot(world)\nsummary(world[\"lifeExp\"])\n#>     lifeExp                geom    \n#>  Min.   :50.6   MULTIPOLYGON :177  \n#>  1st Qu.:65.0   epsg:4326    :  0  \n#>  Median :72.9   +proj=long...:  0  \n#>  Mean   :70.9                      \n#>  3rd Qu.:76.8                      \n#>  Max.   :83.6                      \n#>  NA's   :10\nworld_mini = world[1:2, 1:3]\nworld_mini\n#> Simple feature collection with 2 features and 3 fields\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -180 ymin: -18.3 xmax: 180 ymax: -0.95\n#> Geodetic CRS:  WGS 84\n#> # A tibble: 2 × 4\n#>   iso_a2 name_long continent                                                geom\n#>   <chr>  <chr>     <chr>                                      <MULTIPOLYGON [°]>\n#> 1 FJ     Fiji      Oceania   (((-180 -16.6, -180 -16.5, -180 -16, -180 -16.1, -…\n#> 2 TZ     Tanzania  Africa    (((33.9 -0.95, 31.9 -1.03, 30.8 -1.01, 30.4 -1.13,…"},{"path":"spatial-class.html","id":"why-simple-features","chapter":"2 Geographic data in R","heading":"2.2.2 Why simple features?","text":"Simple features widely supported data model underlies data structures many GIS applications including QGIS PostGIS.\nmajor advantage using data model ensures work cross-transferable set-ups, example importing exporting spatial databases.\nspecific question R perspective “use sf package sp already tried tested”?\nmany reasons (linked advantages simple features model):Fast reading writing dataEnhanced plotting performancesf objects can treated data frames operationssf functions can combined using %>% operator works well tidyverse collection R packages.sf function names relatively consistent intuitive (begin st_)Due advantages, spatial packages (including tmap, mapview tidycensus) added support sf.\nHowever, take many years packages transition never switch.\nFortunately, can still used workflow based sf objects, converting Spatial class used sp:Spatial objects can converted back sf way st_as_sf():","code":"\nlibrary(sp)\nworld_sp = as(world, Class = \"Spatial\")\n# sp functions ...\nworld_sf = st_as_sf(world_sp)"},{"path":"spatial-class.html","id":"basic-map","chapter":"2 Geographic data in R","heading":"2.2.3 Basic map making","text":"Basic maps created sf plot().\ndefault creates multi-panel plot (like sp’s spplot()), one sub-plot variable object, illustrated left-hand panel Figure 2.4.\nlegend ‘key’ continuous color produced object plotted single variable (see right-hand panel).\nColors can also set col =, although create continuous palette legend.\n\nFIGURE 2.4: Plotting sf, multiple variables (left) single variable (right).\nPlots added layers existing images setting add = TRUE.7\ndemonstrate , provide taster content covered Chapters ?? ?? attribute spatial data operations, subsequent code chunk combines countries Asia:can now plot Asian continent map world.\nNote first plot must one facet add = TRUE work.\nfirst plot key, reset = FALSE must used (result shown):Adding layers way can used verify geographic correspondence layers:\nplot() function fast execute requires lines code, create interactive maps wide range options.\nadvanced map making recommend using dedicated visualization packages tmap (see Chapter ??).","code":"\nplot(world[3:6])\nplot(world[\"pop\"])\nworld_asia = world[world$continent == \"Asia\", ]\nasia = st_union(world_asia)\nplot(world[\"pop\"], reset = FALSE)\nplot(asia, add = TRUE, col = \"red\")"},{"path":"spatial-class.html","id":"base-args","chapter":"2 Geographic data in R","heading":"2.2.4 Base plot arguments","text":"various ways modify maps sf’s plot() method.\nsf extends base R plotting methods plot()’s arguments main = (specifies title map) work sf objects (see ?graphics::plot ?par).8\n\nFigure 2.5 illustrates flexibility overlaying circles, whose diameters (set cex =) represent country populations, map world.\nunprojected version figure can created following commands (see exercises end chapter script 02-contplot.R reproduce Figure 2.5):\nFIGURE 2.5: Country continents (represented fill color) 2015 populations (represented circles, area proportional population).\ncode uses function st_centroid() convert one geometry type (polygons) another (points) (see Chapter ??), aesthetics varied cex argument.\nsf’s plot method also arguments specific geographic data. expandBB, example, can used plot sf object context:\ntakes numeric vector length four expands bounding box plot relative zero following order: bottom, left, top, right.\nused plot India context giant Asian neighbors, emphasis China east, following code chunk, generates Figure 2.6 (see exercises adding text plots):\nFIGURE 2.6: India context, demonstrating expandBB argument.\nNote use [0] keep geometry column lwd emphasize India.\nSee Section ?? visualization techniques representing range geometry types, subject next section.","code":"\nplot(world[\"continent\"], reset = FALSE)\ncex = sqrt(world$pop) / 10000\nworld_cents = st_centroid(world, of_largest = TRUE)\nplot(st_geometry(world_cents), add = TRUE, cex = cex)\nindia = world[world$name_long == \"India\", ]\nplot(st_geometry(india), expandBB = c(0, 0.2, 0.1, 1), col = \"gray\", lwd = 3)\nplot(world_asia[0], add = TRUE)"},{"path":"spatial-class.html","id":"geometry","chapter":"2 Geographic data in R","heading":"2.2.5 Geometry types","text":"Geometries basic building blocks simple features.\nSimple features R can take one 17 geometry types supported sf package.\n\n\nchapter focus seven commonly used types: POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON GEOMETRYCOLLECTION.\nFind whole list possible feature types PostGIS manual.Generally, well-known binary (WKB) well-known text (WKT) standard encoding simple feature geometries.\n\n\n\nWKB representations usually hexadecimal strings easily readable computers.\nGIS spatial databases use WKB transfer store geometry objects.\nWKT, hand, human-readable text markup description simple features.\nformats exchangeable, present one, naturally choose WKT representation.basis geometry type point.\npoint simply coordinate 2D, 3D 4D space (see vignette(\"sf1\") information) (see left panel Figure 2.7):\nPOINT (5 2)\nlinestring sequence points straight line connecting points, example (see middle panel Figure 2.7):LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)polygon sequence points form closed, non-intersecting ring.\nClosed means first last point polygon coordinates (see right panel Figure 2.7).9\nPolygon without hole: POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))\nFIGURE 2.7: Illustration point, linestring polygon geometries.\nfar created geometries one geometric entity per feature.\nHowever, sf also allows multiple geometries exist within single feature (hence term ‘geometry collection’) using “multi” version geometry type:\nMultipoint: MULTIPOINT (5 2, 1 3, 3 4, 3 2)Multilinestring: MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))Multipolygon: MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5), (0 2, 1 2, 1 3, 0 3, 0 2)))\nFIGURE 2.8: Illustration multi* geometries.\nFinally, geometry collection can contain combination geometries including (multi)points linestrings (see Figure 2.9):\nGeometry collection: GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2), LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))\nFIGURE 2.9: Illustration geometry collection.\n","code":""},{"path":"spatial-class.html","id":"sfg","chapter":"2 Geographic data in R","heading":"2.2.6 Simple feature geometries (sfg)","text":"sfg class represents different simple feature geometry types R: point, linestring, polygon (‘multi’ equivalents, multipoints) geometry collection.\nUsually spared tedious task creating geometries since can simply import already existing spatial file.\nHowever, set functions create simple feature geometry objects (sfg) scratch needed.\nnames functions simple consistent, start st_ prefix end name geometry type lowercase letters:point: st_point()linestring: st_linestring()polygon: st_polygon()multipoint: st_multipoint()multilinestring: st_multilinestring()multipolygon: st_multipolygon()geometry collection: st_geometrycollection()sfg objects can created three base R data types:numeric vector: single pointA matrix: set points, row represents point, multipoint linestringA list: collection objects matrices, multilinestrings geometry collectionsThe function st_point() creates single points numeric vectors:results show XY (2D coordinates), XYZ (3D coordinates) XYZM (3D additional variable, typically measurement accuracy) point types created vectors length 2, 3, 4, respectively.\nXYM type must specified using dim argument (short dimension).contrast, use matrices case multipoint (st_multipoint()) linestring (st_linestring()) objects:Finally, use lists creation multilinestrings, (multi-)polygons geometry collections:","code":"\nst_point(c(5, 2))                 # XY point\n#> POINT (5 2)\nst_point(c(5, 2, 3))              # XYZ point\n#> POINT Z (5 2 3)\nst_point(c(5, 2, 1), dim = \"XYM\") # XYM point\n#> POINT M (5 2 1)\nst_point(c(5, 2, 3, 1))           # XYZM point\n#> POINT ZM (5 2 3 1)\n# the rbind function simplifies the creation of matrices\n## MULTIPOINT\nmultipoint_matrix = rbind(c(5, 2), c(1, 3), c(3, 4), c(3, 2))\nst_multipoint(multipoint_matrix)\n#> MULTIPOINT ((5 2), (1 3), (3 4), (3 2))\n## LINESTRING\nlinestring_matrix = rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2))\nst_linestring(linestring_matrix)\n#> LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)\n## POLYGON\npolygon_list = list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))\nst_polygon(polygon_list)\n#> POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))\n## POLYGON with a hole\npolygon_border = rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))\npolygon_hole = rbind(c(2, 4), c(3, 4), c(3, 3), c(2, 3), c(2, 4))\npolygon_with_hole_list = list(polygon_border, polygon_hole)\nst_polygon(polygon_with_hole_list)\n#> POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4))\n## MULTILINESTRING\nmultilinestring_list = list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), \n                            rbind(c(1, 2), c(2, 4)))\nst_multilinestring((multilinestring_list))\n#> MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))\n## MULTIPOLYGON\nmultipolygon_list = list(list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))),\n                         list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2))))\nst_multipolygon(multipolygon_list)\n#> MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5)), ((0 2, 1 2, 1 3, 0 3, 0 2)))\n## GEOMETRYCOLLECTION\ngemetrycollection_list = list(st_multipoint(multipoint_matrix),\n                              st_linestring(linestring_matrix))\nst_geometrycollection(gemetrycollection_list)\n#> GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2),\n#>   LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))"},{"path":"spatial-class.html","id":"sfc","chapter":"2 Geographic data in R","heading":"2.2.7 Simple feature columns (sfc)","text":"One sfg object contains single simple feature geometry.\nsimple feature geometry column (sfc) list sfg objects, additionally able contain information coordinate reference system use.\ninstance, combine two simple features one object two features, can use st_sfc() function.\n\nimportant since sfc represents geometry column sf data frames:cases, sfc object contains objects geometry type.\nTherefore, convert sfg objects type polygon simple feature geometry column, also end sfc object type polygon, can verified st_geometry_type().\nEqually, geometry column multilinestrings result sfc object type multilinestring:also possible create sfc object sfg objects different geometry types:mentioned , sfc objects can additionally store information coordinate reference systems (CRS).\nspecify certain CRS, can use epsg (SRID) proj4string attributes sfc object.\ndefault value epsg (SRID) proj4string NA (Available), can verified st_crs():geometries sfc object must CRS.\ncan add coordinate reference system crs argument st_sfc().\nargument accepts integer epsg code 4326, automatically adds ‘proj4string’ (see Section 2.4):also accepts raw proj4string (result shown):","code":"\n# sfc POINT\npoint1 = st_point(c(5, 2))\npoint2 = st_point(c(1, 3))\npoints_sfc = st_sfc(point1, point2)\npoints_sfc\n#> Geometry set for 2 features \n#> Geometry type: POINT\n#> Dimension:     XY\n#> Bounding box:  xmin: 1 ymin: 2 xmax: 5 ymax: 3\n#> CRS:           NA\n#> POINT (5 2)\n#> POINT (1 3)\n# sfc POLYGON\npolygon_list1 = list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))\npolygon1 = st_polygon(polygon_list1)\npolygon_list2 = list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2)))\npolygon2 = st_polygon(polygon_list2)\npolygon_sfc = st_sfc(polygon1, polygon2)\nst_geometry_type(polygon_sfc)\n#> [1] POLYGON POLYGON\n#> 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n# sfc MULTILINESTRING\nmultilinestring_list1 = list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), \n                            rbind(c(1, 2), c(2, 4)))\nmultilinestring1 = st_multilinestring((multilinestring_list1))\nmultilinestring_list2 = list(rbind(c(2, 9), c(7, 9), c(5, 6), c(4, 7), c(2, 7)), \n                            rbind(c(1, 7), c(3, 8)))\nmultilinestring2 = st_multilinestring((multilinestring_list2))\nmultilinestring_sfc = st_sfc(multilinestring1, multilinestring2)\nst_geometry_type(multilinestring_sfc)\n#> [1] MULTILINESTRING MULTILINESTRING\n#> 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n# sfc GEOMETRY\npoint_multilinestring_sfc = st_sfc(point1, multilinestring1)\nst_geometry_type(point_multilinestring_sfc)\n#> [1] POINT           MULTILINESTRING\n#> 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\nst_crs(points_sfc)\n#> Coordinate Reference System: NA\n# EPSG definition\npoints_sfc_wgs = st_sfc(point1, point2, crs = 4326)\nst_crs(points_sfc_wgs)\n#> Coordinate Reference System:\n#>   User input: EPSG:4326 \n#>   wkt:\n#> GEOGCRS[\"WGS 84\",\n#>     DATUM[\"World Geodetic System 1984\",\n#>         ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n#>             LENGTHUNIT[\"metre\",1]]],\n#>     PRIMEM[\"Greenwich\",0,\n#>         ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>     CS[ellipsoidal,2],\n#>         AXIS[\"geodetic latitude (Lat)\",north,\n#>             ORDER[1],\n#>             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>         AXIS[\"geodetic longitude (Lon)\",east,\n#>             ORDER[2],\n#>             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>     USAGE[\n#>         SCOPE[\"Horizontal component of 3D system.\"],\n#>         AREA[\"World.\"],\n#>         BBOX[-90,-180,90,180]],\n#>     ID[\"EPSG\",4326]]\n# PROJ4STRING definition\nst_sfc(point1, point2, crs = \"+proj=longlat +datum=WGS84 +no_defs\")"},{"path":"spatial-class.html","id":"sf","chapter":"2 Geographic data in R","heading":"2.2.8 The sf class","text":"Sections 2.2.5 2.2.7 deal purely geometric objects, ‘sf geometry’ ‘sf column’ objects, respectively.\ngeographic building blocks geographic vector data represented simple features.\nfinal building block non-geographic attributes, representing name feature attributes measured values, groups, things.\nillustrate attributes, represent temperature 25°C London June 21st, 2017.\nexample contains geometry (coordinates), three attributes three different classes (place name, temperature date).10\nObjects class sf represent data combining attributes (data.frame) simple feature geometry column (sfc).\ncreated st_sf() illustrated , creates London example described :just happened? First, coordinates used create simple feature geometry (sfg).\nSecond, geometry converted simple feature geometry column (sfc), CRS.\nThird, attributes stored data.frame, combined sfc object st_sf().\nresults sf object, demonstrated (output omitted):result shows sf objects actually two classes, sf data.frame.\nSimple features simply data frames (square tables), spatial attributes stored list column, usually called geometry, described Section 2.2.1.\nduality central concept simple features:\ntime sf can treated behaves like data.frame.\nSimple features , essence, data frames spatial extension.","code":"\nlnd_point = st_point(c(0.1, 51.5))                 # sfg object\nlnd_geom = st_sfc(lnd_point, crs = 4326)           # sfc object\nlnd_attrib = data.frame(                           # data.frame object\n  name = \"London\",\n  temperature = 25,\n  date = as.Date(\"2017-06-21\")\n  )\nlnd_sf = st_sf(lnd_attrib, geometry = lnd_geom)    # sf object\nlnd_sf\n#> Simple feature collection with 1 features and 3 fields\n#> ...\n#>     name temperature       date         geometry\n#> 1 London          25 2017-06-21 POINT (0.1 51.5)\nclass(lnd_sf)\n#> [1] \"sf\"         \"data.frame\""},{"path":"spatial-class.html","id":"raster-data","chapter":"2 Geographic data in R","heading":"2.3 Raster data","text":"spatial raster data model represents world continuous grid cells (often also called pixels; Figure 2.10:).\ndata model often refers -called regular grids, cell , constant size – focus regular grids book .\nHowever, several types grids exist, including rotated, sheared, rectilinear, curvilinear grids (see Chapter 1 (???) Chapter 2 (???)).raster data model usually consists raster header\nmatrix (rows columns) representing equally spaced cells (often also called pixels; Figure 2.10:).11\nraster header defines coordinate reference system, extent origin.\n\n\norigin (starting point) frequently coordinate lower-left corner matrix (terra package, however, uses upper left corner, default (Figure 2.10:B)).\nheader defines extent via number columns, number rows cell size resolution.\nHence, starting origin, can easily access modify single cell either using ID cell (Figure 2.10:B) explicitly specifying rows columns.\nmatrix representation avoids storing explicitly coordinates four corner points (fact stores one coordinate, namely origin) cell corner case rectangular vector polygons.\nmap algebra (Section (map-algebra)) makes raster processing much efficient faster vector data processing.\nHowever, contrast vector data, cell one raster layer can hold single value.\nvalue might numeric categorical (Figure 2.10:C).\nFIGURE 2.10: Raster data types: () cell IDs, (B) cell values, (C) colored raster map.\nRaster maps usually represent continuous phenomena elevation, temperature, population density spectral data (Figure 2.11).\ncourse, can represent discrete features soil land-cover classes also help raster data model (Figure 2.11).\nConsequently, discrete borders features become blurred, depending spatial task vector representation might suitable.\nFIGURE 2.11: Examples continuous categorical rasters.\n","code":""},{"path":"spatial-class.html","id":"r-packages-for-raster-data-handling","chapter":"2 Geographic data in R","heading":"2.3.1 R packages for raster data handling","text":"","code":""},{"path":"spatial-class.html","id":"an-introduction-to-terra","chapter":"2 Geographic data in R","heading":"2.3.2 An introduction to terra","text":"terra package supports raster objects R.\nprovides extensive set functions create, read, export, manipulate process raster datasets.\nAside general raster data manipulation, terra provides many low-level functions can form basis develop advanced raster functionality.\n\nterra also lets work large raster datasets large fit main memory.\ncase, terra provides possibility divide raster smaller chunks, processes iteratively instead loading whole raster file RAM.illustration terra concepts, use datasets spDataLarge.\nconsists raster objects one vector object covering area Zion National Park (Utah, USA).\nexample, srtm.tif digital elevation model area (details, see documentation ?srtm).\nFirst, let’s create SpatRaster object named my_rast:Typing name raster console, print raster header (dimensions, resolution, extent, CRS) additional information (class, data source, summary raster values):Dedicated functions report component: dim(my_rast) returns number rows, columns layers; ncell() number cells (pixels); res() spatial resolution; ext() spatial extent; crs() coordinate reference system (raster reprojection covered Section ??).\ninMemory() reports whether raster data stored memory disk.help(\"terra-package\") returns full list available terra functions.","code":"\nraster_filepath = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nmy_rast = rast(raster_filepath)\nmy_rast\n#> class       : SpatRaster \n#> dimensions  : 457, 465, 1  (nrow, ncol, nlyr)\n#> resolution  : 0.000833, 0.000833  (x, y)\n#> extent      : -113, -113, 37.1, 37.5  (xmin, xmax, ymin, ymax)\n#> coord. ref. : +proj=longlat +datum=WGS84 +no_defs \n#> source      : srtm.tif \n#> name        : srtm \n#> min value   : 1024 \n#> max value   : 2892"},{"path":"spatial-class.html","id":"basic-map-raster","chapter":"2 Geographic data in R","heading":"2.3.3 Basic map making","text":"Similar sf package, terra also provides plot() methods classes.\n\nFIGURE 2.12: Basic raster plot.\nseveral approaches plotting raster data R outside scope section, including:packages tmap create static interactive maps raster vector objects (see Chapter ??)functions, example levelplot() rasterVis package, create facets, common technique visualizing change time","code":"\nplot(my_rast)"},{"path":"spatial-class.html","id":"raster-classes","chapter":"2 Geographic data in R","heading":"2.3.4 Raster classes","text":"SpatRaster class represents rasters object terra.\neasiest way create raster object R read-raster file disk server (Section ??.\nterra package supports numerous drivers help GDAL library.\nRasters files usually read entirely RAM, exception header pointer file .Rasters can also created scratch using rast() function.\nillustrated subsequent code chunk, results new SpatRaster object.\nresulting raster consists 36 cells (6 columns 6 rows specified nrows ncols) centered around Prime Meridian Equator (see xmin, xmax, ymin ymax parameters).\ndefault CRS raster objects WGS84, can changed crs argument.\nmeans unit resolution degrees set 0.5 (resolution).\nValues (vals) assigned cell: 1 cell 1, 2 cell 2, .\nRemember: rast() fills cells row-wise (unlike matrix()) starting upper left corner, meaning top row contains values 1 6, second 7 12, etc.ways creating raster objects, see ?rast.SpatRaster class also handles multiple layers, typically correspond single multispectral satellite file time-series rasters.nlyr() retrieves number layers stored SpatRaster object:","code":"\nsingle_raster_file = system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nsingle_rast = rast(raster_filepath)\nnew_raster = rast(nrows = 6, ncols = 6, resolution = 0.5, \n                  xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n                  vals = 1:36)\nmulti_raster_file = system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmulti_rast = rast(multi_raster_file)\nmulti_rast\n#> class       : SpatRaster \n#> dimensions  : 1428, 1128, 4  (nrow, ncol, nlyr)\n#> resolution  : 30, 30  (x, y)\n#> extent      : 301905, 335745, 4111245, 4154085  (xmin, xmax, ymin, ymax)\n#> coord. ref. : +proj=utm +zone=12 +datum=WGS84 +units=m +no_defs \n#> source      : landsat.tif \n#> names       : lan_1, lan_2, lan_3, lan_4 \n#> min values  :  7550,  6404,  5678,  5252 \n#> max values  : 19071, 22051, 25780, 31961\nnlyr(multi_rast)\n#> [1] 4"},{"path":"spatial-class.html","id":"crs-intro","chapter":"2 Geographic data in R","heading":"2.4 Coordinate Reference Systems","text":"\nVector raster spatial data types share concepts intrinsic spatial data.\nPerhaps fundamental Coordinate Reference System (CRS), defines spatial elements data relate surface Earth (bodies).\nCRSs either geographic projected, introduced beginning chapter (see Figure 2.1).\nsection explain type, laying foundations Section ?? CRS transformations.","code":""},{"path":"spatial-class.html","id":"geographic-coordinate-systems","chapter":"2 Geographic data in R","heading":"2.4.1 Geographic coordinate systems","text":"\nGeographic coordinate systems identify location Earth’s surface using two values — longitude latitude (see left panels Figures 2.13 2.14).\nLongitude location East-West direction angular distance Prime Meridian plane.\nLatitude angular distance North South equatorial plane.\nDistances geographic CRSs therefore measured meters.\nimportant consequences, demonstrated Section ??.surface Earth geographic coordinate systems represented spherical ellipsoidal surface.\nSpherical models assume Earth perfect sphere given radius.\nSpherical models advantage simplicity , time, inaccurate: Earth sphere!\nEllipsoidal models defined two parameters: equatorial radius polar radius.\nsuitable Earth compressed: equatorial radius around 11.5 km longer polar radius (Maling 1992).12Ellipsoids part wider component CRSs: datum.\ncontains information ellipsoid use precise relationship Cartesian coordinates location Earth’s surface.\n\n\ntwo types datum — geocentric local.\ngeocentric datum, WGS84, center Earth’s center gravity accuracy projections optimized specific location.\nlocal datum, NAD83, ellipsoidal surface shifted align surface particular location.\n\n","code":""},{"path":"spatial-class.html","id":"projected-coordinate-reference-systems","chapter":"2 Geographic data in R","heading":"2.4.2 Projected coordinate reference systems","text":"\nProjected CRSs based Cartesian coordinates implicitly flat surface (right panels Figures 2.13 2.14).\norigin, x y axes, linear unit measurement meters.\nprojected CRSs based geographic CRS, described previous section, rely map projections convert three-dimensional surface Earth Easting Northing (x y) values projected CRS.transition done without adding deformations.\nTherefore, properties Earth’s surface distorted process, area, direction, distance, shape.\nprojected coordinate system can preserve one two properties.\nProjections often named based property preserve: equal-area preserves area, azimuthal preserve direction, equidistant preserve distance, conformal preserve local shape.\n\nthree main groups projection types - conic, cylindrical, planar.\nconic projection, Earth’s surface projected onto cone along single line tangency two lines tangency.\nDistortions minimized along tangency lines rise distance lines projection.\nTherefore, best suited maps mid-latitude areas.\ncylindrical projection maps surface onto cylinder.\nprojection also created touching Earth’s surface along single line tangency two lines tangency.\nCylindrical projections used often mapping entire world.\nplanar projection projects data onto flat surface touching globe point along line tangency.\ntypically used mapping polar regions.\nsf_proj_info(type = \"proj\") gives list available projections supported PROJ library.\nFIGURE 2.13: Examples geographic (WGS 84; left) projected (NAD83 / UTM zone 12N; right) coordinate systems vector data type.\n\nFIGURE 2.14: Examples geographic (WGS 84; left) projected (NAD83 / UTM zone 12N; right) coordinate systems raster data.\n","code":""},{"path":"spatial-class.html","id":"crs-in-r","chapter":"2 Geographic data in R","heading":"2.4.3 CRSs in R","text":"\n\n\nTwo recommend ways describe CRSs R () Spatial Reference System Identifier (SRID) (b) WKT2 definition.\napproaches advantages disadvantages.epsg code usually shorter, therefore easier remember.\ncode also refers one, well-defined coordinate reference system.Spatial R packages support wide range CRSs use long-established PROJ library.\n\n\n\n\nsf CRS object can retrieved using st_crs().\n, need read-vector dataset:new object, new_vector, polygon representing borders Zion National Park (?zion).cases coordinate reference system (CRS) missing wrong CRS set, st_set_crs() function can used:warning message informs us st_set_crs() function transform data one CRS another.crs() function can used access CRS information SpatRaster object:function, crs(), used set CRS raster objects.Importantly, st_crs() crs() functions alter coordinates’ values geometries.\nrole set metadata information object CRS.\nexpand CRSs explain project one CRS another Chapter ??.","code":"\nvector_filepath = system.file(\"vector/zion.gpkg\", package = \"spDataLarge\")\nnew_vector = st_read(vector_filepath)\nst_crs(new_vector) # get CRS\n#> Coordinate Reference System:\n#>   User input: UTM Zone 12, Northern Hemisphere \n#>   wkt:\n#> BOUNDCRS[\n#>     SOURCECRS[\n#>         PROJCRS[\"UTM Zone 12, Northern Hemisphere\",\n#>             BASEGEOGCRS[\"GRS 1980(IUGG, 1980)\",\n#>                 DATUM[\"unknown\",\n#>                     ELLIPSOID[\"GRS80\",6378137,298.257222101,\n#>                         LENGTHUNIT[\"metre\",1,\n#>                             ID[\"EPSG\",9001]]]],\n#>                 PRIMEM[\"Greenwich\",0,\n#>                     ANGLEUNIT[\"degree\",0.0174532925199433]]],\n#>             CONVERSION[\"UTM zone 12N\",\n#>                 METHOD[\"Transverse Mercator\",\n#>                     ID[\"EPSG\",9807]],\n#>                 PARAMETER[\"Latitude of natural origin\",0,\n#>                     ANGLEUNIT[\"degree\",0.0174532925199433],\n#>                     ID[\"EPSG\",8801]],\n#>                 PARAMETER[\"Longitude of natural origin\",-111,\n#>                     ANGLEUNIT[\"degree\",0.0174532925199433],\n#>                     ID[\"EPSG\",8802]],\n#>                 PARAMETER[\"Scale factor at natural origin\",0.9996,\n#>                     SCALEUNIT[\"unity\",1],\n#>                     ID[\"EPSG\",8805]],\n#>                 PARAMETER[\"False easting\",500000,\n#>                     LENGTHUNIT[\"Meter\",1],\n#>                     ID[\"EPSG\",8806]],\n#>                 PARAMETER[\"False northing\",0,\n#>                     LENGTHUNIT[\"Meter\",1],\n#>                     ID[\"EPSG\",8807]],\n#>                 ID[\"EPSG\",16012]],\n#>             CS[Cartesian,2],\n#>                 AXIS[\"(E)\",east,\n#>                     ORDER[1],\n#>                     LENGTHUNIT[\"Meter\",1]],\n#>                 AXIS[\"(N)\",north,\n#>                     ORDER[2],\n#>                     LENGTHUNIT[\"Meter\",1]]]],\n#>     TARGETCRS[\n#>         GEOGCRS[\"WGS 84\",\n#>             DATUM[\"World Geodetic System 1984\",\n#>                 ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n#>                     LENGTHUNIT[\"metre\",1]]],\n#>             PRIMEM[\"Greenwich\",0,\n#>                 ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>             CS[ellipsoidal,2],\n#>                 AXIS[\"latitude\",north,\n#>                     ORDER[1],\n#>                     ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>                 AXIS[\"longitude\",east,\n#>                     ORDER[2],\n#>                     ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>             ID[\"EPSG\",4326]]],\n#>     ABRIDGEDTRANSFORMATION[\"Transformation from GRS 1980(IUGG, 1980) to WGS84\",\n#>         METHOD[\"Position Vector transformation (geog2D domain)\",\n#>             ID[\"EPSG\",9606]],\n#>         PARAMETER[\"X-axis translation\",0,\n#>             ID[\"EPSG\",8605]],\n#>         PARAMETER[\"Y-axis translation\",0,\n#>             ID[\"EPSG\",8606]],\n#>         PARAMETER[\"Z-axis translation\",0,\n#>             ID[\"EPSG\",8607]],\n#>         PARAMETER[\"X-axis rotation\",0,\n#>             ID[\"EPSG\",8608]],\n#>         PARAMETER[\"Y-axis rotation\",0,\n#>             ID[\"EPSG\",8609]],\n#>         PARAMETER[\"Z-axis rotation\",0,\n#>             ID[\"EPSG\",8610]],\n#>         PARAMETER[\"Scale difference\",1,\n#>             ID[\"EPSG\",8611]]]]\nnew_vector = st_set_crs(new_vector, \"EPSG:26912\") # set CRS\n#> Warning: st_crs<- : replacing crs does not reproject data; use st_transform for\n#> that\ncrs(my_rast) # get CRS\n#> [1] \"GEOGCRS[\\\"WGS 84\\\",\\n    DATUM[\\\"World Geodetic System 1984\\\",\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"geodetic latitude (Lat)\\\",north,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        AXIS[\\\"geodetic longitude (Lon)\\\",east,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    ID[\\\"EPSG\\\",4326]]\"\nmy_rast2 = my_rast\ncrs(my_rast2) = \"EPSG:26912\" # set CRS"},{"path":"spatial-class.html","id":"units","chapter":"2 Geographic data in R","heading":"2.5 Units","text":"important feature CRSs contain information spatial units.\nClearly, vital know whether house’s measurements feet meters, applies maps.\ngood cartographic practice add scale bar distance indicator onto maps demonstrate relationship distances page screen distances ground.\nLikewise, important formally specify units geometry data cells measured provide context, ensure subsequent calculations done context.novel feature geometry data sf objects native support units.\nmeans distance, area geometric calculations sf return values come units attribute, defined units package (Pebesma, Mailund, Hiebert 2016).\nadvantageous, preventing confusion caused different units (CRSs use meters, use feet) providing information dimensionality.\ndemonstrated code chunk , calculates area Luxembourg:\n\noutput units square meters (m2), showing result represents two-dimensional space.\ninformation, stored attribute (interested readers can discover attributes(st_area(luxembourg))), can feed subsequent calculations use units, population density (measured people per unit area, typically per km2).\nReporting units prevents confusion.\ntake Luxembourg example, units remained unspecified, one incorrectly assume units hectares.\ntranslate huge number digestible size, tempting divide results million (number square meters square kilometer):However, result incorrectly given square meters.\nsolution set correct units units package:Units equal importance case raster data.\nHowever, far sf spatial package supports units, meaning people working raster data approach changes units analysis (example, converting pixel widths imperial decimal units) care.\nmy_rast object (see ) uses WGS84 projection decimal degrees units.\nConsequently, resolution also given decimal degrees know , since res() function simply returns numeric vector.used UTM projection, units change., res() command gives back numeric vector without unit, forcing us know unit UTM projection meters.","code":"\nluxembourg = world[world$name_long == \"Luxembourg\", ]\nst_area(luxembourg) # requires the s2 package in recent versions of sf\n#> 2.41e+09 [m^2]\nst_area(luxembourg) / 1000000\n#> 2409 [m^2]\nunits::set_units(st_area(luxembourg), km^2)\n#> 2409 [km^2]\nres(my_rast)\n#> [1] 0.000833 0.000833\nrepr = project(my_rast, \"EPSG:26912\")\nres(repr)"},{"path":"spatial-class.html","id":"ex2","chapter":"2 Geographic data in R","heading":"2.6 Exercises","text":"Akima, Hiroshi, Albrecht Gebhardt. 2016. Akima: Interpolation Irregularly Regularly Spaced Data.Baddeley, Adrian, Ege Rubak, Rolf Turner. 2015. Spatial Point Patterns: Methodology Applications R. CRC Press.Bivand, Roger. 2001. “Spatial Data Analysis.” R News 1 (3): 13–17.———. 2003. “Approaches Classes Spatial Data R.” Proceedings DSC, edited Kurt Hornik, Friedrich Leisch, Achim Zeileis.———. 2016a. Rgrass7: Interface GRASS 7 Geographical Information System R.———. 2016b. Spgrass6: Interface GRASS 6 R.———. 2017. Spdep: Spatial Dependence: Weighting Schemes, Statistics Models.Bivand, Roger, Albrecht Gebhardt. 2000. “Implementing Functions Spatial Statistical Analysis Using Language.” Journal Geographical Systems 2 (3): 307–17.Bivand, Roger, Tim Keitt, Barry Rowlingson. 2018. Rgdal: Bindings ’Geospatial’ Data Abstraction Library. https://CRAN.R-project.org/package=rgdal.Bivand, Roger, Nicholas Lewin-Koh. 2017. Maptools: Tools Reading Handling Spatial Objects.Bivand, Roger, Markus Neteler. 2000. “Open Source Geocomputation: Using R Data Analysis Language Integrated GRASS GIS PostgreSQL Data Base Systems.” Proceedings 5th International Conference GeoComputation, edited Markus Neteler Roger S. Bivand.Bivand, Roger, Edzer J Pebesma, Virgilio Gómez-Rubio. 2013. Applied Spatial Data Analysis R. Vol. 747248717. Springer.Bivand, Roger, Colin Rundel. 2018. Rgeos: Interface Geometry Engine - Open Source (’Geos’). https://CRAN.R-project.org/package=rgeos.Bivand, Roger S. 2000. “Using R Statistical Data Analysis Language GRASS 5.0 GIS Database Files.” Computers & Geosciences 26 (9): 1043–52.Brenning, Alexander. 2012. ArcGIS Geoprocessing R via Python.Brenning, Alexander, Donovan Bangs, Marc Becker. 2018. RSAGA: SAGA Geoprocessing Terrain Analysis. https://CRAN.R-project.org/package=RSAGA.Brzustowicz, Michael R. 2017. Data Science Java: [Practical Methods Scientists Engineers]. First. Beijing Boston Farnham: OReilly.Calenge, C. 2006. “Package Adehabitat R Software: Tool Analysis Space Habitat Use Animals.” Ecological Modelling 197: 1035.Chambers, John M. 2016. Extending R. CRC Press.Coppock, J Terry, David W Rhind. 1991. “History GIS.” Geographical Information Systems: Principles Applications, Vol. 1. 1 (1): 21–43.Eddelbuettel, Dirk, James Joseph Balamuta. 2018. “Extending R C++: Brief Introduction Rcpp.” American Statistician 72 (1): 28–36. https://doi.org/10.1080/00031305.2017.1375990.Garrard, Chris. 2016. Geoprocessing Python. Shelter Island, NY: Manning Publications.Gillespie, Colin, Robin Lovelace. 2016. Efficient R Programming: Practical Guide Smarter Programming. O’Reilly Media.Grolemund, Garrett, Hadley Wickham. 2016. R Data Science. O’Reilly Media.Hijmans, Robert J. 2016. Geosphere: Spherical Trigonometry.———. 2017. Raster: Geographic Data Analysis Modeling. https://CRAN.R-project.org/package=raster.Kahle, D, Hadley Wickham. 2013. “Ggmap: Spatial Visualization Ggplot2.” R Journal 5: 144–61.Lamigueiro, Oscar Perpinan. 2018. Displaying Time Series, Spatial, Space-Time Data R. Second. Boca Raton: Chapman Hall/CRC.Livingstone, David N. 1992. Geographical Tradition: Episodes History Contested Enterprise. Oxford, UK ; Cambridge, USA: John Wiley & Sons Ltd.Longley, Paul. 2015. Geographic Information Science & Systems. Fourth edition. Hoboken, NJ: Wiley.Longley, Paul ., Sue M. Brooks, Rachael McDonnell, Bill MacMillan, eds. 1998. Geocomputation: Primer. Chichester, Eng. ; New York: Wiley.Majure, James J., Albrecht Gebhardt. 2016. Sgeostat: Object-Oriented Framework Geostatistical Modeling S+.Maling, D. H. 1992. Coordinate Systems Map Projections. Second. Oxford ; New York: Pergamon Press.Muenchow, Jannes, Patrick Schratz, Alexander Brenning. 2017. “RQGIS: Integrating R QGIS Statistical Geocomputing.” R Journal 9 (2): 409–28.Neteler, Markus, Helena Mitasova. 2008. Open Source GIS: GRASS GIS Approach. Third. New York, NY: Springer.Openshaw, Stan, Robert J. Abrahart, eds. 2000. Geocomputation. London ; New York: CRC Press.Pebesma, Edzer. 2018. “Simple Features R: Standardized Support Spatial Vector Data.” R Journal.Pebesma, Edzer, Roger Bivand. 2018. Sp: Classes Methods Spatial Data. https://CRAN.R-project.org/package=sp.Pebesma, Edzer, Benedikt Graeler. 2018. Gstat: Spatial Spatio-Temporal Geostatistical Modelling, Prediction Simulation. https://CRAN.R-project.org/package=gstat.Pebesma, Edzer J, Roger S Bivand. 2005. “Classes Methods Spatial Data R.” R News 5 (2): 9–13.Pebesma, Edzer, Thomas Mailund, James Hiebert. 2016. “Measurement Units R.” R Journal 8 (2): 486–94.Pebesma, Edzer, Daniel Nüst, Roger Bivand. 2012. “R Software Environment Reproducible Geoscientific Research.” Eos, Transactions American Geophysical Union 93 (16): 163–63. https://doi.org/10.1029/2012EO160003.Ribeiro Jr, Paulo J., Peter J. Diggle. 2016. geoR: Analysis Geostatistical Data.Ripley, Brian D. 2001. “Spatial Statistics R.” R News 1 (2): 14–15.Rowlingson, Barry, Adrian Baddeley, Rolf Turner, Peter Diggle. 2003. “Rasp: Package Spatial Statistics.” Proceedings 3rd International Workshop Distributed Statistical Computing, edited Kurt Hornik.Rowlingson, Barry, Peter Diggle. 2017. Splancs: Spatial Space-Time Point Pattern Analysis.Rowlingson, B. S, P. J Diggle. 1993. “Splancs: Spatial Point Pattern Analysis Code S-Plus.” Computers & Geosciences 19 (5): 627–55. https://doi.org/10.1016/0098-3004(93)90099-Q.Sherman, Gary. 2008. Desktop GIS: Mapping Planet Open Source Tools. Pragmatic Bookshelf.Talbert, Richard J. . 2014. Ancient Perspectives: Maps Place Mesopotamia, Egypt, Greece, Rome. University Chicago Press.Economist. 2016. “Autonomous Car’s Reality Check.” Economist.Venables, W. N., B. D. Ripley. 2002. Modern Applied Statistics S. Fourth. New York: Springer.Venables, W. N., D. M. Smith, R Core Team. 2017. Introduction R. Notes R: Programming Environment Data Analysis Graphics.Wickham, Hadley. 2014. Advanced R. CRC Press.Wulf, Andrea. 2015. Invention Nature: Alexander von Humboldt’s New World. New York: Alfred . Knopf.","code":""}]
